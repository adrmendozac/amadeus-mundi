


declare namespace firebase {
  
  type NextFn<T> = (value: T) => void;
  
  type ErrorFn<E = Error> = (error: E) => void;
  
  type CompleteFn = () => void;

  
  interface FirebaseError {
    
    code: string;
    
    message: string;
    
    name: 'FirebaseError';
    
    stack?: string;
  }

  
  interface Observer<T, E = Error> {
    next: NextFn<T>;
    error: ErrorFn<E>;
    complete: CompleteFn;
  }

  
  type LogLevel = 'debug' | 'verbose' | 'info' | 'warn' | 'error' | 'silent';

  
  var SDK_VERSION: string;

  
  function registerVersion(
    library: string,
    version: string,
    variant?: string
  ): void;

  
  function setLogLevel(logLevel: LogLevel): void;

  
  function onLog(
    logCallback: (callbackParams: {
      
      level: LogLevel;
      
      message: string;
      
      args: any[];
      
      type: string;
    }) => void,
    options?: {
      
      level: LogLevel;
    }
  ): void;

  
  type Unsubscribe = () => void;

  
  interface User extends firebase.UserInfo {
    
    delete(): Promise<void>;
    emailVerified: boolean;
    getIdTokenResult(
      forceRefresh?: boolean
    ): Promise<firebase.auth.IdTokenResult>;
    
    getIdToken(forceRefresh?: boolean): Promise<string>;
    isAnonymous: boolean;
    
    linkAndRetrieveDataWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    linkWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    linkWithPhoneNumber(
      phoneNumber: string,
      applicationVerifier: firebase.auth.ApplicationVerifier
    ): Promise<firebase.auth.ConfirmationResult>;
    
    linkWithPopup(
      provider: firebase.auth.AuthProvider
    ): Promise<firebase.auth.UserCredential>;
    
    linkWithRedirect(provider: firebase.auth.AuthProvider): Promise<void>;
    metadata: firebase.auth.UserMetadata;
    

    multiFactor: firebase.User.MultiFactorUser;
    
    phoneNumber: string | null;
    providerData: (firebase.UserInfo | null)[];
    
    reauthenticateAndRetrieveDataWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    reauthenticateWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    reauthenticateWithPhoneNumber(
      phoneNumber: string,
      applicationVerifier: firebase.auth.ApplicationVerifier
    ): Promise<firebase.auth.ConfirmationResult>;
    
    reauthenticateWithPopup(
      provider: firebase.auth.AuthProvider
    ): Promise<firebase.auth.UserCredential>;
    
    reauthenticateWithRedirect(
      provider: firebase.auth.AuthProvider
    ): Promise<void>;
    refreshToken: string;
    
    reload(): Promise<void>;
    
    sendEmailVerification(
      actionCodeSettings?: firebase.auth.ActionCodeSettings | null
    ): Promise<void>;
    
    tenantId: string | null;
    
    toJSON(): Object;
    
    unlink(providerId: string): Promise<firebase.User>;
    
    updateEmail(newEmail: string): Promise<void>;
    
    updatePassword(newPassword: string): Promise<void>;
    
    updatePhoneNumber(
      phoneCredential: firebase.auth.AuthCredential
    ): Promise<void>;
    
    updateProfile(profile: {
      displayName?: string | null;
      photoURL?: string | null;
    }): Promise<void>;
    
    verifyBeforeUpdateEmail(
      newEmail: string,
      actionCodeSettings?: firebase.auth.ActionCodeSettings | null
    ): Promise<void>;
  }

  
  interface UserInfo {
    displayName: string | null;
    email: string | null;
    phoneNumber: string | null;
    photoURL: string | null;
    providerId: string;
    
    uid: string;
  }

  type FirebaseSignInProvider =
    | 'custom'
    | 'email'
    | 'password'
    | 'phone'
    | 'anonymous'
    | 'google.com'
    | 'facebook.com'
    | 'github.com'
    | 'twitter.com'
    | 'microsoft.com'
    | 'apple.com';

  interface FirebaseIdToken {
    
    aud: string;

    
    sub: string;

    
    iat: number;

    
    exp: number;

    
    user_id: string;

    
    auth_time: number;

    
    provider_id?: 'anonymous';

    
    email?: string;

    
    email_verified?: boolean;

    
    phone_number?: string;

    
    name?: string;

    
    picture?: string;

    
    firebase: {
      
      sign_in_provider: FirebaseSignInProvider;

      
      identities?: { [provider in FirebaseSignInProvider]?: string[] };
    };

    
    [claim: string]: unknown;

    
    uid?: never;
  }

  export type EmulatorMockTokenOptions = (
    | { user_id: string }
    | { sub: string }
  ) &
    Partial<FirebaseIdToken>;

  
  function app(name?: string): firebase.app.App;

  
  var apps: firebase.app.App[];

  
  function auth(app?: firebase.app.App): firebase.auth.Auth;

  
  function database(app?: firebase.app.App): firebase.database.Database;

  
  function initializeApp(options: Object, name?: string): firebase.app.App;

  
  function messaging(app?: firebase.app.App): firebase.messaging.Messaging;

  
  function storage(app?: firebase.app.App): firebase.storage.Storage;

  function firestore(app?: firebase.app.App): firebase.firestore.Firestore;

  function functions(app?: firebase.app.App): firebase.functions.Functions;

  
  function performance(
    app?: firebase.app.App
  ): firebase.performance.Performance;

  
  function remoteConfig(
    app?: firebase.app.App
  ): firebase.remoteConfig.RemoteConfig;

  
  function analytics(app?: firebase.app.App): firebase.analytics.Analytics;

  function appCheck(app?: firebase.app.App): firebase.appCheck.AppCheck;
}

declare namespace firebase.app {
  
  interface App {
    
    auth(): firebase.auth.Auth;
    
    database(url?: string): firebase.database.Database;
    
    delete(): Promise<any>;
    
    installations(): firebase.installations.Installations;
    
    messaging(): firebase.messaging.Messaging;
    
    name: string;
    
    automaticDataCollectionEnabled: boolean;
    
    options: Object;
    
    storage(url?: string): firebase.storage.Storage;
    firestore(): firebase.firestore.Firestore;
    functions(regionOrCustomDomain?: string): firebase.functions.Functions;
    
    performance(): firebase.performance.Performance;
    
    remoteConfig(): firebase.remoteConfig.RemoteConfig;
    
    analytics(): firebase.analytics.Analytics;
    appCheck(): firebase.appCheck.AppCheck;
  }
}


declare namespace firebase.appCheck {
  
  interface AppCheckTokenResult {
    token: string;
  }
  
  class ReCaptchaV3Provider {
    
    constructor(siteKey: string);
  }
  
  class ReCaptchaEnterpriseProvider {
    
    constructor(keyId: string);
  }
  
  class CustomProvider {
    
    constructor(options: CustomProviderOptions);
  }
  
  interface CustomProviderOptions {
    
    getToken: () => Promise<AppCheckToken>;
  }

  
  export interface AppCheck {
    
    activate(
      provider:
        | ReCaptchaV3Provider
        | ReCaptchaEnterpriseProvider
        | CustomProvider
        | AppCheckProvider
        | { getToken: () => AppCheckToken }
        | string,
      isTokenAutoRefreshEnabled?: boolean
    ): void;

    
    setTokenAutoRefreshEnabled(isTokenAutoRefreshEnabled: boolean): void;
    
    getToken(
      forceRefresh?: boolean
    ): Promise<firebase.appCheck.AppCheckTokenResult>;

    
    onTokenChanged(observer: {
      next: (tokenResult: firebase.appCheck.AppCheckTokenResult) => void;
      error?: (error: Error) => void;
      complete?: () => void;
    }): Unsubscribe;

    
    onTokenChanged(
      onNext: (tokenResult: firebase.appCheck.AppCheckTokenResult) => void,
      onError?: (error: Error) => void,
      onCompletion?: () => void
    ): Unsubscribe;
  }

  
  interface AppCheckProvider {
    
    getToken(): Promise<AppCheckToken>;
  }

  
  interface AppCheckToken {
    
    readonly token: string;
    
    readonly expireTimeMillis: number;
  }
}


declare namespace firebase.installations {
  
  export interface Installations {
    
    app: firebase.app.App;
    
    getId(): Promise<string>;

    
    getToken(forceRefresh?: boolean): Promise<string>;

    
    delete(): Promise<void>;

    
    onIdChange(callback: (installationId: string) => void): () => void;
  }
}


declare namespace firebase.performance {
  
  export interface Performance {
    
    app: firebase.app.App;
    
    trace(traceName: string): Trace;

    
    instrumentationEnabled: boolean;
    
    dataCollectionEnabled: boolean;
  }

  export interface Trace {
    
    start(): void;
    
    stop(): void;
    
    record(
      startTime: number,
      duration: number,
      options?: {
        metrics?: { [key: string]: number };
        attributes?: { [key: string]: string };
      }
    ): void;
    
    incrementMetric(metricName: string, num?: number): void;
    
    putMetric(metricName: string, num: number): void;
    
    getMetric(metricName: string): number;
    
    putAttribute(attr: string, value: string): void;
    
    getAttribute(attr: string): string | undefined;
    

    removeAttribute(attr: string): void;
    
    getAttributes(): { [key: string]: string };
  }
}


declare namespace firebase.remoteConfig {
  
  export interface RemoteConfig {
    
    app: firebase.app.App;
    
    settings: Settings;

    
    defaultConfig: { [key: string]: string | number | boolean };

    
    fetchTimeMillis: number;

    
    lastFetchStatus: FetchStatus;

    
    activate(): Promise<boolean>;

    
    ensureInitialized(): Promise<void>;

    
    fetch(): Promise<void>;

    
    fetchAndActivate(): Promise<boolean>;

    
    getAll(): { [key: string]: Value };

    
    getBoolean(key: string): boolean;

    
    getNumber(key: string): number;

    
    getString(key: string): string;

    
    getValue(key: string): Value;

    
    setLogLevel(logLevel: LogLevel): void;
  }

  
  export type ValueSource = 'static' | 'default' | 'remote';

  
  export interface Value {
    
    asBoolean(): boolean;

    
    asNumber(): number;

    
    asString(): string;

    
    getSource(): ValueSource;
  }

  
  export interface Settings {
    
    minimumFetchIntervalMillis: number;

    
    fetchTimeoutMillis: number;
  }

  
  export type FetchStatus = 'no-fetch-yet' | 'success' | 'failure' | 'throttle';

  
  export type LogLevel = 'debug' | 'error' | 'silent';

  
  export function isSupported(): Promise<boolean>;
}

declare namespace firebase.functions {
  
  export interface HttpsCallableResult {
    readonly data: any;
  }
  
  export interface HttpsCallable {
    (data?: any): Promise<HttpsCallableResult>;
  }
  export interface HttpsCallableOptions {
    timeout?: number;
  }
  
  export class Functions {
    private constructor();

    
    useEmulator(host: string, port: number): void;

    
    useFunctionsEmulator(url: string): void;
    
    httpsCallable(name: string, options?: HttpsCallableOptions): HttpsCallable;
  }
  
  export type FunctionsErrorCode =
    | 'ok'
    | 'cancelled'
    | 'unknown'
    | 'invalid-argument'
    | 'deadline-exceeded'
    | 'not-found'
    | 'already-exists'
    | 'permission-denied'
    | 'resource-exhausted'
    | 'failed-precondition'
    | 'aborted'
    | 'out-of-range'
    | 'unimplemented'
    | 'internal'
    | 'unavailable'
    | 'data-loss'
    | 'unauthenticated';
  export interface HttpsError extends Error {
    
    readonly code: FunctionsErrorCode;
    
    readonly details?: any;
  }
}

declare namespace firebase.auth {
  
  class ActionCodeURL {
    private constructor();
    
    apiKey: string;
    
    code: string;
    
    continueUrl: string | null;
    
    languageCode: string | null;
    
    operation: firebase.auth.ActionCodeInfo.Operation;
    
    static parseLink(link: string): firebase.auth.ActionCodeURL | null;
    
    tenantId: string | null;
  }
  
  interface ActionCodeInfo {
    
    data: {
      email?: string | null;
      
      fromEmail?: string | null;
      multiFactorInfo?: firebase.auth.MultiFactorInfo | null;
      previousEmail?: string | null;
    };
    
    operation: string;
  }

  
  type ActionCodeSettings = {
    android?: {
      installApp?: boolean;
      minimumVersion?: string;
      packageName: string;
    };
    handleCodeInApp?: boolean;
    iOS?: { bundleId: string };
    url: string;
    dynamicLinkDomain?: string;
  };

  
  type AdditionalUserInfo = {
    isNewUser: boolean;
    profile: Object | null;
    providerId: string;
    username?: string | null;
  };

  
  interface ApplicationVerifier {
    
    type: string;
    
    verify(): Promise<string>;
  }

  
  interface AuthSettings {
    
    appVerificationDisabledForTesting: boolean;
  }

  
  export interface Config {
    
    apiKey: string;
    
    apiHost: string;
    
    apiScheme: string;
    
    tokenApiHost: string;
    
    sdkClientVersion: string;
    
    authDomain?: string;
  }

  
  export interface EmulatorConfig {
    
    readonly protocol: string;
    
    readonly host: string;
    
    readonly port: number | null;
    
    readonly options: {
      
      readonly disableWarnings: boolean;
    };
  }

  
  interface Auth {
    
    readonly name: string;
    
    readonly config: Config;
    
    readonly emulatorConfig: EmulatorConfig | null;
    
    app: firebase.app.App;
    
    applyActionCode(code: string): Promise<void>;
    
    checkActionCode(code: string): Promise<firebase.auth.ActionCodeInfo>;
    
    confirmPasswordReset(code: string, newPassword: string): Promise<void>;

    
    createUserWithEmailAndPassword(
      email: string,
      password: string
    ): Promise<firebase.auth.UserCredential>;
    
    currentUser: firebase.User | null;

    
    fetchSignInMethodsForEmail(email: string): Promise<Array<string>>;

    
    isSignInWithEmailLink(emailLink: string): boolean;
    
    getRedirectResult(): Promise<firebase.auth.UserCredential>;
    
    languageCode: string | null;
    
    settings: firebase.auth.AuthSettings;
    
    onAuthStateChanged(
      nextOrObserver:
        | firebase.Observer<any>
        | ((a: firebase.User | null) => any),
      error?: (a: firebase.auth.Error) => any,
      completed?: firebase.Unsubscribe
    ): firebase.Unsubscribe;
    
    onIdTokenChanged(
      nextOrObserver:
        | firebase.Observer<any>
        | ((a: firebase.User | null) => any),
      error?: (a: firebase.auth.Error) => any,
      completed?: firebase.Unsubscribe
    ): firebase.Unsubscribe;
    
    sendSignInLinkToEmail(
      email: string,
      actionCodeSettings: firebase.auth.ActionCodeSettings
    ): Promise<void>;

    
    sendPasswordResetEmail(
      email: string,
      actionCodeSettings?: firebase.auth.ActionCodeSettings | null
    ): Promise<void>;

    
    setPersistence(persistence: firebase.auth.Auth.Persistence): Promise<void>;

    
    signInAndRetrieveDataWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    signInAnonymously(): Promise<firebase.auth.UserCredential>;

    
    signInWithCredential(
      credential: firebase.auth.AuthCredential
    ): Promise<firebase.auth.UserCredential>;
    
    signInWithCustomToken(token: string): Promise<firebase.auth.UserCredential>;
    
    signInWithEmailAndPassword(
      email: string,
      password: string
    ): Promise<firebase.auth.UserCredential>;

    
    signInWithPhoneNumber(
      phoneNumber: string,
      applicationVerifier: firebase.auth.ApplicationVerifier
    ): Promise<firebase.auth.ConfirmationResult>;
    
    signInWithEmailLink(
      email: string,
      emailLink?: string
    ): Promise<firebase.auth.UserCredential>;
    
    signInWithPopup(
      provider: firebase.auth.AuthProvider
    ): Promise<firebase.auth.UserCredential>;
    
    signInWithRedirect(provider: firebase.auth.AuthProvider): Promise<void>;
    
    signOut(): Promise<void>;
    
    tenantId: string | null;
    
    updateCurrentUser(user: firebase.User | null): Promise<void>;
    
    useDeviceLanguage(): void;
    
    useEmulator(url: string): void;
    
    verifyPasswordResetCode(code: string): Promise<string>;
  }

  
  abstract class AuthCredential {
    
    providerId: string;
    
    signInMethod: string;
    
    toJSON(): Object;
    
    static fromJSON(json: Object | string): AuthCredential | null;
  }

  
  class OAuthCredential extends AuthCredential {
    private constructor();
    
    idToken?: string;
    
    accessToken?: string;
    
    secret?: string;
  }

  
  interface AuthProvider {
    providerId: string;
  }

  
  interface ConfirmationResult {
    
    confirm(verificationCode: string): Promise<firebase.auth.UserCredential>;
    
    verificationId: string;
  }

  
  class EmailAuthProvider extends EmailAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static EMAIL_PASSWORD_SIGN_IN_METHOD: string;
    
    static EMAIL_LINK_SIGN_IN_METHOD: string;
    
    static credential(
      email: string,
      password: string
    ): firebase.auth.AuthCredential;
    
    static credentialWithLink(
      email: string,
      emailLink: string
    ): firebase.auth.AuthCredential;
  }
  
  class EmailAuthProvider_Instance implements firebase.auth.AuthProvider {
    providerId: string;
  }

  
  interface Error {
    name: string;
    
    code: string;
    
    message: string;
  }

  
  interface AuthError extends firebase.auth.Error {
    
    credential?: firebase.auth.AuthCredential;
    
    email?: string;
    
    phoneNumber?: string;
    
    tenantId?: string;
  }

  
  interface MultiFactorError extends firebase.auth.AuthError {
    
    resolver: firebase.auth.MultiFactorResolver;
  }

  
  class FacebookAuthProvider extends FacebookAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static FACEBOOK_SIGN_IN_METHOD: string;
    
    static credential(token: string): firebase.auth.OAuthCredential;
  }
  
  class FacebookAuthProvider_Instance implements firebase.auth.AuthProvider {
    
    addScope(scope: string): firebase.auth.AuthProvider;
    providerId: string;
    
    setCustomParameters(
      customOAuthParameters: Object
    ): firebase.auth.AuthProvider;
  }

  
  class GithubAuthProvider extends GithubAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static GITHUB_SIGN_IN_METHOD: string;
    
    static credential(token: string): firebase.auth.OAuthCredential;
  }
  
  class GithubAuthProvider_Instance implements firebase.auth.AuthProvider {
    
    addScope(scope: string): firebase.auth.AuthProvider;
    providerId: string;
    
    setCustomParameters(
      customOAuthParameters: Object
    ): firebase.auth.AuthProvider;
  }

  
  class GoogleAuthProvider extends GoogleAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static GOOGLE_SIGN_IN_METHOD: string;
    
    static credential(
      idToken?: string | null,
      accessToken?: string | null
    ): firebase.auth.OAuthCredential;
  }
  
  class GoogleAuthProvider_Instance implements firebase.auth.AuthProvider {
    
    addScope(scope: string): firebase.auth.AuthProvider;
    providerId: string;
    
    setCustomParameters(
      customOAuthParameters: Object
    ): firebase.auth.AuthProvider;
  }

  
  class OAuthProvider implements firebase.auth.AuthProvider {
    constructor(providerId: string);
    providerId: string;
    
    addScope(scope: string): firebase.auth.AuthProvider;
    
    credential(
      optionsOrIdToken: firebase.auth.OAuthCredentialOptions | string | null,
      accessToken?: string
    ): firebase.auth.OAuthCredential;
    
    setCustomParameters(
      customOAuthParameters: Object
    ): firebase.auth.AuthProvider;
  }

  class SAMLAuthProvider implements firebase.auth.AuthProvider {
    constructor(providerId: string);
    providerId: string;
  }

  
  interface IdTokenResult {
    
    token: string;
    
    expirationTime: string;
    
    authTime: string;
    
    issuedAtTime: string;
    
    signInProvider: string | null;
    
    signInSecondFactor: string | null;
    
    claims: {
      [key: string]: any;
    };
  }

  
  interface OAuthCredentialOptions {
    
    idToken?: string;
    
    accessToken?: string;
    
    rawNonce?: string;
  }

  
  abstract class MultiFactorAssertion {
    
    factorId: string;
  }

  
  class PhoneMultiFactorAssertion extends firebase.auth.MultiFactorAssertion {
    private constructor();
  }

  
  class PhoneMultiFactorGenerator {
    private constructor();
    
    static FACTOR_ID: string;
    
    static assertion(
      phoneAuthCredential: firebase.auth.PhoneAuthCredential
    ): firebase.auth.PhoneMultiFactorAssertion;
  }

  
  interface MultiFactorInfo {
    
    uid: string;
    
    displayName?: string | null;
    
    enrollmentTime: string;
    
    factorId: string;
  }

  
  interface PhoneMultiFactorInfo extends firebase.auth.MultiFactorInfo {
    
    phoneNumber: string;
  }

  
  type PhoneInfoOptions =
    | firebase.auth.PhoneSingleFactorInfoOptions
    | firebase.auth.PhoneMultiFactorEnrollInfoOptions
    | firebase.auth.PhoneMultiFactorSignInInfoOptions;
  
  interface PhoneSingleFactorInfoOptions {
    phoneNumber: string;
  }

  
  interface PhoneMultiFactorEnrollInfoOptions {
    phoneNumber: string;
    session: firebase.auth.MultiFactorSession;
  }

  
  interface PhoneMultiFactorSignInInfoOptions {
    multiFactorHint?: firebase.auth.MultiFactorInfo;
    multiFactorUid?: string;
    session: firebase.auth.MultiFactorSession;
  }

  
  class MultiFactorResolver {
    private constructor();
    
    auth: firebase.auth.Auth;
    
    session: firebase.auth.MultiFactorSession;
    
    hints: firebase.auth.MultiFactorInfo[];
    
    resolveSignIn(
      assertion: firebase.auth.MultiFactorAssertion
    ): Promise<firebase.auth.UserCredential>;
  }

  
  class MultiFactorSession {
    private constructor();
  }

  
  class PhoneAuthCredential extends AuthCredential {
    private constructor();
  }

  
  class PhoneAuthProvider extends PhoneAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static PHONE_SIGN_IN_METHOD: string;
    
    static credential(
      verificationId: string,
      verificationCode: string
    ): firebase.auth.AuthCredential;
  }
  
  class PhoneAuthProvider_Instance implements firebase.auth.AuthProvider {
    constructor(auth?: firebase.auth.Auth | null);
    providerId: string;
    
    verifyPhoneNumber(
      phoneInfoOptions: firebase.auth.PhoneInfoOptions | string,
      applicationVerifier: firebase.auth.ApplicationVerifier
    ): Promise<string>;
  }

  
  class RecaptchaVerifier extends RecaptchaVerifier_Instance {}
  
  class RecaptchaVerifier_Instance
    implements firebase.auth.ApplicationVerifier
  {
    constructor(
      container: any | string,
      parameters?: Object | null,
      app?: firebase.app.App | null
    );
    
    clear(): void;
    
    render(): Promise<number>;
    
    type: string;
    
    verify(): Promise<string>;
  }

  
  class TwitterAuthProvider extends TwitterAuthProvider_Instance {
    static PROVIDER_ID: string;
    
    static TWITTER_SIGN_IN_METHOD: string;
    
    static credential(
      token: string,
      secret: string
    ): firebase.auth.OAuthCredential;
  }
  
  class TwitterAuthProvider_Instance implements firebase.auth.AuthProvider {
    providerId: string;
    
    setCustomParameters(
      customOAuthParameters: Object
    ): firebase.auth.AuthProvider;
  }

  
  type UserCredential = {
    additionalUserInfo?: firebase.auth.AdditionalUserInfo | null;
    credential: firebase.auth.AuthCredential | null;
    operationType?: string | null;
    user: firebase.User | null;
  };

  
  interface UserMetadata {
    creationTime?: string;
    lastSignInTime?: string;
  }
}


declare namespace firebase.analytics {
  
  export interface Analytics {
    
    app: firebase.app.App;

    
    logEvent(
      eventName: 'add_payment_info',
      eventParams?: {
        coupon?: EventParams['coupon'];
        currency?: EventParams['currency'];
        items?: EventParams['items'];
        payment_type?: EventParams['payment_type'];
        value?: EventParams['value'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'add_shipping_info',
      eventParams?: {
        coupon?: EventParams['coupon'];
        currency?: EventParams['currency'];
        items?: EventParams['items'];
        shipping_tier?: EventParams['shipping_tier'];
        value?: EventParams['value'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'add_to_cart' | 'add_to_wishlist' | 'remove_from_cart',
      eventParams?: {
        currency?: EventParams['currency'];
        value?: EventParams['value'];
        items?: EventParams['items'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'begin_checkout',
      eventParams?: {
        currency?: EventParams['currency'];
        coupon?: EventParams['coupon'];
        value?: EventParams['value'];
        items?: EventParams['items'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'checkout_progress',
      eventParams?: {
        currency?: EventParams['currency'];
        coupon?: EventParams['coupon'];
        value?: EventParams['value'];
        items?: EventParams['items'];
        checkout_step?: EventParams['checkout_step'];
        checkout_option?: EventParams['checkout_option'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'exception',
      eventParams?: {
        description?: EventParams['description'];
        fatal?: EventParams['fatal'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'generate_lead',
      eventParams?: {
        value?: EventParams['value'];
        currency?: EventParams['currency'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'login',
      eventParams?: {
        method?: EventParams['method'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'page_view',
      eventParams?: {
        page_title?: string;
        page_location?: string;
        page_path?: string;
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'purchase' | 'refund',
      eventParams?: {
        value?: EventParams['value'];
        currency?: EventParams['currency'];
        transaction_id: EventParams['transaction_id'];
        tax?: EventParams['tax'];
        shipping?: EventParams['shipping'];
        items?: EventParams['items'];
        coupon?: EventParams['coupon'];
        affiliation?: EventParams['affiliation'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'screen_view',
      eventParams?: {
        firebase_screen: EventParams['firebase_screen'];
        firebase_screen_class: EventParams['firebase_screen_class'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'search' | 'view_search_results',
      eventParams?: {
        search_term?: EventParams['search_term'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'select_content',
      eventParams?: {
        content_type?: EventParams['content_type'];
        item_id?: EventParams['item_id'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'select_item',
      eventParams?: {
        items?: EventParams['items'];
        item_list_name?: EventParams['item_list_name'];
        item_list_id?: EventParams['item_list_id'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'select_promotion' | 'view_promotion',
      eventParams?: {
        items?: EventParams['items'];
        promotion_id?: EventParams['promotion_id'];
        promotion_name?: EventParams['promotion_name'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'set_checkout_option',
      eventParams?: {
        checkout_step?: EventParams['checkout_step'];
        checkout_option?: EventParams['checkout_option'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'share',
      eventParams?: {
        method?: EventParams['method'];
        content_type?: EventParams['content_type'];
        item_id?: EventParams['item_id'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'sign_up',
      eventParams?: {
        method?: EventParams['method'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'timing_complete',
      eventParams?: {
        name: string;
        value: number;
        event_category?: string;
        event_label?: string;
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'view_cart' | 'view_item',
      eventParams?: {
        currency?: EventParams['currency'];
        items?: EventParams['items'];
        value?: EventParams['value'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent(
      eventName: 'view_item_list',
      eventParams?: {
        items?: EventParams['items'];
        item_list_name?: EventParams['item_list_name'];
        item_list_id?: EventParams['item_list_id'];
        [key: string]: any;
      },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    logEvent<T extends string>(
      eventName: CustomEventName<T>,
      eventParams?: { [key: string]: any },
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    setCurrentScreen(
      screenName: string,
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    setUserId(
      id: string,
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    setUserProperties(
      properties: firebase.analytics.CustomParams,
      options?: firebase.analytics.AnalyticsCallOptions
    ): void;

    
    setAnalyticsCollectionEnabled(enabled: boolean): void;
  }

  export type CustomEventName<T> = T extends EventNameString ? never : T;

  
  export interface AnalyticsCallOptions {
    
    global: boolean;
  }

  
  export interface SettingsOptions {
    
    gtagName?: string;
    
    dataLayerName?: string;
  }

  
  export function settings(settings: firebase.analytics.SettingsOptions): void;

  
  export interface ControlParams {
    groups?: string | string[];
    send_to?: string | string[];
    event_callback?: () => void;
    event_timeout?: number;
  }

  
  export interface EventParams {
    checkout_option?: string;
    checkout_step?: number;
    item_id?: string;
    content_type?: string;
    coupon?: string;
    currency?: string;
    description?: string;
    fatal?: boolean;
    items?: Item[];
    method?: string;
    number?: string;
    promotions?: Promotion[];
    screen_name?: string;
    
    firebase_screen?: string;
    
    firebase_screen_class?: string;
    search_term?: string;
    shipping?: Currency;
    tax?: Currency;
    transaction_id?: string;
    value?: number;
    event_label?: string;
    event_category: string;
    shipping_tier?: string;
    item_list_id?: string;
    item_list_name?: string;
    promotion_id?: string;
    promotion_name?: string;
    payment_type?: string;
    affiliation?: string;
  }

  
  export interface CustomParams {
    [key: string]: any;
  }

  
  export type EventNameString =
    | 'add_payment_info'
    | 'add_shipping_info'
    | 'add_to_cart'
    | 'add_to_wishlist'
    | 'begin_checkout'
    | 'checkout_progress'
    | 'exception'
    | 'generate_lead'
    | 'login'
    | 'page_view'
    | 'purchase'
    | 'refund'
    | 'remove_from_cart'
    | 'screen_view'
    | 'search'
    | 'select_content'
    | 'select_item'
    | 'select_promotion'
    | 'set_checkout_option'
    | 'share'
    | 'sign_up'
    | 'timing_complete'
    | 'view_cart'
    | 'view_item'
    | 'view_item_list'
    | 'view_promotion'
    | 'view_search_results';

  
  export enum EventName {
    ADD_PAYMENT_INFO = 'add_payment_info',
    ADD_SHIPPING_INFO = 'add_shipping_info',
    ADD_TO_CART = 'add_to_cart',
    ADD_TO_WISHLIST = 'add_to_wishlist',
    BEGIN_CHECKOUT = 'begin_checkout',
    
    CHECKOUT_PROGRESS = 'checkout_progress',
    EXCEPTION = 'exception',
    GENERATE_LEAD = 'generate_lead',
    LOGIN = 'login',
    PAGE_VIEW = 'page_view',
    PURCHASE = 'purchase',
    REFUND = 'refund',
    REMOVE_FROM_CART = 'remove_from_cart',
    SCREEN_VIEW = 'screen_view',
    SEARCH = 'search',
    SELECT_CONTENT = 'select_content',
    SELECT_ITEM = 'select_item',
    SELECT_PROMOTION = 'select_promotion',
    
    SET_CHECKOUT_OPTION = 'set_checkout_option',
    SHARE = 'share',
    SIGN_UP = 'sign_up',
    TIMING_COMPLETE = 'timing_complete',
    VIEW_CART = 'view_cart',
    VIEW_ITEM = 'view_item',
    VIEW_ITEM_LIST = 'view_item_list',
    VIEW_PROMOTION = 'view_promotion',
    VIEW_SEARCH_RESULTS = 'view_search_results'
  }

  export type Currency = string | number;

  export interface Item {
    item_id?: string;
    item_name?: string;
    item_brand?: string;
    item_category?: string;
    item_category2?: string;
    item_category3?: string;
    item_category4?: string;
    item_category5?: string;
    item_variant?: string;
    price?: Currency;
    quantity?: number;
    index?: number;
    coupon?: string;
    item_list_name?: string;
    item_list_id?: string;
    discount?: Currency;
    affiliation?: string;
    creative_name?: string;
    creative_slot?: string;
    promotion_id?: string;
    promotion_name?: string;
    location_id?: string;
    
    brand?: string;
    
    category?: string;
    
    id?: string;
    
    name?: string;
  }

  
  export interface Promotion {
    creative_name?: string;
    creative_slot?: string;
    id?: string;
    name?: string;
  }

  
  function isSupported(): Promise<boolean>;
}

declare namespace firebase.auth.Auth {
  type Persistence = string;
  
  var Persistence: {
    
    LOCAL: Persistence;
    
    NONE: Persistence;
    
    SESSION: Persistence;
  };
}

declare namespace firebase.User {
  
  interface MultiFactorUser {
    
    enrolledFactors: firebase.auth.MultiFactorInfo[];
    
    enroll(
      assertion: firebase.auth.MultiFactorAssertion,
      displayName?: string | null
    ): Promise<void>;
    
    getSession(): Promise<firebase.auth.MultiFactorSession>;
    
    unenroll(option: firebase.auth.MultiFactorInfo | string): Promise<void>;
  }
}

declare namespace firebase.auth.ActionCodeInfo {
  type Operation = string;
  
  var Operation: {
    
    EMAIL_SIGNIN: Operation;
    
    PASSWORD_RESET: Operation;
    
    RECOVER_EMAIL: Operation;
    
    REVERT_SECOND_FACTOR_ADDITION: Operation;
    
    VERIFY_AND_CHANGE_EMAIL: Operation;
    
    VERIFY_EMAIL: Operation;
  };
}

declare namespace firebase.database {
  
  interface DataSnapshot {
    
    child(path: string): firebase.database.DataSnapshot;
    
    exists(): boolean;
    
    exportVal(): any;
    
    forEach(
      action: (a: firebase.database.IteratedDataSnapshot) => boolean | void
    ): boolean;
    
    getPriority(): string | number | null;
    
    hasChild(path: string): boolean;
    
    hasChildren(): boolean;
    
    key: string | null;
    
    numChildren(): number;
    
    val(): any;
    
    ref: firebase.database.Reference;
    
    toJSON(): Object | null;
  }

  interface IteratedDataSnapshot extends DataSnapshot {
    key: string; 
  }

  
  interface Database {
    
    app: firebase.app.App;
    
    INTERNAL: {
      
      forceWebSockets: () => void;
      
      forceLongPolling: () => void;
    };
    
    useEmulator(
      host: string,
      port: number,
      options?: {
        mockUserToken?: EmulatorMockTokenOptions | string;
      }
    ): void;
    
    goOffline(): any;
    
    goOnline(): any;
    
    ref(path?: string): firebase.database.Reference;
    
    refFromURL(url: string): firebase.database.Reference;
  }

  
  interface OnDisconnect {
    
    cancel(onComplete?: (a: Error | null) => any): Promise<any>;
    
    remove(onComplete?: (a: Error | null) => any): Promise<any>;
    
    set(value: any, onComplete?: (a: Error | null) => any): Promise<any>;
    
    setWithPriority(
      value: any,
      priority: number | string | null,
      onComplete?: (a: Error | null) => any
    ): Promise<any>;
    
    update(values: Object, onComplete?: (a: Error | null) => any): Promise<any>;
  }

  type EventType =
    | 'value'
    | 'child_added'
    | 'child_changed'
    | 'child_moved'
    | 'child_removed';

  
  interface Query {
    
    endAt(
      value: number | string | boolean | null,
      key?: string
    ): firebase.database.Query;
    
    endBefore(
      value: number | string | boolean | null,
      key?: string
    ): firebase.database.Query;
    
    equalTo(
      value: number | string | boolean | null,
      key?: string
    ): firebase.database.Query;
    
    isEqual(other: firebase.database.Query | null): boolean;
    
    limitToFirst(limit: number): firebase.database.Query;
    
    limitToLast(limit: number): firebase.database.Query;
    
    off(
      eventType?: EventType,
      callback?: (a: firebase.database.DataSnapshot, b?: string | null) => any,
      context?: Object | null
    ): void;

    
    get(): Promise<DataSnapshot>;

    
    on(
      eventType: EventType,
      callback: (a: firebase.database.DataSnapshot, b?: string | null) => any,
      cancelCallbackOrContext?: ((a: Error) => any) | Object | null,
      context?: Object | null
    ): (a: firebase.database.DataSnapshot | null, b?: string | null) => any;

    
    once(
      eventType: EventType,
      successCallback?: (
        a: firebase.database.DataSnapshot,
        b?: string | null
      ) => any,
      failureCallbackOrContext?: ((a: Error) => void) | Object | null,
      context?: Object | null
    ): Promise<firebase.database.DataSnapshot>;
    
    orderByChild(path: string): firebase.database.Query;
    
    orderByKey(): firebase.database.Query;
    
    orderByPriority(): firebase.database.Query;
    
    orderByValue(): firebase.database.Query;
    
    ref: firebase.database.Reference;
    
    startAt(
      value: number | string | boolean | null,
      key?: string
    ): firebase.database.Query;
    
    startAfter(
      value: number | string | boolean | null,
      key?: string
    ): firebase.database.Query;
    
    toJSON(): Object;
    
    toString(): string;
  }

  
  interface Reference extends firebase.database.Query {
    
    child(path: string): firebase.database.Reference;
    
    key: string | null;
    
    onDisconnect(): firebase.database.OnDisconnect;
    
    parent: firebase.database.Reference | null;
    
    push(
      value?: any,
      onComplete?: (a: Error | null) => any
    ): firebase.database.ThenableReference;
    
    remove(onComplete?: (a: Error | null) => void): Promise<void>;
    
    root: firebase.database.Reference;
    
    set(value: any, onComplete?: (a: Error | null) => void): Promise<void>;
    
    setPriority(
      priority: string | number | null,
      onComplete: (a: Error | null) => void
    ): Promise<void>;
    
    setWithPriority(
      newVal: any,
      newPriority: string | number | null,
      onComplete?: (a: Error | null) => void
    ): Promise<void>;
    
    transaction(
      transactionUpdate: (a: any) => any,
      onComplete?: (
        a: Error | null,
        b: boolean,
        c: firebase.database.DataSnapshot | null
      ) => void,
      applyLocally?: boolean
    ): Promise<TransactionResult>;
    
    update(
      values: Object,
      onComplete?: (a: Error | null) => void
    ): Promise<void>;
  }

  interface TransactionResult {
    
    committed: boolean;
    
    snapshot: DataSnapshot;
  }

  interface ThenableReference
    extends firebase.database.Reference,
      Pick<Promise<Reference>, 'then' | 'catch'> {
    key: string;
    parent: Reference;
  }

  
  function enableLogging(
    logger?: boolean | ((a: string) => any),
    persistent?: boolean
  ): any;

  export type EmulatorMockTokenOptions = firebase.EmulatorMockTokenOptions;
}

declare namespace firebase.database.ServerValue {
  
  var TIMESTAMP: Object;

  
  function increment(delta: number): Object;
}


declare namespace firebase.messaging {
  
  interface Messaging {
    
    deleteToken(): Promise<boolean>;

    
    getToken(options?: {
      vapidKey?: string;
      serviceWorkerRegistration?: ServiceWorkerRegistration;
    }): Promise<string>;

    
    onMessage(
      nextOrObserver: firebase.NextFn<any> | firebase.Observer<any>
    ): firebase.Unsubscribe;

    
    onBackgroundMessage(
      nextOrObserver:
        | firebase.NextFn<MessagePayload>
        | firebase.Observer<MessagePayload>
    ): firebase.Unsubscribe;
  }

  
  export interface MessagePayload {
    
    notification?: NotificationPayload;

    
    data?: { [key: string]: string };

    
    fcmOptions?: FcmOptions;

    
    from: string;

    
    collapseKey: string;
  }

  
  export interface FcmOptions {
    
    link?: string;

    
    analyticsLabel?: string;
  }

  
  export interface NotificationPayload {
    
    title?: string;

    
    body?: string;

    
    image?: string;
  }

  function isSupported(): boolean;
}

declare namespace firebase.storage {
  
  interface FullMetadata extends firebase.storage.UploadMetadata {
    
    bucket: string;
    
    fullPath: string;
    
    generation: string;
    
    metageneration: string;
    
    name: string;
    
    size: number;
    
    timeCreated: string;
    
    updated: string;
  }

  
  interface Reference {
    
    bucket: string;
    
    child(path: string): firebase.storage.Reference;
    
    delete(): Promise<void>;
    
    fullPath: string;
    
    getDownloadURL(): Promise<string>;
    
    getMetadata(): Promise<FullMetadata>;
    
    name: string;
    
    parent: firebase.storage.Reference | null;
    
    put(
      data: Blob | Uint8Array | ArrayBuffer,
      metadata?: firebase.storage.UploadMetadata
    ): firebase.storage.UploadTask;
    
    putString(
      data: string,
      format?: firebase.storage.StringFormat,
      metadata?: firebase.storage.UploadMetadata
    ): firebase.storage.UploadTask;
    
    root: firebase.storage.Reference;
    
    storage: firebase.storage.Storage;
    
    toString(): string;
    
    updateMetadata(
      metadata: firebase.storage.SettableMetadata
    ): Promise<FullMetadata>;
    
    listAll(): Promise<ListResult>;
    
    list(options?: ListOptions): Promise<ListResult>;
  }

  
  interface ListResult {
    
    prefixes: Reference[];
    
    items: Reference[];
    
    nextPageToken: string | null;
  }

  
  interface ListOptions {
    
    maxResults?: number | null;
    
    pageToken?: string | null;
  }

  
  interface SettableMetadata {
    
    cacheControl?: string | null;
    contentDisposition?: string | null;
    
    contentEncoding?: string | null;
    
    contentLanguage?: string | null;
    
    contentType?: string | null;
    
    customMetadata?: {
      [ key: string]: string;
    } | null;
  }

  
  interface Storage {
    
    app: firebase.app.App;
    
    maxOperationRetryTime: number;
    
    maxUploadRetryTime: number;
    
    ref(path?: string): firebase.storage.Reference;
    
    refFromURL(url: string): firebase.storage.Reference;
    
    setMaxOperationRetryTime(time: number): any;
    
    setMaxUploadRetryTime(time: number): any;
    
    useEmulator(
      host: string,
      port: number,
      options?: {
        mockUserToken?: EmulatorMockTokenOptions | string;
      }
    ): void;
  }

  
  type StringFormat = string;
  var StringFormat: {
    
    BASE64: StringFormat;
    
    BASE64URL: StringFormat;
    
    DATA_URL: StringFormat;
    
    RAW: StringFormat;
  };

  
  type TaskEvent = string;
  var TaskEvent: {
    
    STATE_CHANGED: TaskEvent;
  };

  
  type TaskState = string;
  var TaskState: {
    CANCELED: TaskState;
    ERROR: TaskState;
    PAUSED: TaskState;
    RUNNING: TaskState;
    SUCCESS: TaskState;
  };

  
  interface UploadMetadata extends firebase.storage.SettableMetadata {
    
    md5Hash?: string | null;
  }

  
  export enum StorageErrorCode {
    UNKNOWN = 'unknown',
    OBJECT_NOT_FOUND = 'object-not-found',
    BUCKET_NOT_FOUND = 'bucket-not-found',
    PROJECT_NOT_FOUND = 'project-not-found',
    QUOTA_EXCEEDED = 'quota-exceeded',
    UNAUTHENTICATED = 'unauthenticated',
    UNAUTHORIZED = 'unauthorized',
    UNAUTHORIZED_APP = 'unauthorized-app',
    RETRY_LIMIT_EXCEEDED = 'retry-limit-exceeded',
    INVALID_CHECKSUM = 'invalid-checksum',
    CANCELED = 'canceled',
    INVALID_EVENT_NAME = 'invalid-event-name',
    INVALID_URL = 'invalid-url',
    INVALID_DEFAULT_BUCKET = 'invalid-default-bucket',
    NO_DEFAULT_BUCKET = 'no-default-bucket',
    CANNOT_SLICE_BLOB = 'cannot-slice-blob',
    SERVER_FILE_WRONG_SIZE = 'server-file-wrong-size',
    NO_DOWNLOAD_URL = 'no-download-url',
    INVALID_ARGUMENT = 'invalid-argument',
    INVALID_ARGUMENT_COUNT = 'invalid-argument-count',
    APP_DELETED = 'app-deleted',
    INVALID_ROOT_OPERATION = 'invalid-root-operation',
    INVALID_FORMAT = 'invalid-format',
    INTERNAL_ERROR = 'internal-error',
    UNSUPPORTED_ENVIRONMENT = 'unsupported-environment'
  }

  interface StorageObserver<T> {
    next?: NextFn<T> | null;
    error?: (error: FirebaseStorageError) => void | null;
    complete?: CompleteFn | null;
  }

  
  interface UploadTask {
    
    cancel(): boolean;
    
    catch(onRejected: (error: FirebaseStorageError) => any): Promise<any>;
    
    on(
      event: firebase.storage.TaskEvent,
      nextOrObserver?:
        | StorageObserver<UploadTaskSnapshot>
        | null
        | ((snapshot: UploadTaskSnapshot) => any),
      error?: ((error: FirebaseStorageError) => any) | null,
      complete?: firebase.Unsubscribe | null
    ): Function;
    
    pause(): boolean;
    
    resume(): boolean;
    
    snapshot: firebase.storage.UploadTaskSnapshot;
    
    then(
      onFulfilled?:
        | ((snapshot: firebase.storage.UploadTaskSnapshot) => any)
        | null,
      onRejected?: ((error: FirebaseStorageError) => any) | null
    ): Promise<any>;
  }

  
  interface UploadTaskSnapshot {
    
    bytesTransferred: number;
    
    metadata: firebase.storage.FullMetadata;
    
    ref: firebase.storage.Reference;
    
    state: firebase.storage.TaskState;
    
    task: firebase.storage.UploadTask;
    
    totalBytes: number;
  }

  
  export interface FirebaseStorageError extends FirebaseError {
    
    customData: {
      serverResponse: string | null;
    };

    get status(): number;
    set status(status: number);
    
    _codeEquals(code: StorageErrorCode): boolean;
    
    get serverResponse(): null | string;
    set serverResponse(serverResponse: string | null);
  }
}

declare namespace firebase.firestore {
  
  export type DocumentData = { [field: string]: any };

  
  export type UpdateData = { [fieldPath: string]: any };

  
  export const CACHE_SIZE_UNLIMITED: number;

  
  export interface Settings {
    
    host?: string;
    
    ssl?: boolean;

    
    cacheSizeBytes?: number;

    
    experimentalForceLongPolling?: boolean;

    
    experimentalAutoDetectLongPolling?: boolean;

    
    ignoreUndefinedProperties?: boolean;

    
    merge?: boolean;
  }

  
  export interface PersistenceSettings {
    
    synchronizeTabs?: boolean;

    
    experimentalForceOwningTab?: boolean;
  }

  export type LogLevel = 'debug' | 'error' | 'silent';

  
  export function setLogLevel(logLevel: LogLevel): void;

  
  export interface FirestoreDataConverter<T> {
    
    toFirestore(modelObject: T): DocumentData;
    toFirestore(modelObject: Partial<T>, options: SetOptions): DocumentData;

    
    fromFirestore(snapshot: QueryDocumentSnapshot, options: SnapshotOptions): T;
  }

  
  export class Firestore {
    private constructor();
    
    settings(settings: Settings): void;

    
    useEmulator(
      host: string,
      port: number,
      options?: {
        mockUserToken?: EmulatorMockTokenOptions | string;
      }
    ): void;

    
    enablePersistence(settings?: PersistenceSettings): Promise<void>;

    
    collection(collectionPath: string): CollectionReference<DocumentData>;

    
    doc(documentPath: string): DocumentReference<DocumentData>;

    
    collectionGroup(collectionId: string): Query<DocumentData>;

    
    runTransaction<T>(
      updateFunction: (transaction: Transaction) => Promise<T>
    ): Promise<T>;

    
    batch(): WriteBatch;

    
    app: firebase.app.App;

    
    clearPersistence(): Promise<void>;

    
    enableNetwork(): Promise<void>;

    
    disableNetwork(): Promise<void>;

    
    waitForPendingWrites(): Promise<void>;

    
    onSnapshotsInSync(observer: {
      next?: (value: void) => void;
      error?: (error: FirestoreError) => void;
      complete?: () => void;
    }): () => void;

    
    onSnapshotsInSync(onSync: () => void): () => void;

    
    terminate(): Promise<void>;

    
    loadBundle(
      bundleData: ArrayBuffer | ReadableStream<Uint8Array> | string
    ): LoadBundleTask;

    
    namedQuery(name: string): Promise<Query<DocumentData> | null>;

    
    INTERNAL: { delete: () => Promise<void> };
  }

  
  export interface LoadBundleTask extends PromiseLike<LoadBundleTaskProgress> {
    
    onProgress(
      next?: (progress: LoadBundleTaskProgress) => any,
      error?: (error: Error) => any,
      complete?: () => void
    ): void;

    
    then<T, R>(
      onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>,
      onRejected?: (a: Error) => R | PromiseLike<R>
    ): Promise<T | R>;

    
    catch<R>(
      onRejected: (a: Error) => R | PromiseLike<R>
    ): Promise<R | LoadBundleTaskProgress>;
  }

  
  export interface LoadBundleTaskProgress {
    
    documentsLoaded: number;
    
    totalDocuments: number;
    
    bytesLoaded: number;
    
    totalBytes: number;
    
    taskState: TaskState;
  }

  
  export type TaskState = 'Error' | 'Running' | 'Success';

  
  export class GeoPoint {
    
    constructor(latitude: number, longitude: number);

    
    readonly latitude: number;
    
    readonly longitude: number;

    
    isEqual(other: GeoPoint): boolean;
  }

  
  export class Timestamp {
    
    constructor(seconds: number, nanoseconds: number);

    
    static now(): Timestamp;

    
    static fromDate(date: Date): Timestamp;

    
    static fromMillis(milliseconds: number): Timestamp;

    readonly seconds: number;
    readonly nanoseconds: number;

    
    toDate(): Date;

    
    toMillis(): number;

    
    isEqual(other: Timestamp): boolean;

    
    valueOf(): string;
  }

  
  export class Blob {
    private constructor();

    
    static fromBase64String(base64: string): Blob;

    
    static fromUint8Array(array: Uint8Array): Blob;

    
    public toBase64(): string;

    
    public toUint8Array(): Uint8Array;

    
    isEqual(other: Blob): boolean;
  }

  
  export class Transaction {
    private constructor();

    
    get<T>(documentRef: DocumentReference<T>): Promise<DocumentSnapshot<T>>;

    
    set<T>(
      documentRef: DocumentReference<T>,
      data: Partial<T>,
      options: SetOptions
    ): Transaction;

    
    set<T>(documentRef: DocumentReference<T>, data: T): Transaction;

    
    update(documentRef: DocumentReference<any>, data: UpdateData): Transaction;

    
    update(
      documentRef: DocumentReference<any>,
      field: string | FieldPath,
      value: any,
      ...moreFieldsAndValues: any[]
    ): Transaction;

    
    delete(documentRef: DocumentReference<any>): Transaction;
  }

  
  export class WriteBatch {
    private constructor();

    
    set<T>(
      documentRef: DocumentReference<T>,
      data: Partial<T>,
      options: SetOptions
    ): WriteBatch;

    
    set<T>(documentRef: DocumentReference<T>, data: T): WriteBatch;

    
    update(documentRef: DocumentReference<any>, data: UpdateData): WriteBatch;

    
    update(
      documentRef: DocumentReference<any>,
      field: string | FieldPath,
      value: any,
      ...moreFieldsAndValues: any[]
    ): WriteBatch;

    
    delete(documentRef: DocumentReference<any>): WriteBatch;

    
    commit(): Promise<void>;
  }

  
  export interface SnapshotListenOptions {
    
    readonly includeMetadataChanges?: boolean;
  }

  
  export interface SetOptions {
    
    readonly merge?: boolean;

    
    readonly mergeFields?: (string | FieldPath)[];
  }

  
  export interface GetOptions {
    
    readonly source?: 'default' | 'server' | 'cache';
  }

  
  export class DocumentReference<T = DocumentData> {
    private constructor();

    
    readonly id: string;

    
    readonly firestore: Firestore;

    
    readonly parent: CollectionReference<T>;

    
    readonly path: string;

    
    collection(collectionPath: string): CollectionReference<DocumentData>;

    
    isEqual(other: DocumentReference<T>): boolean;

    
    set(data: Partial<T>, options: SetOptions): Promise<void>;

    
    set(data: T): Promise<void>;

    
    update(data: UpdateData): Promise<void>;

    
    update(
      field: string | FieldPath,
      value: any,
      ...moreFieldsAndValues: any[]
    ): Promise<void>;

    
    delete(): Promise<void>;

    
    get(options?: GetOptions): Promise<DocumentSnapshot<T>>;

    
    onSnapshot(observer: {
      next?: (snapshot: DocumentSnapshot<T>) => void;
      error?: (error: FirestoreError) => void;
      complete?: () => void;
    }): () => void;
    
    onSnapshot(
      options: SnapshotListenOptions,
      observer: {
        next?: (snapshot: DocumentSnapshot<T>) => void;
        error?: (error: FirestoreError) => void;
        complete?: () => void;
      }
    ): () => void;
    
    onSnapshot(
      onNext: (snapshot: DocumentSnapshot<T>) => void,
      onError?: (error: FirestoreError) => void,
      onCompletion?: () => void
    ): () => void;
    
    onSnapshot(
      options: SnapshotListenOptions,
      onNext: (snapshot: DocumentSnapshot<T>) => void,
      onError?: (error: FirestoreError) => void,
      onCompletion?: () => void
    ): () => void;

    
    withConverter(converter: null): DocumentReference<DocumentData>;
    
    withConverter<U>(
      converter: FirestoreDataConverter<U>
    ): DocumentReference<U>;
  }

  
  export interface SnapshotOptions {
    
    readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
  }

  
  export interface SnapshotMetadata {
    
    readonly hasPendingWrites: boolean;

    
    readonly fromCache: boolean;

    
    isEqual(other: SnapshotMetadata): boolean;
  }

  
  export class DocumentSnapshot<T = DocumentData> {
    protected constructor();

    
    readonly exists: boolean;
    
    readonly ref: DocumentReference<T>;
    
    readonly id: string;
    
    readonly metadata: SnapshotMetadata;

    
    data(options?: SnapshotOptions): T | undefined;

    
    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;

    
    isEqual(other: DocumentSnapshot<T>): boolean;
  }

  
  export class QueryDocumentSnapshot<
    T = DocumentData
  > extends DocumentSnapshot<T> {
    private constructor();

    
    data(options?: SnapshotOptions): T;
  }

  
  export type OrderByDirection = 'desc' | 'asc';

  
  export type WhereFilterOp =
    | '<'
    | '<='
    | '=='
    | '!='
    | '>='
    | '>'
    | 'array-contains'
    | 'in'
    | 'array-contains-any'
    | 'not-in';

  
  export class Query<T = DocumentData> {
    protected constructor();

    
    readonly firestore: Firestore;

    
    where(
      fieldPath: string | FieldPath,
      opStr: WhereFilterOp,
      value: any
    ): Query<T>;

    
    orderBy(
      fieldPath: string | FieldPath,
      directionStr?: OrderByDirection
    ): Query<T>;

    
    limit(limit: number): Query<T>;

    
    limitToLast(limit: number): Query<T>;

    
    startAt(snapshot: DocumentSnapshot<any>): Query<T>;

    
    startAt(...fieldValues: any[]): Query<T>;

    
    startAfter(snapshot: DocumentSnapshot<any>): Query<T>;

    
    startAfter(...fieldValues: any[]): Query<T>;

    
    endBefore(snapshot: DocumentSnapshot<any>): Query<T>;

    
    endBefore(...fieldValues: any[]): Query<T>;

    
    endAt(snapshot: DocumentSnapshot<any>): Query<T>;

    
    endAt(...fieldValues: any[]): Query<T>;

    
    isEqual(other: Query<T>): boolean;

    
    get(options?: GetOptions): Promise<QuerySnapshot<T>>;

    
    onSnapshot(observer: {
      next?: (snapshot: QuerySnapshot<T>) => void;
      error?: (error: FirestoreError) => void;
      complete?: () => void;
    }): () => void;
    
    onSnapshot(
      options: SnapshotListenOptions,
      observer: {
        next?: (snapshot: QuerySnapshot<T>) => void;
        error?: (error: FirestoreError) => void;
        complete?: () => void;
      }
    ): () => void;
    
    onSnapshot(
      onNext: (snapshot: QuerySnapshot<T>) => void,
      onError?: (error: FirestoreError) => void,
      onCompletion?: () => void
    ): () => void;
    
    onSnapshot(
      options: SnapshotListenOptions,
      onNext: (snapshot: QuerySnapshot<T>) => void,
      onError?: (error: FirestoreError) => void,
      onCompletion?: () => void
    ): () => void;

    
    withConverter(converter: null): Query<DocumentData>;
    
    withConverter<U>(converter: FirestoreDataConverter<U>): Query<U>;
  }

  
  export class QuerySnapshot<T = DocumentData> {
    private constructor();

    
    readonly query: Query<T>;
    
    readonly metadata: SnapshotMetadata;

    
    readonly docs: Array<QueryDocumentSnapshot<T>>;

    
    readonly size: number;

    
    readonly empty: boolean;

    
    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<T>>;

    
    forEach(
      callback: (result: QueryDocumentSnapshot<T>) => void,
      thisArg?: any
    ): void;

    
    isEqual(other: QuerySnapshot<T>): boolean;
  }

  
  export type DocumentChangeType = 'added' | 'removed' | 'modified';

  
  export interface DocumentChange<T = DocumentData> {
    
    readonly type: DocumentChangeType;

    
    readonly doc: QueryDocumentSnapshot<T>;

    
    readonly oldIndex: number;

    
    readonly newIndex: number;
  }

  
  export class CollectionReference<T = DocumentData> extends Query<T> {
    private constructor();

    
    readonly id: string;

    
    readonly parent: DocumentReference<DocumentData> | null;

    
    readonly path: string;

    
    doc(documentPath?: string): DocumentReference<T>;

    
    add(data: T): Promise<DocumentReference<T>>;

    
    isEqual(other: CollectionReference<T>): boolean;

    
    withConverter(converter: null): CollectionReference<DocumentData>;
    
    withConverter<U>(
      converter: FirestoreDataConverter<U>
    ): CollectionReference<U>;
  }

  
  export class FieldValue {
    private constructor();

    
    static serverTimestamp(): FieldValue;

    
    static delete(): FieldValue;

    
    static arrayUnion(...elements: any[]): FieldValue;

    
    static arrayRemove(...elements: any[]): FieldValue;

    
    static increment(n: number): FieldValue;

    
    isEqual(other: FieldValue): boolean;
  }

  
  export class FieldPath {
    
    constructor(...fieldNames: string[]);

    
    static documentId(): FieldPath;

    
    isEqual(other: FieldPath): boolean;
  }

  
  export type FirestoreErrorCode =
    | 'cancelled'
    | 'unknown'
    | 'invalid-argument'
    | 'deadline-exceeded'
    | 'not-found'
    | 'already-exists'
    | 'permission-denied'
    | 'resource-exhausted'
    | 'failed-precondition'
    | 'aborted'
    | 'out-of-range'
    | 'unimplemented'
    | 'internal'
    | 'unavailable'
    | 'data-loss'
    | 'unauthenticated';

  
  
  export interface FirestoreError {
    code: FirestoreErrorCode;
    message: string;
    name: string;
    stack?: string;
  }

  export type EmulatorMockTokenOptions = firebase.EmulatorMockTokenOptions;
}

export default firebase;
export as namespace firebase;
