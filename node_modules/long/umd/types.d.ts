



type LongLike =
  | Long
  | number
  | bigint
  | string
  | { low: number; high: number; unsigned: boolean };

export declare class Long {
  
  constructor(low: number, high?: number, unsigned?: boolean);

  
  static MAX_UNSIGNED_VALUE: Long;

  
  static MAX_VALUE: Long;

  
  static MIN_VALUE: Long;

  
  static NEG_ONE: Long;

  
  static ONE: Long;

  
  static UONE: Long;

  
  static UZERO: Long;

  
  static ZERO: Long;

  
  high: number;

  
  low: number;

  
  unsigned: boolean;

  
  static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;

  
  static fromInt(value: number, unsigned?: boolean): Long;

  
  static fromNumber(value: number, unsigned?: boolean): Long;

  
  static fromBigInt(value: bigint, unsigned?: boolean): Long;

  
  static fromString(
    str: string,
    unsigned?: boolean | number,
    radix?: number,
  ): Long;

  
  static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;

  
  static fromBytesLE(bytes: number[], unsigned?: boolean): Long;

  
  static fromBytesBE(bytes: number[], unsigned?: boolean): Long;

  
  static isLong(obj: any): obj is Long;

  
  static fromValue(val: LongLike, unsigned?: boolean): Long;

  
  add(addend: LongLike): Long;

  
  and(other: LongLike): Long;

  
  compare(other: LongLike): number;

  
  comp(other: LongLike): number;

  
  divide(divisor: LongLike): Long;

  
  div(divisor: LongLike): Long;

  
  equals(other: LongLike): boolean;

  
  eq(other: LongLike): boolean;

  
  getHighBits(): number;

  
  getHighBitsUnsigned(): number;

  
  getLowBits(): number;

  
  getLowBitsUnsigned(): number;

  
  getNumBitsAbs(): number;

  
  greaterThan(other: LongLike): boolean;

  
  gt(other: LongLike): boolean;

  
  greaterThanOrEqual(other: LongLike): boolean;

  
  gte(other: LongLike): boolean;

  
  ge(other: LongLike): boolean;

  
  isEven(): boolean;

  
  isNegative(): boolean;

  
  isOdd(): boolean;

  
  isPositive(): boolean;

  
  isSafeInteger(): boolean;

  
  isZero(): boolean;

  
  eqz(): boolean;

  
  lessThan(other: LongLike): boolean;

  
  lt(other: LongLike): boolean;

  
  lessThanOrEqual(other: LongLike): boolean;

  
  lte(other: LongLike): boolean;

  
  le(other: LongLike): boolean;

  
  modulo(other: LongLike): Long;

  
  mod(other: LongLike): Long;

  
  rem(other: LongLike): Long;

  
  multiply(multiplier: LongLike): Long;

  
  mul(multiplier: LongLike): Long;

  
  negate(): Long;

  
  neg(): Long;

  
  not(): Long;

  
  countLeadingZeros(): number;

  
  clz(): number;

  
  countTrailingZeros(): number;

  
  ctz(): number;

  
  notEquals(other: LongLike): boolean;

  
  neq(other: LongLike): boolean;

  
  ne(other: LongLike): boolean;

  
  or(other: LongLike): Long;

  
  shiftLeft(numBits: number | Long): Long;

  
  shl(numBits: number | Long): Long;

  
  shiftRight(numBits: number | Long): Long;

  
  shr(numBits: number | Long): Long;

  
  shiftRightUnsigned(numBits: number | Long): Long;

  
  shru(numBits: number | Long): Long;

  
  shr_u(numBits: number | Long): Long;

  
  rotateLeft(numBits: number | Long): Long;

  
  rotl(numBits: number | Long): Long;

  
  rotateRight(numBits: number | Long): Long;

  
  rotr(numBits: number | Long): Long;

  
  subtract(subtrahend: LongLike): Long;

  
  sub(subtrahend: LongLike): Long;

  
  toBigInt(): bigint;

  
  toInt(): number;

  
  toNumber(): number;

  

  toBytes(le?: boolean): number[];

  

  toBytesLE(): number[];

  

  toBytesBE(): number[];

  
  toSigned(): Long;

  
  toString(radix?: number): string;

  
  toUnsigned(): Long;

  
  xor(other: LongLike): Long;
}
