

import {onBFCacheRestore} from './lib/bfcache.js';
import {bindReporter} from './lib/bindReporter.js';
import {doubleRAF} from './lib/doubleRAF.js';
import {getActivationStart} from './lib/getActivationStart.js';
import {getVisibilityWatcher} from './lib/getVisibilityWatcher.js';
import {initMetric} from './lib/initMetric.js';
import {observe} from './lib/observe.js';
import {onHidden} from './lib/onHidden.js';
import {runOnce} from './lib/runOnce.js';
import {whenActivated} from './lib/whenActivated.js';
import {whenIdle} from './lib/whenIdle.js';
import {LCPMetric, MetricRatingThresholds, ReportOpts} from './types.js';


export const onLCP = (
  onReport: (metric: LCPMetric) => void,
  opts?: ReportOpts,
) => {
  
  opts = opts || {};

  whenActivated(() => {
    const visibilityWatcher = getVisibilityWatcher();
    let metric = initMetric('LCP');
    let report: ReturnType<typeof bindReporter>;

    const handleEntries = (entries: LCPMetric['entries']) => {
      
      
      if (!opts!.reportAllChanges) {
        entries = entries.slice(-1);
      }

      entries.forEach((entry) => {
        
        if (entry.startTime < visibilityWatcher.firstHiddenTime) {
          
          
          
          
          
          
          metric.value = Math.max(entry.startTime - getActivationStart(), 0);
          metric.entries = [entry];
          report();
        }
      });
    };

    const po = observe('largest-contentful-paint', handleEntries);

    if (po) {
      report = bindReporter(
        onReport,
        metric,
        LCPThresholds,
        opts!.reportAllChanges,
      );

      const stopListening = runOnce(() => {
        if (!reportedMetricIDs[metric.id]) {
          handleEntries(po!.takeRecords() as LCPMetric['entries']);
          po!.disconnect();
          reportedMetricIDs[metric.id] = true;
          report(true);
        }
      });

      
      
      
      ['keydown', 'click'].forEach((type) => {
        
        
        
        addEventListener(type, () => whenIdle(stopListening), {
          once: true,
          capture: true,
        });
      });

      onHidden(stopListening);

      
      
      onBFCacheRestore((event) => {
        metric = initMetric('LCP');
        report = bindReporter(
          onReport,
          metric,
          LCPThresholds,
          opts!.reportAllChanges,
        );

        doubleRAF(() => {
          metric.value = performance.now() - event.timeStamp;
          reportedMetricIDs[metric.id] = true;
          report(true);
        });
      });
    }
  });
};
