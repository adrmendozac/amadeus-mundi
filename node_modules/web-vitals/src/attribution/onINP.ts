

import {getLoadState} from '../lib/getLoadState.js';
import {getSelector} from '../lib/getSelector.js';
import {
  longestInteractionList,
  entryPreProcessingCallbacks,
  longestInteractionMap,
} from '../lib/interactions.js';
import {observe} from '../lib/observe.js';
import {whenIdle} from '../lib/whenIdle.js';
import {onINP as unattributedOnINP} from '../onINP.js';
import {
  INPAttribution,
  INPMetric,
  INPMetricWithAttribution,
  ReportOpts,
} from '../types.js';

interface pendingEntriesGroup {
  startTime: DOMHighResTimeStamp;
  processingStart: DOMHighResTimeStamp;
  processingEnd: DOMHighResTimeStamp;
  renderTime: DOMHighResTimeStamp;
  entries: PerformanceEventTiming[];
}








const MAX_PREVIOUS_FRAMES = 50;



let loafObserver: PerformanceObserver | undefined;




let pendingLoAFs: PerformanceLongAnimationFrameTiming[] = [];




let pendingEntriesGroups: pendingEntriesGroup[] = [];


let latestProcessingEnd: number = 0;




const entryToEntriesGroupMap: WeakMap<
  PerformanceEventTiming,
  pendingEntriesGroup
> = new WeakMap();


export const interactionTargetMap: Map<number, Node> = new Map();




let idleHandle: number = -1;


const handleLoAFEntries = (entries: PerformanceLongAnimationFrameTiming[]) => {
  pendingLoAFs = pendingLoAFs.concat(entries);
  queueCleanup();
};



const saveInteractionTarget = (entry: PerformanceEventTiming) => {
  if (
    entry.interactionId &&
    entry.target &&
    !interactionTargetMap.has(entry.interactionId)
  ) {
    interactionTargetMap.set(entry.interactionId, entry.target);
  }
};


const groupEntriesByRenderTime = (entry: PerformanceEventTiming) => {
  const renderTime = entry.startTime + entry.duration;
  let group;

  latestProcessingEnd = Math.max(latestProcessingEnd, entry.processingEnd);

  
  
  for (let i = pendingEntriesGroups.length - 1; i >= 0; i--) {
    const potentialGroup = pendingEntriesGroups[i];

    
    
    if (Math.abs(renderTime - potentialGroup.renderTime) <= 8) {
      group = potentialGroup;
      group.startTime = Math.min(entry.startTime, group.startTime);
      group.processingStart = Math.min(
        entry.processingStart,
        group.processingStart,
      );
      group.processingEnd = Math.max(entry.processingEnd, group.processingEnd);
      group.entries.push(entry);

      break;
    }
  }

  
  if (!group) {
    group = {
      startTime: entry.startTime,
      processingStart: entry.processingStart,
      processingEnd: entry.processingEnd,
      renderTime,
      entries: [entry],
    };

    pendingEntriesGroups.push(group);
  }

  
  if (entry.interactionId || entry.entryType === 'first-input') {
    entryToEntriesGroupMap.set(entry, group);
  }

  queueCleanup();
};

const queueCleanup = () => {
  
  if (idleHandle < 0) {
    idleHandle = whenIdle(cleanupEntries);
  }
};

const cleanupEntries = () => {
  
  
  if (interactionTargetMap.size > 10) {
    interactionTargetMap.forEach((_, key) => {
      if (!longestInteractionMap.has(key)) {
        interactionTargetMap.delete(key);
      }
    });
  }

  
  
  const longestInteractionGroups = longestInteractionList.map((i) => {
    return entryToEntriesGroupMap.get(i.entries[0]);
  });
  const minIndex = pendingEntriesGroups.length - MAX_PREVIOUS_FRAMES;
  pendingEntriesGroups = pendingEntriesGroups.filter((group, index) => {
    if (index >= minIndex) return true;
    return longestInteractionGroups.includes(group);
  });

  
  
  
  const loafsToKeep: Set<PerformanceLongAnimationFrameTiming> = new Set();
  for (let i = 0; i < pendingEntriesGroups.length; i++) {
    const group = pendingEntriesGroups[i];
    getIntersectingLoAFs(group.startTime, group.processingEnd).forEach(
      (loaf) => {
        loafsToKeep.add(loaf);
      },
    );
  }
  const prevFrameIndexCutoff = pendingLoAFs.length - 1 - MAX_PREVIOUS_FRAMES;
  
  pendingLoAFs = pendingLoAFs.filter((loaf, index) => {
    if (loaf.startTime > latestProcessingEnd && index > prevFrameIndexCutoff) {
      return true;
    }

    return loafsToKeep.has(loaf);
  });

  
  idleHandle = -1;
};

entryPreProcessingCallbacks.push(
  saveInteractionTarget,
  groupEntriesByRenderTime,
);

const getIntersectingLoAFs = (
  start: DOMHighResTimeStamp,
  end: DOMHighResTimeStamp,
) => {
  const intersectingLoAFs = [];

  for (let i = 0, loaf; (loaf = pendingLoAFs[i]); i++) {
    
    if (loaf.startTime + loaf.duration < start) continue;

    
    
    if (loaf.startTime > end) break;

    
    intersectingLoAFs.push(loaf);
  }
  return intersectingLoAFs;
};

const attributeINP = (metric: INPMetric): INPMetricWithAttribution => {
  const firstEntry = metric.entries[0];
  const group = entryToEntriesGroupMap.get(firstEntry)!;

  const processingStart = firstEntry.processingStart;
  const processingEnd = group.processingEnd;

  
  const processedEventEntries = group.entries.sort((a, b) => {
    return a.processingStart - b.processingStart;
  });

  const longAnimationFrameEntries: PerformanceLongAnimationFrameTiming[] =
    getIntersectingLoAFs(firstEntry.startTime, processingEnd);

  
  
  
  
  
  
  const firstEntryWithTarget = metric.entries.find((entry) => entry.target);
  const interactionTargetElement =
    (firstEntryWithTarget && firstEntryWithTarget.target) ||
    interactionTargetMap.get(firstEntry.interactionId);

  
  
  
  const nextPaintTimeCandidates = [
    firstEntry.startTime + firstEntry.duration,
    processingEnd,
  ].concat(
    longAnimationFrameEntries.map((loaf) => loaf.startTime + loaf.duration),
  );

  const nextPaintTime = Math.max.apply(Math, nextPaintTimeCandidates);

  const attribution: INPAttribution = {
    interactionTarget: getSelector(interactionTargetElement),
    interactionTargetElement: interactionTargetElement,
    interactionType: firstEntry.name.startsWith('key') ? 'keyboard' : 'pointer',
    interactionTime: firstEntry.startTime,
    nextPaintTime: nextPaintTime,
    processedEventEntries: processedEventEntries,
    longAnimationFrameEntries: longAnimationFrameEntries,
    inputDelay: processingStart - firstEntry.startTime,
    processingDuration: processingEnd - processingStart,
    presentationDelay: Math.max(nextPaintTime - processingEnd, 0),
    loadState: getLoadState(firstEntry.startTime),
  };

  
  const metricWithAttribution: INPMetricWithAttribution = Object.assign(
    metric,
    {attribution},
  );
  return metricWithAttribution;
};


export const onINP = (
  onReport: (metric: INPMetricWithAttribution) => void,
  opts?: ReportOpts,
) => {
  if (!loafObserver) {
    loafObserver = observe('long-animation-frame', handleLoAFEntries);
  }
  unattributedOnINP((metric: INPMetric) => {
    const metricWithAttribution = attributeINP(metric);
    onReport(metricWithAttribution);
  }, opts);
};
