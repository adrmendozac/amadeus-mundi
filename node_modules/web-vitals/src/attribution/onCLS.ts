

import {getLoadState} from '../lib/getLoadState.js';
import {getSelector} from '../lib/getSelector.js';
import {onCLS as unattributedOnCLS} from '../onCLS.js';
import {
  CLSAttribution,
  CLSMetric,
  CLSMetricWithAttribution,
  ReportOpts,
} from '../types.js';

const getLargestLayoutShiftEntry = (entries: LayoutShift[]) => {
  return entries.reduce((a, b) => (a && a.value > b.value ? a : b));
};

const getLargestLayoutShiftSource = (sources: LayoutShiftAttribution[]) => {
  return sources.find((s) => s.node && s.node.nodeType === 1) || sources[0];
};

const attributeCLS = (metric: CLSMetric): CLSMetricWithAttribution => {
  
  let attribution: CLSAttribution = {};

  if (metric.entries.length) {
    const largestEntry = getLargestLayoutShiftEntry(metric.entries);
    if (largestEntry && largestEntry.sources && largestEntry.sources.length) {
      const largestSource = getLargestLayoutShiftSource(largestEntry.sources);
      if (largestSource) {
        attribution = {
          largestShiftTarget: getSelector(largestSource.node),
          largestShiftTime: largestEntry.startTime,
          largestShiftValue: largestEntry.value,
          largestShiftSource: largestSource,
          largestShiftEntry: largestEntry,
          loadState: getLoadState(largestEntry.startTime),
        };
      }
    }
  }

  
  const metricWithAttribution: CLSMetricWithAttribution = Object.assign(
    metric,
    {attribution},
  );
  return metricWithAttribution;
};


export const onCLS = (
  onReport: (metric: CLSMetricWithAttribution) => void,
  opts?: ReportOpts,
) => {
  unattributedOnCLS((metric: CLSMetric) => {
    const metricWithAttribution = attributeCLS(metric);
    onReport(metricWithAttribution);
  }, opts);
};
