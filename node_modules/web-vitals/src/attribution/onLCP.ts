

import {getNavigationEntry} from '../lib/getNavigationEntry.js';
import {getSelector} from '../lib/getSelector.js';
import {onLCP as unattributedOnLCP} from '../onLCP.js';
import {
  LCPAttribution,
  LCPMetric,
  LCPMetricWithAttribution,
  ReportOpts,
} from '../types.js';

const attributeLCP = (metric: LCPMetric): LCPMetricWithAttribution => {
  
  let attribution: LCPAttribution = {
    timeToFirstByte: 0,
    resourceLoadDelay: 0,
    resourceLoadDuration: 0,
    elementRenderDelay: metric.value,
  };

  if (metric.entries.length) {
    const navigationEntry = getNavigationEntry();
    if (navigationEntry) {
      const activationStart = navigationEntry.activationStart || 0;
      const lcpEntry = metric.entries[metric.entries.length - 1];
      const lcpResourceEntry =
        lcpEntry.url &&
        performance
          .getEntriesByType('resource')
          .filter((e) => e.name === lcpEntry.url)[0];

      const ttfb = Math.max(0, navigationEntry.responseStart - activationStart);

      const lcpRequestStart = Math.max(
        ttfb,
        
        lcpResourceEntry
          ? (lcpResourceEntry.requestStart || lcpResourceEntry.startTime) -
              activationStart
          : 0,
      );
      const lcpResponseEnd = Math.max(
        lcpRequestStart,
        lcpResourceEntry ? lcpResourceEntry.responseEnd - activationStart : 0,
      );
      const lcpRenderTime = Math.max(
        lcpResponseEnd,
        lcpEntry.startTime - activationStart,
      );

      attribution = {
        element: getSelector(lcpEntry.element),
        timeToFirstByte: ttfb,
        resourceLoadDelay: lcpRequestStart - ttfb,
        resourceLoadDuration: lcpResponseEnd - lcpRequestStart,
        elementRenderDelay: lcpRenderTime - lcpResponseEnd,
        navigationEntry,
        lcpEntry,
      };

      
      if (lcpEntry.url) {
        attribution.url = lcpEntry.url;
      }
      if (lcpResourceEntry) {
        attribution.lcpResourceEntry = lcpResourceEntry;
      }
    }
  }

  
  const metricWithAttribution: LCPMetricWithAttribution = Object.assign(
    metric,
    {attribution},
  );
  return metricWithAttribution;
};


export const onLCP = (
  onReport: (metric: LCPMetricWithAttribution) => void,
  opts?: ReportOpts,
) => {
  unattributedOnLCP((metric: LCPMetric) => {
    const metricWithAttribution = attributeLCP(metric);
    onReport(metricWithAttribution);
  }, opts);
};
