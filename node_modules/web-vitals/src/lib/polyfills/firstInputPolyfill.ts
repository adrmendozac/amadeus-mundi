

import {
  FirstInputPolyfillEntry,
  FirstInputPolyfillCallback,
} from '../../types.js';

type addOrRemoveEventListener =
  | typeof addEventListener
  | typeof removeEventListener;

let firstInputEvent: Event | null;
let firstInputDelay: number;
let firstInputTimeStamp: Date;
let callbacks: FirstInputPolyfillCallback[];

const listenerOpts: AddEventListenerOptions = {passive: true, capture: true};
const startTimeStamp: Date = new Date();


export const firstInputPolyfill = (
  onFirstInput: FirstInputPolyfillCallback,
) => {
  callbacks.push(onFirstInput);
  reportFirstInputDelayIfRecordedAndValid();
};

export const resetFirstInputPolyfill = () => {
  callbacks = [];
  firstInputDelay = -1;
  firstInputEvent = null;
  eachEventType(addEventListener);
};


const recordFirstInputDelay = (delay: number, event: Event) => {
  if (!firstInputEvent) {
    firstInputEvent = event;
    firstInputDelay = delay;
    firstInputTimeStamp = new Date();

    eachEventType(removeEventListener);
    reportFirstInputDelayIfRecordedAndValid();
  }
};


const reportFirstInputDelayIfRecordedAndValid = () => {
  
  
  
  
  
  if (
    firstInputDelay >= 0 &&
    
    firstInputDelay < firstInputTimeStamp - startTimeStamp
  ) {
    const entry = {
      entryType: 'first-input',
      name: firstInputEvent!.type,
      target: firstInputEvent!.target,
      cancelable: firstInputEvent!.cancelable,
      startTime: firstInputEvent!.timeStamp,
      processingStart: firstInputEvent!.timeStamp + firstInputDelay,
    } as FirstInputPolyfillEntry;
    callbacks.forEach(function (callback) {
      callback(entry);
    });
    callbacks = [];
  }
};


const onPointerDown = (delay: number, event: Event) => {
  
  const onPointerUp = () => {
    recordFirstInputDelay(delay, event);
    removePointerEventListeners();
  };

  
  const onPointerCancel = () => {
    removePointerEventListeners();
  };

  
  const removePointerEventListeners = () => {
    removeEventListener('pointerup', onPointerUp, listenerOpts);
    removeEventListener('pointercancel', onPointerCancel, listenerOpts);
  };

  addEventListener('pointerup', onPointerUp, listenerOpts);
  addEventListener('pointercancel', onPointerCancel, listenerOpts);
};


const onInput = (event: Event) => {
  
  
  if (event.cancelable) {
    
    
    
    
    
    
    const isEpochTime = event.timeStamp > 1e12;
    const now = isEpochTime ? new Date() : performance.now();

    
    
    const delay = (now as number) - event.timeStamp;

    if (event.type == 'pointerdown') {
      onPointerDown(delay, event);
    } else {
      recordFirstInputDelay(delay, event);
    }
  }
};


const eachEventType = (callback: addOrRemoveEventListener) => {
  const eventTypes = ['mousedown', 'keydown', 'touchstart', 'pointerdown'];
  eventTypes.forEach((type) => callback(type, onInput, listenerOpts));
};
