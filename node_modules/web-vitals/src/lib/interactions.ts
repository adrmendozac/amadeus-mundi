

import {getInteractionCount} from './polyfills/interactionCountPolyfill.js';

interface Interaction {
  id: number;
  latency: number;
  entries: PerformanceEventTiming[];
}

interface EntryPreProcessingHook {
  (entry: PerformanceEventTiming): void;
}



export const longestInteractionList: Interaction[] = [];



export const longestInteractionMap: Map<number, Interaction> = new Map();



export const DEFAULT_DURATION_THRESHOLD = 40;



let prevInteractionCount = 0;


const getInteractionCountForNavigation = () => {
  return getInteractionCount() - prevInteractionCount;
};

export const resetInteractions = () => {
  prevInteractionCount = getInteractionCount();
  longestInteractionList.length = 0;
  longestInteractionMap.clear();
};


export const estimateP98LongestInteraction = () => {
  const candidateInteractionIndex = Math.min(
    longestInteractionList.length - 1,
    Math.floor(getInteractionCountForNavigation() / 50),
  );

  return longestInteractionList[candidateInteractionIndex];
};



const MAX_INTERACTIONS_TO_CONSIDER = 10;


export const entryPreProcessingCallbacks: EntryPreProcessingHook[] = [];


export const processInteractionEntry = (entry: PerformanceEventTiming) => {
  entryPreProcessingCallbacks.forEach((cb) => cb(entry));

  
  if (!(entry.interactionId || entry.entryType === 'first-input')) return;

  
  const minLongestInteraction =
    longestInteractionList[longestInteractionList.length - 1];

  const existingInteraction = longestInteractionMap.get(entry.interactionId!);

  
  
  if (
    existingInteraction ||
    longestInteractionList.length < MAX_INTERACTIONS_TO_CONSIDER ||
    entry.duration > minLongestInteraction.latency
  ) {
    
    if (existingInteraction) {
      
      
      if (entry.duration > existingInteraction.latency) {
        existingInteraction.entries = [entry];
        existingInteraction.latency = entry.duration;
      } else if (
        entry.duration === existingInteraction.latency &&
        entry.startTime === existingInteraction.entries[0].startTime
      ) {
        existingInteraction.entries.push(entry);
      }
    } else {
      const interaction = {
        id: entry.interactionId!,
        latency: entry.duration,
        entries: [entry],
      };
      longestInteractionMap.set(interaction.id, interaction);
      longestInteractionList.push(interaction);
    }

    
    longestInteractionList.sort((a, b) => b.latency - a.latency);
    if (longestInteractionList.length > MAX_INTERACTIONS_TO_CONSIDER) {
      longestInteractionList
        .splice(MAX_INTERACTIONS_TO_CONSIDER)
        .forEach((i) => longestInteractionMap.delete(i.id));
    }
  }
};
