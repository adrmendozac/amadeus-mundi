import type { EndpointParameterInstructions } from "@smithy/middleware-endpoint";
import type { Command as ICommand, Handler, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, Logger, MetadataBearer, MiddlewareStack as IMiddlewareStack, OperationSchema, OptionalParameter, Pluggable, RequestHandler, SerdeContext } from "@smithy/types";

export declare abstract class Command<Input extends ClientInput, Output extends ClientOutput, ResolvedClientConfiguration, ClientInput extends object = any, ClientOutput extends MetadataBearer = any> implements ICommand<ClientInput, Input, ClientOutput, Output, ResolvedClientConfiguration> {
    abstract input: Input;
    readonly middlewareStack: IMiddlewareStack<Input, Output>;
    readonly schema?: OperationSchema;
    
    static classBuilder<I extends SI, O extends SO, C extends {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, SI extends object = any, SO extends MetadataBearer = any>(): ClassBuilder<I, O, C, SI, SO>;
    abstract resolveMiddleware(stack: IMiddlewareStack<ClientInput, ClientOutput>, configuration: ResolvedClientConfiguration, options: any): Handler<Input, Output>;
    
    resolveMiddlewareWithContext(clientStack: IMiddlewareStack<any, any>, configuration: {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, options: any, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }: ResolveMiddlewareContextArgs): import("@smithy/types").InitializeHandler<any, Output>;
}

type ResolveMiddlewareContextArgs = {
    middlewareFn: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[];
    clientName: string;
    commandName: string;
    smithyContext: Record<string, unknown>;
    additionalContext: HandlerExecutionContext;
    inputFilterSensitiveLog: (_: any) => any;
    outputFilterSensitiveLog: (_: any) => any;
    CommandCtor: any;
};

declare class ClassBuilder<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> {
    private _init;
    private _ep;
    private _middlewareFn;
    private _commandName;
    private _clientName;
    private _additionalContext;
    private _smithyContext;
    private _inputFilterSensitiveLog;
    private _outputFilterSensitiveLog;
    private _serializer;
    private _deserializer;
    private _operationSchema?;
    
    init(cb: (_: Command<I, O, C, SI, SO>) => void): void;
    
    ep(endpointParameterInstructions: EndpointParameterInstructions): ClassBuilder<I, O, C, SI, SO>;
    
    m(middlewareSupplier: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[]): ClassBuilder<I, O, C, SI, SO>;
    
    s(service: string, operation: string, smithyContext?: Record<string, unknown>): ClassBuilder<I, O, C, SI, SO>;
    
    c(additionalContext?: HandlerExecutionContext): ClassBuilder<I, O, C, SI, SO>;
    
    n(clientName: string, commandName: string): ClassBuilder<I, O, C, SI, SO>;
    
    f(inputFilter?: (_: any) => any, outputFilter?: (_: any) => any): ClassBuilder<I, O, C, SI, SO>;
    
    ser(serializer: (input: I, context?: SerdeContext | any) => Promise<IHttpRequest>): ClassBuilder<I, O, C, SI, SO>;
    
    de(deserializer: (output: IHttpResponse, context?: SerdeContext | any) => Promise<O>): ClassBuilder<I, O, C, SI, SO>;
    
    sc(operation: OperationSchema): ClassBuilder<I, O, C, SI, SO>;
    
    build(): {
        new (input: I): CommandImpl<I, O, C, SI, SO>;
        new (...[input]: OptionalParameter<I>): CommandImpl<I, O, C, SI, SO>;
        getEndpointParameterInstructions(): EndpointParameterInstructions;
    };
}

export interface CommandImpl<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> extends Command<I, O, C, SI, SO> {
    readonly input: I;
    resolveMiddleware(stack: IMiddlewareStack<SI, SO>, configuration: C, options: any): Handler<I, O>;
}
export {};
