
declare module "events" {
    import { AsyncResource, AsyncResourceOptions } from "node:async_hooks";
    interface EventEmitterOptions {
        
        captureRejections?: boolean | undefined;
    }
    interface StaticEventEmitterOptions {
        
        signal?: AbortSignal | undefined;
    }
    interface StaticEventEmitterIteratorOptions extends StaticEventEmitterOptions {
        
        close?: string[] | undefined;
        
        highWaterMark?: number | undefined;
        
        lowWaterMark?: number | undefined;
    }
    interface EventEmitter<T extends EventMap<T> = DefaultEventMap> extends NodeJS.EventEmitter<T> {}
    type EventMap<T> = Record<keyof T, any[]> | DefaultEventMap;
    type DefaultEventMap = [never];
    type AnyRest = [...args: any[]];
    type Args<K, T> = T extends DefaultEventMap ? AnyRest : (
        K extends keyof T ? T[K] : never
    );
    type Key<K, T> = T extends DefaultEventMap ? string | symbol : K | keyof T;
    type Key2<K, T> = T extends DefaultEventMap ? string | symbol : K & keyof T;
    type Listener<K, T, F> = T extends DefaultEventMap ? F : (
        K extends keyof T ? (
                T[K] extends unknown[] ? (...args: T[K]) => void : never
            )
            : never
    );
    type Listener1<K, T> = Listener<K, T, (...args: any[]) => void>;
    type Listener2<K, T> = Listener<K, T, Function>;

    
    class EventEmitter<T extends EventMap<T> = DefaultEventMap> {
        constructor(options?: EventEmitterOptions);

        [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;

        
        static once(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterOptions,
        ): Promise<any[]>;
        static once(emitter: EventTarget, eventName: string, options?: StaticEventEmitterOptions): Promise<any[]>;
        
        static on(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterIteratorOptions,
        ): NodeJS.AsyncIterator<any[]>;
        static on(
            emitter: EventTarget,
            eventName: string,
            options?: StaticEventEmitterIteratorOptions,
        ): NodeJS.AsyncIterator<any[]>;
        
        static listenerCount(emitter: NodeJS.EventEmitter, eventName: string | symbol): number;
        
        static getEventListeners(emitter: EventTarget | NodeJS.EventEmitter, name: string | symbol): Function[];
        
        static getMaxListeners(emitter: EventTarget | NodeJS.EventEmitter): number;
        
        static setMaxListeners(n?: number, ...eventTargets: Array<EventTarget | NodeJS.EventEmitter>): void;
        
        static addAbortListener(signal: AbortSignal, resource: (event: Event) => void): Disposable;
        
        static readonly errorMonitor: unique symbol;
        
        static readonly captureRejectionSymbol: unique symbol;
        
        static captureRejections: boolean;
        
        static defaultMaxListeners: number;
    }
    import internal = require("node:events");
    namespace EventEmitter {
        
        export { internal as EventEmitter };
        export interface Abortable {
            
            signal?: AbortSignal | undefined;
        }

        export interface EventEmitterReferencingAsyncResource extends AsyncResource {
            readonly eventEmitter: EventEmitterAsyncResource;
        }

        export interface EventEmitterAsyncResourceOptions extends AsyncResourceOptions, EventEmitterOptions {
            
            name?: string | undefined;
        }

        
        export class EventEmitterAsyncResource extends EventEmitter {
            
            constructor(options?: EventEmitterAsyncResourceOptions);
            
            emitDestroy(): void;
            
            readonly asyncId: number;
            
            readonly triggerAsyncId: number;
            
            readonly asyncResource: EventEmitterReferencingAsyncResource;
        }
        
        export interface NodeEventTarget extends EventTarget {
            
            addListener(type: string, listener: (arg: any) => void): this;
            
            emit(type: string, arg: any): boolean;
            
            eventNames(): string[];
            
            listenerCount(type: string): number;
            
            setMaxListeners(n: number): void;
            
            getMaxListeners(): number;
            
            off(type: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
            
            on(type: string, listener: (arg: any) => void): this;
            
            once(type: string, listener: (arg: any) => void): this;
            
            removeAllListeners(type?: string): this;
            
            removeListener(type: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
        }
    }
    global {
        namespace NodeJS {
            interface EventEmitter<T extends EventMap<T> = DefaultEventMap> {
                [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;
                
                addListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                on<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                once<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                removeListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                removeAllListeners(eventName?: Key<unknown, T>): this;
                
                setMaxListeners(n: number): this;
                
                getMaxListeners(): number;
                
                listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                
                rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                
                emit<K>(eventName: Key<K, T>, ...args: Args<K, T>): boolean;
                
                listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;
                
                prependListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                prependOnceListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                
                eventNames(): Array<(string | symbol) & Key2<unknown, T>>;
            }
        }
    }
    export = EventEmitter;
}
declare module "node:events" {
    import events = require("events");
    export = events;
}
