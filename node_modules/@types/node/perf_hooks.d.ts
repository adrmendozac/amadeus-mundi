
declare module "perf_hooks" {
    import { AsyncResource } from "node:async_hooks";
    type EntryType =
        | "dns" 
        | "function" 
        | "gc" 
        | "http2" 
        | "http" 
        | "mark" 
        | "measure" 
        | "net" 
        | "node" 
        | "resource"; 
    interface NodeGCPerformanceDetail {
        
        readonly kind: number;
        
        readonly flags: number;
    }
    
    class PerformanceEntry {
        protected constructor();
        
        readonly duration: number;
        
        readonly name: string;
        
        readonly startTime: number;
        
        readonly entryType: EntryType;
        toJSON(): any;
    }
    
    class PerformanceMark extends PerformanceEntry {
        readonly detail: any;
        readonly duration: 0;
        readonly entryType: "mark";
    }
    
    class PerformanceMeasure extends PerformanceEntry {
        readonly detail: any;
        readonly entryType: "measure";
    }
    interface UVMetrics {
        
        readonly loopCount: number;
        
        readonly events: number;
        
        readonly eventsWaiting: number;
    }
    
    
    class PerformanceNodeTiming extends PerformanceEntry {
        readonly entryType: "node";
        
        readonly bootstrapComplete: number;
        
        readonly environment: number;
        
        readonly idleTime: number;
        
        readonly loopExit: number;
        
        readonly loopStart: number;
        
        readonly nodeStart: number;
        
        readonly uvMetricsInfo: UVMetrics;
        
        readonly v8Start: number;
    }
    interface EventLoopUtilization {
        idle: number;
        active: number;
        utilization: number;
    }
    
    type EventLoopUtilityFunction = (
        utilization1?: EventLoopUtilization,
        utilization2?: EventLoopUtilization,
    ) => EventLoopUtilization;
    interface MarkOptions {
        
        detail?: unknown | undefined;
        
        startTime?: number | undefined;
    }
    interface MeasureOptions {
        
        detail?: unknown;
        
        duration?: number | undefined;
        
        end?: number | string | undefined;
        
        start?: number | string | undefined;
    }
    interface TimerifyOptions {
        
        histogram?: RecordableHistogram | undefined;
    }
    interface Performance {
        
        clearMarks(name?: string): void;
        
        clearMeasures(name?: string): void;
        
        clearResourceTimings(name?: string): void;
        
        eventLoopUtilization: EventLoopUtilityFunction;
        
        getEntries(): PerformanceEntry[];
        
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        
        getEntriesByType(type: EntryType): PerformanceEntry[];
        
        mark(name: string, options?: MarkOptions): PerformanceMark;
        
        markResourceTiming(
            timingInfo: object,
            requestedUrl: string,
            initiatorType: string,
            global: object,
            cacheMode: "" | "local",
            bodyInfo: object,
            responseStatus: number,
            deliveryType?: string,
        ): PerformanceResourceTiming;
        
        measure(name: string, startMark?: string, endMark?: string): PerformanceMeasure;
        measure(name: string, options: MeasureOptions): PerformanceMeasure;
        
        readonly nodeTiming: PerformanceNodeTiming;
        
        now(): number;
        
        setResourceTimingBufferSize(maxSize: number): void;
        
        readonly timeOrigin: number;
        
        timerify<T extends (...params: any[]) => any>(fn: T, options?: TimerifyOptions): T;
        
        toJSON(): any;
    }
    class PerformanceObserverEntryList {
        
        getEntries(): PerformanceEntry[];
        
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        
        getEntriesByType(type: EntryType): PerformanceEntry[];
    }
    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;
    
    class PerformanceObserver extends AsyncResource {
        constructor(callback: PerformanceObserverCallback);
        
        disconnect(): void;
        
        observe(
            options:
                | {
                    entryTypes: readonly EntryType[];
                    buffered?: boolean | undefined;
                }
                | {
                    type: EntryType;
                    buffered?: boolean | undefined;
                },
        ): void;
        
        takeRecords(): PerformanceEntry[];
    }
    
    class PerformanceResourceTiming extends PerformanceEntry {
        readonly entryType: "resource";
        protected constructor();
        
        readonly workerStart: number;
        
        readonly redirectStart: number;
        
        readonly redirectEnd: number;
        
        readonly fetchStart: number;
        
        readonly domainLookupStart: number;
        
        readonly domainLookupEnd: number;
        
        readonly connectStart: number;
        
        readonly connectEnd: number;
        
        readonly secureConnectionStart: number;
        
        readonly requestStart: number;
        
        readonly responseEnd: number;
        
        readonly transferSize: number;
        
        readonly encodedBodySize: number;
        
        readonly decodedBodySize: number;
        
        toJSON(): any;
    }
    namespace constants {
        const NODE_PERFORMANCE_GC_MAJOR: number;
        const NODE_PERFORMANCE_GC_MINOR: number;
        const NODE_PERFORMANCE_GC_INCREMENTAL: number;
        const NODE_PERFORMANCE_GC_WEAKCB: number;
        const NODE_PERFORMANCE_GC_FLAGS_NO: number;
        const NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: number;
        const NODE_PERFORMANCE_GC_FLAGS_FORCED: number;
        const NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: number;
        const NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: number;
    }
    const performance: Performance;
    interface EventLoopMonitorOptions {
        
        resolution?: number | undefined;
    }
    interface Histogram {
        
        readonly count: number;
        
        readonly countBigInt: bigint;
        
        readonly exceeds: number;
        
        readonly exceedsBigInt: bigint;
        
        readonly max: number;
        
        readonly maxBigInt: number;
        
        readonly mean: number;
        
        readonly min: number;
        
        readonly minBigInt: bigint;
        
        percentile(percentile: number): number;
        
        percentileBigInt(percentile: number): bigint;
        
        readonly percentiles: Map<number, number>;
        
        readonly percentilesBigInt: Map<bigint, bigint>;
        
        reset(): void;
        
        readonly stddev: number;
    }
    interface IntervalHistogram extends Histogram {
        
        enable(): boolean;
        
        disable(): boolean;
        
        [Symbol.dispose](): void;
    }
    interface RecordableHistogram extends Histogram {
        
        record(val: number | bigint): void;
        
        recordDelta(): void;
        
        add(other: RecordableHistogram): void;
    }
    
    function monitorEventLoopDelay(options?: EventLoopMonitorOptions): IntervalHistogram;
    interface CreateHistogramOptions {
        
        lowest?: number | bigint | undefined;
        
        highest?: number | bigint | undefined;
        
        figures?: number | undefined;
    }
    
    function createHistogram(options?: CreateHistogramOptions): RecordableHistogram;
    import {
        performance as _performance,
        PerformanceEntry as _PerformanceEntry,
        PerformanceMark as _PerformanceMark,
        PerformanceMeasure as _PerformanceMeasure,
        PerformanceObserver as _PerformanceObserver,
        PerformanceObserverEntryList as _PerformanceObserverEntryList,
        PerformanceResourceTiming as _PerformanceResourceTiming,
    } from "perf_hooks";
    global {
        
        var PerformanceEntry: typeof globalThis extends {
            onmessage: any;
            PerformanceEntry: infer T;
        } ? T
            : typeof _PerformanceEntry;
        
        var PerformanceMark: typeof globalThis extends {
            onmessage: any;
            PerformanceMark: infer T;
        } ? T
            : typeof _PerformanceMark;
        
        var PerformanceMeasure: typeof globalThis extends {
            onmessage: any;
            PerformanceMeasure: infer T;
        } ? T
            : typeof _PerformanceMeasure;
        
        var PerformanceObserver: typeof globalThis extends {
            onmessage: any;
            PerformanceObserver: infer T;
        } ? T
            : typeof _PerformanceObserver;
        
        var PerformanceObserverEntryList: typeof globalThis extends {
            onmessage: any;
            PerformanceObserverEntryList: infer T;
        } ? T
            : typeof _PerformanceObserverEntryList;
        
        var PerformanceResourceTiming: typeof globalThis extends {
            onmessage: any;
            PerformanceResourceTiming: infer T;
        } ? T
            : typeof _PerformanceResourceTiming;
        
        var performance: typeof globalThis extends {
            onmessage: any;
            performance: infer T;
        } ? T
            : typeof _performance;
    }
}
declare module "node:perf_hooks" {
    export * from "perf_hooks";
}
