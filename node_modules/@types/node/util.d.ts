
declare module "util" {
    import * as types from "node:util/types";
    export interface InspectOptions {
        
        showHidden?: boolean | undefined;
        
        depth?: number | null | undefined;
        
        colors?: boolean | undefined;
        
        customInspect?: boolean | undefined;
        
        showProxy?: boolean | undefined;
        
        maxArrayLength?: number | null | undefined;
        
        maxStringLength?: number | null | undefined;
        
        breakLength?: number | undefined;
        
        compact?: boolean | number | undefined;
        
        sorted?: boolean | ((a: string, b: string) => number) | undefined;
        
        getters?: "get" | "set" | boolean | undefined;
        
        numericSeparator?: boolean | undefined;
    }
    export type Style =
        | "special"
        | "number"
        | "bigint"
        | "boolean"
        | "undefined"
        | "null"
        | "string"
        | "symbol"
        | "date"
        | "regexp"
        | "module";
    export type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => any; 
    export interface InspectOptionsStylized extends InspectOptions {
        stylize(text: string, styleType: Style): string;
    }
    export interface CallSiteObject {
        
        functionName: string;
        
        scriptName: string;
        
        scriptId: string;
        
        lineNumber: number;
        
        columnNumber: number;
    }
    export type DiffEntry = [operation: -1 | 0 | 1, value: string];
    
    export function diff(actual: string | readonly string[], expected: string | readonly string[]): DiffEntry[];
    
    export function format(format?: any, ...param: any[]): string;
    
    export function formatWithOptions(inspectOptions: InspectOptions, format?: any, ...param: any[]): string;
    interface GetCallSitesOptions {
        
        sourceMap?: boolean | undefined;
    }
    
    export function getCallSites(frameCount?: number, options?: GetCallSitesOptions): CallSiteObject[];
    export function getCallSites(options: GetCallSitesOptions): CallSiteObject[];
    
    export function getSystemErrorName(err: number): string;
    
    export function setTraceSigInt(enable: boolean): void;
    
    export function getSystemErrorMap(): Map<number, [string, string]>;
    
    export function getSystemErrorMessage(err: number): string;
    
    export function toUSVString(string: string): string;
    
    export function transferableAbortController(): AbortController;
    
    export function transferableAbortSignal(signal: AbortSignal): AbortSignal;
    
    export function aborted(signal: AbortSignal, resource: any): Promise<void>;
    
    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;
    export function inspect(object: any, options?: InspectOptions): string;
    export namespace inspect {
        let colors: NodeJS.Dict<[number, number]>;
        let styles: {
            [K in Style]: string;
        };
        let defaultOptions: InspectOptions;
        
        let replDefaults: InspectOptions;
        
        const custom: unique symbol;
    }
    
    export function isArray(object: unknown): object is unknown[];
    
    export function inherits(constructor: unknown, superConstructor: unknown): void;
    export type DebugLoggerFunction = (msg: string, ...param: unknown[]) => void;
    export interface DebugLogger extends DebugLoggerFunction {
        
        enabled: boolean;
    }
    
    export function debuglog(section: string, callback?: (fn: DebugLoggerFunction) => void): DebugLogger;
    export { debuglog as debug };
    
    export function deprecate<T extends Function>(fn: T, msg: string, code?: string): T;
    
    export function isDeepStrictEqual(val1: unknown, val2: unknown): boolean;
    
    export function stripVTControlCharacters(str: string): string;
    
    export function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<TResult>(
        fn: () => Promise<TResult>,
    ): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;
    export function callbackify<T1>(
        fn: (arg1: T1) => Promise<void>,
    ): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<T1, TResult>(
        fn: (arg1: T1) => Promise<TResult>,
    ): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;
    export function callbackify<T1, T2>(
        fn: (arg1: T1, arg2: T2) => Promise<void>,
    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<T1, T2, TResult>(
        fn: (arg1: T1, arg2: T2) => Promise<TResult>,
    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;
    export function callbackify<T1, T2, T3>(
        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>,
    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<T1, T2, T3, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>,
    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;
    export function callbackify<T1, T2, T3, T4>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<T1, T2, T3, T4, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>,
    ): (
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
    ) => void;
    export function callbackify<T1, T2, T3, T4, T5>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;
    export function callbackify<T1, T2, T3, T4, T5, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,
    ): (
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        arg5: T5,
        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
    ) => void;
    export function callbackify<T1, T2, T3, T4, T5, T6>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,
    ): (
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        arg5: T5,
        arg6: T6,
        callback: (err: NodeJS.ErrnoException) => void,
    ) => void;
    export function callbackify<T1, T2, T3, T4, T5, T6, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>,
    ): (
        arg1: T1,
        arg2: T2,
        arg3: T3,
        arg4: T4,
        arg5: T5,
        arg6: T6,
        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
    ) => void;
    export interface CustomPromisifyLegacy<TCustom extends Function> extends Function {
        __promisify__: TCustom;
    }
    export interface CustomPromisifySymbol<TCustom extends Function> extends Function {
        [promisify.custom]: TCustom;
    }
    export type CustomPromisify<TCustom extends Function> =
        | CustomPromisifySymbol<TCustom>
        | CustomPromisifyLegacy<TCustom>;
    
    export function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;
    export function promisify<TResult>(
        fn: (callback: (err: any, result: TResult) => void) => void,
    ): () => Promise<TResult>;
    export function promisify(fn: (callback: (err?: any) => void) => void): () => Promise<void>;
    export function promisify<T1, TResult>(
        fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void,
    ): (arg1: T1) => Promise<TResult>;
    export function promisify<T1>(fn: (arg1: T1, callback: (err?: any) => void) => void): (arg1: T1) => Promise<void>;
    export function promisify<T1, T2, TResult>(
        fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void,
    ): (arg1: T1, arg2: T2) => Promise<TResult>;
    export function promisify<T1, T2>(
        fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void,
    ): (arg1: T1, arg2: T2) => Promise<void>;
    export function promisify<T1, T2, T3, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: TResult) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;
    export function promisify<T1, T2, T3>(
        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: any) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;
    export function promisify<T1, T2, T3, T4, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: any, result: TResult) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;
    export function promisify<T1, T2, T3, T4>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: any) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;
    export function promisify<T1, T2, T3, T4, T5, TResult>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: any, result: TResult) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;
    export function promisify<T1, T2, T3, T4, T5>(
        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: any) => void) => void,
    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;
    export function promisify(fn: Function): Function;
    export namespace promisify {
        
        const custom: unique symbol;
    }
    
    export function parseEnv(content: string): NodeJS.Dict<string>;
    
    type ForegroundColors =
        | "black"
        | "blackBright"
        | "blue"
        | "blueBright"
        | "cyan"
        | "cyanBright"
        | "gray"
        | "green"
        | "greenBright"
        | "grey"
        | "magenta"
        | "magentaBright"
        | "red"
        | "redBright"
        | "white"
        | "whiteBright"
        | "yellow"
        | "yellowBright";
    
    type BackgroundColors =
        | "bgBlack"
        | "bgBlackBright"
        | "bgBlue"
        | "bgBlueBright"
        | "bgCyan"
        | "bgCyanBright"
        | "bgGray"
        | "bgGreen"
        | "bgGreenBright"
        | "bgGrey"
        | "bgMagenta"
        | "bgMagentaBright"
        | "bgRed"
        | "bgRedBright"
        | "bgWhite"
        | "bgWhiteBright"
        | "bgYellow"
        | "bgYellowBright";
    
    type Modifiers =
        | "blink"
        | "bold"
        | "dim"
        | "doubleunderline"
        | "framed"
        | "hidden"
        | "inverse"
        | "italic"
        | "none"
        | "overlined"
        | "reset"
        | "strikethrough"
        | "underline";
    export interface StyleTextOptions {
        
        validateStream?: boolean | undefined;
        
        stream?: NodeJS.WritableStream | undefined;
    }
    
    export function styleText(
        format:
            | ForegroundColors
            | BackgroundColors
            | Modifiers
            | Array<ForegroundColors | BackgroundColors | Modifiers>,
        text: string,
        options?: StyleTextOptions,
    ): string;
    
    export class TextDecoder {
        
        readonly encoding: string;
        
        readonly fatal: boolean;
        
        readonly ignoreBOM: boolean;
        constructor(
            encoding?: string,
            options?: {
                fatal?: boolean | undefined;
                ignoreBOM?: boolean | undefined;
            },
        );
        
        decode(
            input?: NodeJS.ArrayBufferView | ArrayBuffer | null,
            options?: {
                stream?: boolean | undefined;
            },
        ): string;
    }
    export interface EncodeIntoResult {
        
        read: number;
        
        written: number;
    }
    export { types };

    
    
    export class TextEncoder {
        
        readonly encoding: string;
        
        encode(input?: string): Uint8Array;
        
        encodeInto(src: string, dest: Uint8Array): EncodeIntoResult;
    }
    import { TextDecoder as _TextDecoder, TextEncoder as _TextEncoder } from "util";
    global {
        
        var TextDecoder: typeof globalThis extends {
            onmessage: any;
            TextDecoder: infer TextDecoder;
        } ? TextDecoder
            : typeof _TextDecoder;
        
        var TextEncoder: typeof globalThis extends {
            onmessage: any;
            TextEncoder: infer TextEncoder;
        } ? TextEncoder
            : typeof _TextEncoder;
    }

    
    
    export function parseArgs<T extends ParseArgsConfig>(config?: T): ParsedResults<T>;

    
    export type ParseArgsOptionsType = "boolean" | "string";

    export interface ParseArgsOptionDescriptor {
        
        type: ParseArgsOptionsType;
        
        multiple?: boolean | undefined;
        
        short?: string | undefined;
        
        default?: string | boolean | string[] | boolean[] | undefined;
    }
    export interface ParseArgsOptionsConfig {
        [longOption: string]: ParseArgsOptionDescriptor;
    }
    export interface ParseArgsConfig {
        
        args?: string[] | undefined;
        
        options?: ParseArgsOptionsConfig | undefined;
        
        strict?: boolean | undefined;
        
        allowPositionals?: boolean | undefined;
        
        allowNegative?: boolean | undefined;
        
        tokens?: boolean | undefined;
    }
    
    type IfDefaultsTrue<T, IfTrue, IfFalse> = T extends true ? IfTrue
        : T extends false ? IfFalse
        : IfTrue;

    
    type IfDefaultsFalse<T, IfTrue, IfFalse> = T extends false ? IfFalse
        : T extends true ? IfTrue
        : IfFalse;

    type ExtractOptionValue<T extends ParseArgsConfig, O extends ParseArgsOptionDescriptor> = IfDefaultsTrue<
        T["strict"],
        O["type"] extends "string" ? string : O["type"] extends "boolean" ? boolean : string | boolean,
        string | boolean
    >;

    type ApplyOptionalModifiers<O extends ParseArgsOptionsConfig, V extends Record<keyof O, unknown>> = (
        & { -readonly [LongOption in keyof O]?: V[LongOption] }
        & { [LongOption in keyof O as O[LongOption]["default"] extends {} ? LongOption : never]: V[LongOption] }
    ) extends infer P ? { [K in keyof P]: P[K] } : never; 

    type ParsedValues<T extends ParseArgsConfig> =
        & IfDefaultsTrue<T["strict"], unknown, { [longOption: string]: undefined | string | boolean }>
        & (T["options"] extends ParseArgsOptionsConfig ? ApplyOptionalModifiers<
                T["options"],
                {
                    [LongOption in keyof T["options"]]: IfDefaultsFalse<
                        T["options"][LongOption]["multiple"],
                        Array<ExtractOptionValue<T, T["options"][LongOption]>>,
                        ExtractOptionValue<T, T["options"][LongOption]>
                    >;
                }
            >
            : {});

    type ParsedPositionals<T extends ParseArgsConfig> = IfDefaultsTrue<
        T["strict"],
        IfDefaultsFalse<T["allowPositionals"], string[], []>,
        IfDefaultsTrue<T["allowPositionals"], string[], []>
    >;

    type PreciseTokenForOptions<
        K extends string,
        O extends ParseArgsOptionDescriptor,
    > = O["type"] extends "string" ? {
            kind: "option";
            index: number;
            name: K;
            rawName: string;
            value: string;
            inlineValue: boolean;
        }
        : O["type"] extends "boolean" ? {
                kind: "option";
                index: number;
                name: K;
                rawName: string;
                value: undefined;
                inlineValue: undefined;
            }
        : OptionToken & { name: K };

    type TokenForOptions<
        T extends ParseArgsConfig,
        K extends keyof T["options"] = keyof T["options"],
    > = K extends unknown
        ? T["options"] extends ParseArgsOptionsConfig ? PreciseTokenForOptions<K & string, T["options"][K]>
        : OptionToken
        : never;

    type ParsedOptionToken<T extends ParseArgsConfig> = IfDefaultsTrue<T["strict"], TokenForOptions<T>, OptionToken>;

    type ParsedPositionalToken<T extends ParseArgsConfig> = IfDefaultsTrue<
        T["strict"],
        IfDefaultsFalse<T["allowPositionals"], { kind: "positional"; index: number; value: string }, never>,
        IfDefaultsTrue<T["allowPositionals"], { kind: "positional"; index: number; value: string }, never>
    >;

    type ParsedTokens<T extends ParseArgsConfig> = Array<
        ParsedOptionToken<T> | ParsedPositionalToken<T> | { kind: "option-terminator"; index: number }
    >;

    type PreciseParsedResults<T extends ParseArgsConfig> = IfDefaultsFalse<
        T["tokens"],
        {
            values: ParsedValues<T>;
            positionals: ParsedPositionals<T>;
            tokens: ParsedTokens<T>;
        },
        {
            values: ParsedValues<T>;
            positionals: ParsedPositionals<T>;
        }
    >;

    type OptionToken =
        | { kind: "option"; index: number; name: string; rawName: string; value: string; inlineValue: boolean }
        | {
            kind: "option";
            index: number;
            name: string;
            rawName: string;
            value: undefined;
            inlineValue: undefined;
        };

    type Token =
        | OptionToken
        | { kind: "positional"; index: number; value: string }
        | { kind: "option-terminator"; index: number };

    
    
    type ParsedResults<T extends ParseArgsConfig> = ParseArgsConfig extends T ? {
            values: {
                [longOption: string]: undefined | string | boolean | Array<string | boolean>;
            };
            positionals: string[];
            tokens?: Token[];
        }
        : PreciseParsedResults<T>;

    
    export class MIMEType {
        
        constructor(input: string | { toString: () => string });

        
        type: string;
        
        subtype: string;
        
        readonly essence: string;
        
        readonly params: MIMEParams;
        
        toString(): string;
    }
    
    export class MIMEParams {
        
        delete(name: string): void;
        
        entries(): NodeJS.Iterator<[name: string, value: string]>;
        
        get(name: string): string | null;
        
        has(name: string): boolean;
        
        keys(): NodeJS.Iterator<string>;
        
        set(name: string, value: string): void;
        
        values(): NodeJS.Iterator<string>;
        
        [Symbol.iterator](): NodeJS.Iterator<[name: string, value: string]>;
    }
}
declare module "util/types" {
    import { KeyObject, webcrypto } from "node:crypto";
    
    function isAnyArrayBuffer(object: unknown): object is ArrayBufferLike;
    
    function isArgumentsObject(object: unknown): object is IArguments;
    
    function isArrayBuffer(object: unknown): object is ArrayBuffer;
    
    function isArrayBufferView(object: unknown): object is NodeJS.ArrayBufferView;
    
    function isAsyncFunction(object: unknown): boolean;
    
    function isBigInt64Array(value: unknown): value is BigInt64Array;
    
    function isBigIntObject(object: unknown): object is BigInt;
    
    function isBigUint64Array(value: unknown): value is BigUint64Array;
    
    function isBooleanObject(object: unknown): object is Boolean;
    
    function isBoxedPrimitive(object: unknown): object is String | Number | BigInt | Boolean | Symbol;
    
    function isDataView(object: unknown): object is DataView;
    
    function isDate(object: unknown): object is Date;
    
    function isExternal(object: unknown): boolean;
    
    function isFloat16Array(object: unknown): object is Float16Array;
    
    function isFloat32Array(object: unknown): object is Float32Array;
    
    function isFloat64Array(object: unknown): object is Float64Array;
    
    function isGeneratorFunction(object: unknown): object is GeneratorFunction;
    
    function isGeneratorObject(object: unknown): object is Generator;
    
    function isInt8Array(object: unknown): object is Int8Array;
    
    function isInt16Array(object: unknown): object is Int16Array;
    
    function isInt32Array(object: unknown): object is Int32Array;
    
    function isMap<T>(
        object: T | {},
    ): object is T extends ReadonlyMap<any, any> ? (unknown extends T ? never : ReadonlyMap<any, any>)
        : Map<unknown, unknown>;
    
    function isMapIterator(object: unknown): boolean;
    
    function isModuleNamespaceObject(value: unknown): boolean;
    
    function isNativeError(object: unknown): object is Error;
    
    function isNumberObject(object: unknown): object is Number;
    
    function isPromise(object: unknown): object is Promise<unknown>;
    
    function isProxy(object: unknown): boolean;
    
    function isRegExp(object: unknown): object is RegExp;
    
    function isSet<T>(
        object: T | {},
    ): object is T extends ReadonlySet<any> ? (unknown extends T ? never : ReadonlySet<any>) : Set<unknown>;
    
    function isSetIterator(object: unknown): boolean;
    
    function isSharedArrayBuffer(object: unknown): object is SharedArrayBuffer;
    
    function isStringObject(object: unknown): object is String;
    
    function isSymbolObject(object: unknown): object is Symbol;
    
    function isTypedArray(object: unknown): object is NodeJS.TypedArray;
    
    function isUint8Array(object: unknown): object is Uint8Array;
    
    function isUint8ClampedArray(object: unknown): object is Uint8ClampedArray;
    
    function isUint16Array(object: unknown): object is Uint16Array;
    
    function isUint32Array(object: unknown): object is Uint32Array;
    
    function isWeakMap(object: unknown): object is WeakMap<object, unknown>;
    
    function isWeakSet(object: unknown): object is WeakSet<object>;
    
    function isKeyObject(object: unknown): object is KeyObject;
    
    function isCryptoKey(object: unknown): object is webcrypto.CryptoKey;
}
declare module "node:util" {
    export * from "util";
}
declare module "node:util/types" {
    export * from "util/types";
}
