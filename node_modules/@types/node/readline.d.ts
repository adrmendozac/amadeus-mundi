
declare module "readline" {
    import { Abortable, EventEmitter } from "node:events";
    import * as promises from "node:readline/promises";
    export { promises };
    export interface Key {
        sequence?: string | undefined;
        name?: string | undefined;
        ctrl?: boolean | undefined;
        meta?: boolean | undefined;
        shift?: boolean | undefined;
    }
    
    export class Interface extends EventEmitter implements Disposable {
        readonly terminal: boolean;
        
        readonly line: string;
        
        readonly cursor: number;
        
        protected constructor(
            input: NodeJS.ReadableStream,
            output?: NodeJS.WritableStream,
            completer?: Completer | AsyncCompleter,
            terminal?: boolean,
        );
        
        protected constructor(options: ReadLineOptions);
        
        getPrompt(): string;
        
        setPrompt(prompt: string): void;
        
        prompt(preserveCursor?: boolean): void;
        
        question(query: string, callback: (answer: string) => void): void;
        question(query: string, options: Abortable, callback: (answer: string) => void): void;
        
        pause(): this;
        
        resume(): this;
        
        close(): void;
        
        [Symbol.dispose](): void;
        
        write(data: string | Buffer, key?: Key): void;
        write(data: undefined | null | string | Buffer, key: Key): void;
        
        getCursorPos(): CursorPos;
        
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "history", listener: (history: string[]) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "history", history: string[]): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "history", listener: (history: string[]) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "history", listener: (history: string[]) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "history", listener: (history: string[]) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "history", listener: (history: string[]) => void): this;
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<string>;
    }
    export type ReadLine = Interface; 
    export type Completer = (line: string) => CompleterResult;
    export type AsyncCompleter = (
        line: string,
        callback: (err?: null | Error, result?: CompleterResult) => void,
    ) => void;
    export type CompleterResult = [string[], string];
    export interface ReadLineOptions {
        
        input: NodeJS.ReadableStream;
        
        output?: NodeJS.WritableStream | undefined;
        
        completer?: Completer | AsyncCompleter | undefined;
        
        terminal?: boolean | undefined;
        
        history?: string[] | undefined;
        
        historySize?: number | undefined;
        
        removeHistoryDuplicates?: boolean | undefined;
        
        prompt?: string | undefined;
        
        crlfDelay?: number | undefined;
        
        escapeCodeTimeout?: number | undefined;
        
        tabSize?: number | undefined;
        
        signal?: AbortSignal | undefined;
    }
    
    export function createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer | AsyncCompleter,
        terminal?: boolean,
    ): Interface;
    export function createInterface(options: ReadLineOptions): Interface;
    
    export function emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;
    export type Direction = -1 | 0 | 1;
    export interface CursorPos {
        rows: number;
        cols: number;
    }
    
    export function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;
    
    export function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;
    
    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;
    
    export function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;
}
declare module "node:readline" {
    export * from "readline";
}
