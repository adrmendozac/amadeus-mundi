
declare module "v8" {
    import { Readable } from "node:stream";
    interface HeapSpaceInfo {
        space_name: string;
        space_size: number;
        space_used_size: number;
        space_available_size: number;
        physical_space_size: number;
    }
    
    type DoesZapCodeSpaceFlag = 0 | 1;
    interface HeapInfo {
        total_heap_size: number;
        total_heap_size_executable: number;
        total_physical_size: number;
        total_available_size: number;
        used_heap_size: number;
        heap_size_limit: number;
        malloced_memory: number;
        peak_malloced_memory: number;
        does_zap_garbage: DoesZapCodeSpaceFlag;
        number_of_native_contexts: number;
        number_of_detached_contexts: number;
        total_global_handles_size: number;
        used_global_handles_size: number;
        external_memory: number;
    }
    interface HeapCodeStatistics {
        code_and_metadata_size: number;
        bytecode_and_metadata_size: number;
        external_script_source_size: number;
    }
    interface HeapSnapshotOptions {
        
        exposeInternals?: boolean | undefined;
        
        exposeNumericValues?: boolean | undefined;
    }
    
    function cachedDataVersionTag(): number;
    
    function getHeapStatistics(): HeapInfo;
    
    function getCppHeapStatistics(detailLevel?: "brief" | "detailed"): object;
    
    function getHeapSpaceStatistics(): HeapSpaceInfo[];
    
    function setFlagsFromString(flags: string): void;
    
    function queryObjects(ctor: Function): number | string[];
    function queryObjects(ctor: Function, options: { format: "count" }): number;
    function queryObjects(ctor: Function, options: { format: "summary" }): string[];
    
    function getHeapSnapshot(options?: HeapSnapshotOptions): Readable;
    
    function writeHeapSnapshot(filename?: string, options?: HeapSnapshotOptions): string;
    
    function getHeapCodeStatistics(): HeapCodeStatistics;
    
    interface CPUProfileHandle {
        
        stop(): Promise<string>;
        
        [Symbol.asyncDispose](): Promise<void>;
    }
    
    function isStringOneByteRepresentation(content: string): boolean;
    
    class Serializer {
        
        writeHeader(): void;
        
        writeValue(val: any): boolean;
        
        releaseBuffer(): Buffer;
        
        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;
        
        writeUint32(value: number): void;
        
        writeUint64(hi: number, lo: number): void;
        
        writeDouble(value: number): void;
        
        writeRawBytes(buffer: NodeJS.TypedArray): void;
    }
    
    class DefaultSerializer extends Serializer {}
    
    class Deserializer {
        constructor(data: NodeJS.TypedArray);
        
        readHeader(): boolean;
        
        readValue(): any;
        
        transferArrayBuffer(id: number, arrayBuffer: ArrayBuffer): void;
        
        getWireFormatVersion(): number;
        
        readUint32(): number;
        
        readUint64(): [number, number];
        
        readDouble(): number;
        
        readRawBytes(length: number): Buffer;
    }
    
    class DefaultDeserializer extends Deserializer {}
    
    function serialize(value: any): Buffer;
    
    function deserialize(buffer: NodeJS.ArrayBufferView): any;
    
    function takeCoverage(): void;
    
    function stopCoverage(): void;
    
    function setHeapSnapshotNearHeapLimit(limit: number): void;
    
    class GCProfiler {
        
        start(): void;
        
        stop(): GCProfilerResult;
    }
    interface GCProfilerResult {
        version: number;
        startTime: number;
        endTime: number;
        statistics: Array<{
            gcType: string;
            cost: number;
            beforeGC: {
                heapStatistics: HeapStatistics;
                heapSpaceStatistics: HeapSpaceStatistics[];
            };
            afterGC: {
                heapStatistics: HeapStatistics;
                heapSpaceStatistics: HeapSpaceStatistics[];
            };
        }>;
    }
    interface HeapStatistics {
        totalHeapSize: number;
        totalHeapSizeExecutable: number;
        totalPhysicalSize: number;
        totalAvailableSize: number;
        totalGlobalHandlesSize: number;
        usedGlobalHandlesSize: number;
        usedHeapSize: number;
        heapSizeLimit: number;
        mallocedMemory: number;
        externalMemory: number;
        peakMallocedMemory: number;
    }
    interface HeapSpaceStatistics {
        spaceName: string;
        spaceSize: number;
        spaceUsedSize: number;
        spaceAvailableSize: number;
        physicalSpaceSize: number;
    }
    
    interface Init {
        (promise: Promise<unknown>, parent: Promise<unknown>): void;
    }
    
    interface Before {
        (promise: Promise<unknown>): void;
    }
    
    interface After {
        (promise: Promise<unknown>): void;
    }
    
    interface Settled {
        (promise: Promise<unknown>): void;
    }
    
    interface HookCallbacks {
        init?: Init;
        before?: Before;
        after?: After;
        settled?: Settled;
    }
    interface PromiseHooks {
        
        onInit: (init: Init) => Function;
        
        onSettled: (settled: Settled) => Function;
        
        onBefore: (before: Before) => Function;
        
        onAfter: (after: After) => Function;
        
        createHook: (callbacks: HookCallbacks) => Function;
    }
    
    const promiseHooks: PromiseHooks;
    type StartupSnapshotCallbackFn = (args: any) => any;
    
    namespace startupSnapshot {
        
        function addSerializeCallback(callback: StartupSnapshotCallbackFn, data?: any): void;
        
        function addDeserializeCallback(callback: StartupSnapshotCallbackFn, data?: any): void;
        
        function setDeserializeMainFunction(callback: StartupSnapshotCallbackFn, data?: any): void;
        
        function isBuildingSnapshot(): boolean;
    }
}
declare module "node:v8" {
    export * from "v8";
}
