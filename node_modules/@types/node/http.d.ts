
declare module "http" {
    import * as stream from "node:stream";
    import { URL } from "node:url";
    import { LookupOptions } from "node:dns";
    import { EventEmitter } from "node:events";
    import { LookupFunction, Server as NetServer, Socket, TcpSocketConnectOpts } from "node:net";
    
    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {
        accept?: string | undefined;
        "accept-encoding"?: string | undefined;
        "accept-language"?: string | undefined;
        "accept-patch"?: string | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        "alt-svc"?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        connection?: string | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        location?: string | undefined;
        origin?: string | undefined;
        pragma?: string | undefined;
        "proxy-authenticate"?: string | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-fetch-site"?: string | undefined;
        "sec-fetch-mode"?: string | undefined;
        "sec-fetch-user"?: string | undefined;
        "sec-fetch-dest"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | undefined;
        "sec-websocket-version"?: string | undefined;
        "set-cookie"?: string[] | undefined;
        "strict-transport-security"?: string | undefined;
        tk?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        upgrade?: string | undefined;
        "user-agent"?: string | undefined;
        vary?: string | undefined;
        via?: string | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | undefined;
    }
    
    type OutgoingHttpHeader = number | string | string[];
    interface OutgoingHttpHeaders extends NodeJS.Dict<OutgoingHttpHeader> {
        accept?: string | string[] | undefined;
        "accept-charset"?: string | string[] | undefined;
        "accept-encoding"?: string | string[] | undefined;
        "accept-language"?: string | string[] | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        "cdn-cache-control"?: string | undefined;
        connection?: string | string[] | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | number | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-security-policy"?: string | undefined;
        "content-security-policy-report-only"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | string[] | undefined;
        dav?: string | string[] | undefined;
        dnt?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-range"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        link?: string | string[] | undefined;
        location?: string | undefined;
        "max-forwards"?: string | undefined;
        origin?: string | undefined;
        pragma?: string | string[] | undefined;
        "proxy-authenticate"?: string | string[] | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        "public-key-pins-report-only"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "referrer-policy"?: string | undefined;
        refresh?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | string[] | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | string[] | undefined;
        "sec-websocket-version"?: string | undefined;
        server?: string | undefined;
        "set-cookie"?: string | string[] | undefined;
        "strict-transport-security"?: string | undefined;
        te?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        "user-agent"?: string | undefined;
        upgrade?: string | undefined;
        "upgrade-insecure-requests"?: string | undefined;
        vary?: string | undefined;
        via?: string | string[] | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | string[] | undefined;
        "x-content-type-options"?: string | undefined;
        "x-dns-prefetch-control"?: string | undefined;
        "x-frame-options"?: string | undefined;
        "x-xss-protection"?: string | undefined;
    }
    interface ClientRequestArgs extends Pick<LookupOptions, "hints"> {
        _defaultAgent?: Agent | undefined;
        agent?: Agent | boolean | undefined;
        auth?: string | null | undefined;
        createConnection?:
            | ((
                options: ClientRequestArgs,
                oncreate: (err: Error | null, socket: stream.Duplex) => void,
            ) => stream.Duplex | null | undefined)
            | undefined;
        defaultPort?: number | string | undefined;
        family?: number | undefined;
        headers?: OutgoingHttpHeaders | readonly string[] | undefined;
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        insecureHTTPParser?: boolean | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        lookup?: LookupFunction | undefined;
        
        maxHeaderSize?: number | undefined;
        method?: string | undefined;
        path?: string | null | undefined;
        port?: number | string | null | undefined;
        protocol?: string | null | undefined;
        setDefaultHeaders?: boolean | undefined;
        setHost?: boolean | undefined;
        signal?: AbortSignal | undefined;
        socketPath?: string | undefined;
        timeout?: number | undefined;
        uniqueHeaders?: Array<string | string[]> | undefined;
        joinDuplicateHeaders?: boolean | undefined;
    }
    interface ServerOptions<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > {
        
        IncomingMessage?: Request | undefined;
        
        ServerResponse?: Response | undefined;
        
        requestTimeout?: number | undefined;
        
        joinDuplicateHeaders?: boolean | undefined;
        
        keepAliveTimeout?: number | undefined;
        
        keepAliveTimeoutBuffer?: number | undefined;
        
        connectionsCheckingInterval?: number | undefined;
        
        headersTimeout?: number | undefined;
        
        highWaterMark?: number | undefined;
        
        insecureHTTPParser?: boolean | undefined;
        
        maxHeaderSize?: number | undefined;
        
        noDelay?: boolean | undefined;
        
        requireHostHeader?: boolean | undefined;
        
        keepAlive?: boolean | undefined;
        
        keepAliveInitialDelay?: number | undefined;
        
        uniqueHeaders?: Array<string | string[]> | undefined;
        
        rejectNonStandardBodyWrites?: boolean | undefined;
    }
    type RequestListener<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > = (req: InstanceType<Request>, res: InstanceType<Response> & { req: InstanceType<Request> }) => void;
    
    class Server<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > extends NetServer {
        constructor(requestListener?: RequestListener<Request, Response>);
        constructor(options: ServerOptions<Request, Response>, requestListener?: RequestListener<Request, Response>);
        
        setTimeout(msecs?: number, callback?: (socket: Socket) => void): this;
        setTimeout(callback: (socket: Socket) => void): this;
        
        maxHeadersCount: number | null;
        
        maxRequestsPerSocket: number | null;
        
        timeout: number;
        
        headersTimeout: number;
        
        keepAliveTimeout: number;
        
        keepAliveTimeoutBuffer: number;
        
        requestTimeout: number;
        
        closeAllConnections(): void;
        
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        addListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        addListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        addListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        addListener(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        addListener(event: "request", listener: RequestListener<Request, Response>): this;
        addListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(
            event: "checkContinue",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: "checkExpectation",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "clientError", err: Error, socket: stream.Duplex): boolean;
        emit(event: "connect", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        emit(event: "dropRequest", req: InstanceType<Request>, socket: stream.Duplex): boolean;
        emit(
            event: "request",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "upgrade", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        on(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        on(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        on(event: "connect", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        on(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        on(event: "request", listener: RequestListener<Request, Response>): this;
        on(event: "upgrade", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        once(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        once(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        once(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        once(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        once(event: "request", listener: RequestListener<Request, Response>): this;
        once(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependOnceListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependOnceListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
    }
    
    class OutgoingMessage<Request extends IncomingMessage = IncomingMessage> extends stream.Writable {
        readonly req: Request;
        chunkedEncoding: boolean;
        shouldKeepAlive: boolean;
        useChunkedEncodingByDefault: boolean;
        sendDate: boolean;
        
        finished: boolean;
        
        readonly headersSent: boolean;
        
        readonly connection: Socket | null;
        
        readonly socket: Socket | null;
        constructor();
        
        setTimeout(msecs: number, callback?: () => void): this;
        
        setHeader(name: string, value: number | string | readonly string[]): this;
        
        setHeaders(headers: Headers | Map<string, number | string | readonly string[]>): this;
        
        appendHeader(name: string, value: string | readonly string[]): this;
        
        getHeader(name: string): number | string | string[] | undefined;
        
        getHeaders(): OutgoingHttpHeaders;
        
        getHeaderNames(): string[];
        
        hasHeader(name: string): boolean;
        
        removeHeader(name: string): void;
        
        addTrailers(headers: OutgoingHttpHeaders | ReadonlyArray<[string, string]>): void;
        
        flushHeaders(): void;
    }
    
    class ServerResponse<Request extends IncomingMessage = IncomingMessage> extends OutgoingMessage<Request> {
        
        statusCode: number;
        
        statusMessage: string;
        
        strictContentLength: boolean;
        constructor(req: Request);
        assignSocket(socket: Socket): void;
        detachSocket(socket: Socket): void;
        
        writeContinue(callback?: () => void): void;
        
        writeEarlyHints(hints: Record<string, string | string[]>, callback?: () => void): void;
        
        writeHead(
            statusCode: number,
            statusMessage?: string,
            headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],
        ): this;
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): this;
        
        writeProcessing(callback?: () => void): void;
    }
    interface InformationEvent {
        statusCode: number;
        statusMessage: string;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        headers: IncomingHttpHeaders;
        rawHeaders: string[];
    }
    
    class ClientRequest extends OutgoingMessage {
        
        aborted: boolean;
        
        host: string;
        
        protocol: string;
        
        reusedSocket: boolean;
        
        maxHeadersCount: number;
        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);
        
        method: string;
        
        path: string;
        
        abort(): void;
        onSocket(socket: Socket): void;
        
        setTimeout(timeout: number, callback?: () => void): this;
        
        setNoDelay(noDelay?: boolean): void;
        
        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;
        
        getRawHeaderNames(): string[];
        
        addListener(event: "abort", listener: () => void): this;
        addListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "continue", listener: () => void): this;
        addListener(event: "information", listener: (info: InformationEvent) => void): this;
        addListener(event: "response", listener: (response: IncomingMessage) => void): this;
        addListener(event: "socket", listener: (socket: Socket) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        
        on(event: "abort", listener: () => void): this;
        on(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "continue", listener: () => void): this;
        on(event: "information", listener: (info: InformationEvent) => void): this;
        on(event: "response", listener: (response: IncomingMessage) => void): this;
        on(event: "socket", listener: (socket: Socket) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        
        once(event: "abort", listener: () => void): this;
        once(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "continue", listener: () => void): this;
        once(event: "information", listener: (info: InformationEvent) => void): this;
        once(event: "response", listener: (response: IncomingMessage) => void): this;
        once(event: "socket", listener: (socket: Socket) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        
        prependListener(event: "abort", listener: () => void): this;
        prependListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "continue", listener: () => void): this;
        prependListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependListener(event: "socket", listener: (socket: Socket) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        
        prependOnceListener(event: "abort", listener: () => void): this;
        prependOnceListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "continue", listener: () => void): this;
        prependOnceListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependOnceListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependOnceListener(event: "socket", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    
    class IncomingMessage extends stream.Readable {
        constructor(socket: Socket);
        
        aborted: boolean;
        
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        
        complete: boolean;
        
        connection: Socket;
        
        socket: Socket;
        
        headers: IncomingHttpHeaders;
        
        headersDistinct: NodeJS.Dict<string[]>;
        
        rawHeaders: string[];
        
        trailers: NodeJS.Dict<string>;
        
        trailersDistinct: NodeJS.Dict<string[]>;
        
        rawTrailers: string[];
        
        setTimeout(msecs: number, callback?: () => void): this;
        
        method?: string | undefined;
        
        url?: string | undefined;
        
        statusCode?: number | undefined;
        
        statusMessage?: string | undefined;
        
        destroy(error?: Error): this;
    }
    interface ProxyEnv extends NodeJS.ProcessEnv {
        HTTP_PROXY?: string | undefined;
        HTTPS_PROXY?: string | undefined;
        NO_PROXY?: string | undefined;
        http_proxy?: string | undefined;
        https_proxy?: string | undefined;
        no_proxy?: string | undefined;
    }
    interface AgentOptions extends NodeJS.PartialOptions<TcpSocketConnectOpts> {
        
        keepAlive?: boolean | undefined;
        
        keepAliveMsecs?: number | undefined;
        
        agentKeepAliveTimeoutBuffer?: number | undefined;
        
        maxSockets?: number | undefined;
        
        maxTotalSockets?: number | undefined;
        
        maxFreeSockets?: number | undefined;
        
        timeout?: number | undefined;
        
        scheduling?: "fifo" | "lifo" | undefined;
        
        proxyEnv?: ProxyEnv | undefined;
        
        defaultPort?: number | undefined;
        
        protocol?: string | undefined;
    }
    
    class Agent extends EventEmitter {
        
        maxFreeSockets: number;
        
        maxSockets: number;
        
        maxTotalSockets: number;
        
        readonly freeSockets: NodeJS.ReadOnlyDict<Socket[]>;
        
        readonly sockets: NodeJS.ReadOnlyDict<Socket[]>;
        
        readonly requests: NodeJS.ReadOnlyDict<IncomingMessage[]>;
        constructor(opts?: AgentOptions);
        
        destroy(): void;
        
        createConnection(
            options: ClientRequestArgs,
            callback?: (err: Error | null, stream: stream.Duplex) => void,
        ): stream.Duplex | null | undefined;
        
        keepSocketAlive(socket: stream.Duplex): void;
        
        reuseSocket(socket: stream.Duplex, request: ClientRequest): void;
        
        getName(options?: ClientRequestArgs): string;
    }
    const METHODS: string[];
    const STATUS_CODES: {
        [errorCode: number]: string | undefined;
        [errorCode: string]: string | undefined;
    };
    
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    >(requestListener?: RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: RequestListener<Request, Response>,
    ): Server<Request, Response>;
    
    
    interface RequestOptions extends ClientRequestArgs {}
    
    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: IncomingMessage) => void,
    ): ClientRequest;
    
    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;
    
    function validateHeaderName(name: string): void;
    
    function validateHeaderValue(name: string, value: string): void;
    
    function setMaxIdleHTTPParsers(max: number): void;
    
    let globalAgent: Agent;
    
    const maxHeaderSize: number;
    
    const WebSocket: typeof import("undici-types").WebSocket;
    
    const CloseEvent: typeof import("undici-types").CloseEvent;
    
    const MessageEvent: typeof import("undici-types").MessageEvent;
}
declare module "node:http" {
    export * from "http";
}
