
declare module "worker_threads" {
    import { Context } from "node:vm";
    import { EventEmitter, NodeEventTarget } from "node:events";
    import { EventLoopUtilityFunction } from "node:perf_hooks";
    import { FileHandle } from "node:fs/promises";
    import { Readable, Writable } from "node:stream";
    import { ReadableStream, TransformStream, WritableStream } from "node:stream/web";
    import { URL } from "node:url";
    import { CPUProfileHandle, HeapInfo } from "node:v8";
    import { MessageEvent } from "undici-types";
    const isInternalThread: boolean;
    const isMainThread: boolean;
    const parentPort: null | MessagePort;
    const resourceLimits: ResourceLimits;
    const SHARE_ENV: unique symbol;
    const threadId: number;
    const threadName: string | null;
    const workerData: any;
    
    class MessageChannel {
        readonly port1: MessagePort;
        readonly port2: MessagePort;
    }
    interface WorkerPerformance {
        eventLoopUtilization: EventLoopUtilityFunction;
    }
    type Transferable =
        | ArrayBuffer
        | MessagePort
        | AbortSignal
        | FileHandle
        | ReadableStream
        | WritableStream
        | TransformStream;
    
    
    type TransferListItem = Transferable;
    
    class MessagePort implements EventTarget {
        
        close(): void;
        
        postMessage(value: any, transferList?: readonly Transferable[]): void;
        
        hasRef(): boolean;
        
        ref(): void;
        
        unref(): void;
        
        start(): void;
        addListener(event: "close", listener: (ev: Event) => void): this;
        addListener(event: "message", listener: (value: any) => void): this;
        addListener(event: "messageerror", listener: (error: Error) => void): this;
        addListener(event: string, listener: (arg: any) => void): this;
        emit(event: "close", ev: Event): boolean;
        emit(event: "message", value: any): boolean;
        emit(event: "messageerror", error: Error): boolean;
        emit(event: string, arg: any): boolean;
        off(event: "close", listener: (ev: Event) => void, options?: EventListenerOptions): this;
        off(event: "message", listener: (value: any) => void, options?: EventListenerOptions): this;
        off(event: "messageerror", listener: (error: Error) => void, options?: EventListenerOptions): this;
        off(event: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
        on(event: "close", listener: (ev: Event) => void): this;
        on(event: "message", listener: (value: any) => void): this;
        on(event: "messageerror", listener: (error: Error) => void): this;
        on(event: string, listener: (arg: any) => void): this;
        once(event: "close", listener: (ev: Event) => void): this;
        once(event: "message", listener: (value: any) => void): this;
        once(event: "messageerror", listener: (error: Error) => void): this;
        once(event: string, listener: (arg: any) => void): this;
        removeListener(event: "close", listener: (ev: Event) => void, options?: EventListenerOptions): this;
        removeListener(event: "message", listener: (value: any) => void, options?: EventListenerOptions): this;
        removeListener(event: "messageerror", listener: (error: Error) => void, options?: EventListenerOptions): this;
        removeListener(event: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
    }
    interface MessagePort extends NodeEventTarget {}
    interface WorkerOptions {
        
        argv?: any[] | undefined;
        env?: NodeJS.Dict<string> | typeof SHARE_ENV | undefined;
        eval?: boolean | undefined;
        workerData?: any;
        stdin?: boolean | undefined;
        stdout?: boolean | undefined;
        stderr?: boolean | undefined;
        execArgv?: string[] | undefined;
        resourceLimits?: ResourceLimits | undefined;
        
        transferList?: Transferable[] | undefined;
        
        trackUnmanagedFds?: boolean | undefined;
        
        name?: string | undefined;
    }
    interface ResourceLimits {
        
        maxYoungGenerationSizeMb?: number | undefined;
        
        maxOldGenerationSizeMb?: number | undefined;
        
        codeRangeSizeMb?: number | undefined;
        
        stackSizeMb?: number | undefined;
    }
    
    class Worker extends EventEmitter {
        
        readonly stdin: Writable | null;
        
        readonly stdout: Readable;
        
        readonly stderr: Readable;
        
        readonly threadId: number;
        
        readonly threadName: string | null;
        
        readonly resourceLimits?: ResourceLimits | undefined;
        
        readonly performance: WorkerPerformance;
        
        constructor(filename: string | URL, options?: WorkerOptions);
        
        postMessage(value: any, transferList?: readonly Transferable[]): void;
        
        ref(): void;
        
        unref(): void;
        
        terminate(): Promise<number>;
        
        cpuUsage(prev?: NodeJS.CpuUsage): Promise<NodeJS.CpuUsage>;
        
        getHeapSnapshot(): Promise<Readable>;
        
        getHeapStatistics(): Promise<HeapInfo>;
        
        startCpuProfile(): Promise<CPUProfileHandle>;
        
        [Symbol.asyncDispose](): Promise<void>;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "exit", listener: (exitCode: number) => void): this;
        addListener(event: "message", listener: (value: any) => void): this;
        addListener(event: "messageerror", listener: (error: Error) => void): this;
        addListener(event: "online", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "error", err: Error): boolean;
        emit(event: "exit", exitCode: number): boolean;
        emit(event: "message", value: any): boolean;
        emit(event: "messageerror", error: Error): boolean;
        emit(event: "online"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "exit", listener: (exitCode: number) => void): this;
        on(event: "message", listener: (value: any) => void): this;
        on(event: "messageerror", listener: (error: Error) => void): this;
        on(event: "online", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "exit", listener: (exitCode: number) => void): this;
        once(event: "message", listener: (value: any) => void): this;
        once(event: "messageerror", listener: (error: Error) => void): this;
        once(event: "online", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "exit", listener: (exitCode: number) => void): this;
        prependListener(event: "message", listener: (value: any) => void): this;
        prependListener(event: "messageerror", listener: (error: Error) => void): this;
        prependListener(event: "online", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "exit", listener: (exitCode: number) => void): this;
        prependOnceListener(event: "message", listener: (value: any) => void): this;
        prependOnceListener(event: "messageerror", listener: (error: Error) => void): this;
        prependOnceListener(event: "online", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
        removeListener(event: "error", listener: (err: Error) => void): this;
        removeListener(event: "exit", listener: (exitCode: number) => void): this;
        removeListener(event: "message", listener: (value: any) => void): this;
        removeListener(event: "messageerror", listener: (error: Error) => void): this;
        removeListener(event: "online", listener: () => void): this;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
        off(event: "error", listener: (err: Error) => void): this;
        off(event: "exit", listener: (exitCode: number) => void): this;
        off(event: "message", listener: (value: any) => void): this;
        off(event: "messageerror", listener: (error: Error) => void): this;
        off(event: "online", listener: () => void): this;
        off(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    interface BroadcastChannel extends NodeJS.RefCounted {}
    
    class BroadcastChannel extends EventTarget {
        readonly name: string;
        
        onmessage: (message: MessageEvent) => void;
        
        onmessageerror: (message: MessageEvent) => void;
        constructor(name: string);
        
        close(): void;
        
        postMessage(message: unknown): void;
    }
    interface Lock {
        readonly mode: LockMode;
        readonly name: string;
    }
    interface LockGrantedCallback<T> {
        (lock: Lock | null): T;
    }
    interface LockInfo {
        clientId: string;
        mode: LockMode;
        name: string;
    }
    interface LockManager {
        query(): Promise<LockManagerSnapshot>;
        request<T>(name: string, callback: LockGrantedCallback<T>): Promise<Awaited<T>>;
        request<T>(name: string, options: LockOptions, callback: LockGrantedCallback<T>): Promise<Awaited<T>>;
    }
    interface LockManagerSnapshot {
        held: LockInfo[];
        pending: LockInfo[];
    }
    type LockMode = "exclusive" | "shared";
    interface LockOptions {
        ifAvailable?: boolean;
        mode?: LockMode;
        signal?: AbortSignal;
        steal?: boolean;
    }
    var locks: LockManager;
    
    function markAsUntransferable(object: object): void;
    
    function isMarkedAsUntransferable(object: object): boolean;
    
    function markAsUncloneable(object: object): void;
    
    function moveMessagePortToContext(port: MessagePort, contextifiedSandbox: Context): MessagePort;
    
    function receiveMessageOnPort(port: MessagePort):
        | {
            message: any;
        }
        | undefined;
    type Serializable = string | object | number | boolean | bigint;
    
    function getEnvironmentData(key: Serializable): Serializable;
    
    function setEnvironmentData(key: Serializable, value?: Serializable): void;
    
    function postMessageToThread(threadId: number, value: any, timeout?: number): Promise<void>;
    function postMessageToThread(
        threadId: number,
        value: any,
        transferList: readonly Transferable[],
        timeout?: number,
    ): Promise<void>;

    import {
        BroadcastChannel as _BroadcastChannel,
        MessageChannel as _MessageChannel,
        MessagePort as _MessagePort,
    } from "worker_threads";
    global {
        function structuredClone<T>(
            value: T,
            options?: { transfer?: Transferable[] },
        ): T;
        
        var BroadcastChannel: typeof globalThis extends {
            onmessage: any;
            BroadcastChannel: infer T;
        } ? T
            : typeof _BroadcastChannel;
        
        var MessageChannel: typeof globalThis extends {
            onmessage: any;
            MessageChannel: infer T;
        } ? T
            : typeof _MessageChannel;
        
        var MessagePort: typeof globalThis extends {
            onmessage: any;
            MessagePort: infer T;
        } ? T
            : typeof _MessagePort;
    }
}
declare module "node:worker_threads" {
    export * from "worker_threads";
}
