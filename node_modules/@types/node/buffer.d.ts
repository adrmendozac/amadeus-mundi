

type _Blob = typeof globalThis extends { onmessage: any; Blob: any } ? {} : import("buffer").Blob;
type _File = typeof globalThis extends { onmessage: any; File: any } ? {} : import("buffer").File;


declare module "buffer" {
    import { BinaryLike } from "node:crypto";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    
    export function isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    
    export function isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    export let INSPECT_MAX_BYTES: number;
    export const kMaxLength: number;
    export const kStringMaxLength: number;
    export const constants: {
        MAX_LENGTH: number;
        MAX_STRING_LENGTH: number;
    };
    export type TranscodeEncoding =
        | "ascii"
        | "utf8"
        | "utf-8"
        | "utf16le"
        | "utf-16le"
        | "ucs2"
        | "ucs-2"
        | "latin1"
        | "binary";
    
    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;
    
    export function resolveObjectURL(id: string): Blob | undefined;
    export { type AllowSharedBuffer, Buffer, type NonSharedBuffer };
    
    export interface BlobOptions {
        
        endings?: "transparent" | "native";
        
        type?: string | undefined;
    }
    
    export class Blob {
        
        readonly size: number;
        
        readonly type: string;
        
        constructor(sources: Array<ArrayBuffer | BinaryLike | Blob>, options?: BlobOptions);
        
        arrayBuffer(): Promise<ArrayBuffer>;
        
        bytes(): Promise<Uint8Array>;
        
        slice(start?: number, end?: number, type?: string): Blob;
        
        text(): Promise<string>;
        
        stream(): WebReadableStream;
    }
    export interface FileOptions {
        
        endings?: "native" | "transparent";
        
        type?: string;
        
        lastModified?: number;
    }
    
    export class File extends Blob {
        constructor(sources: Array<BinaryLike | Blob>, fileName: string, options?: FileOptions);
        
        readonly name: string;
        
        readonly lastModified: number;
    }
    export import atob = globalThis.atob;
    export import btoa = globalThis.btoa;
    export type WithImplicitCoercion<T> =
        | T
        | { valueOf(): T }
        | (T extends string ? { [Symbol.toPrimitive](hint: "string"): T } : never);
    global {
        namespace NodeJS {
            export { BufferEncoding };
        }
        
        type BufferEncoding =
            | "ascii"
            | "utf8"
            | "utf-8"
            | "utf16le"
            | "utf-16le"
            | "ucs2"
            | "ucs-2"
            | "base64"
            | "base64url"
            | "latin1"
            | "binary"
            | "hex";
        
        interface BufferConstructor {
            
            

            
            isBuffer(obj: any): obj is Buffer;
            
            isEncoding(encoding: string): encoding is BufferEncoding;
            
            byteLength(
                string: string | Buffer | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
                encoding?: BufferEncoding,
            ): number;
            
            compare(buf1: Uint8Array, buf2: Uint8Array): -1 | 0 | 1;
            
            poolSize: number;
        }
        interface Buffer {
            
            

            
            write(string: string, encoding?: BufferEncoding): number;
            write(string: string, offset: number, encoding?: BufferEncoding): number;
            write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
            
            toString(encoding?: BufferEncoding, start?: number, end?: number): string;
            
            toJSON(): {
                type: "Buffer";
                data: number[];
            };
            
            equals(otherBuffer: Uint8Array): boolean;
            
            compare(
                target: Uint8Array,
                targetStart?: number,
                targetEnd?: number,
                sourceStart?: number,
                sourceEnd?: number,
            ): -1 | 0 | 1;
            
            copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
            
            writeBigInt64BE(value: bigint, offset?: number): number;
            
            writeBigInt64LE(value: bigint, offset?: number): number;
            
            writeBigUInt64BE(value: bigint, offset?: number): number;
            
            writeBigUint64BE(value: bigint, offset?: number): number;
            
            writeBigUInt64LE(value: bigint, offset?: number): number;
            
            writeBigUint64LE(value: bigint, offset?: number): number;
            
            writeUIntLE(value: number, offset: number, byteLength: number): number;
            
            writeUintLE(value: number, offset: number, byteLength: number): number;
            
            writeUIntBE(value: number, offset: number, byteLength: number): number;
            
            writeUintBE(value: number, offset: number, byteLength: number): number;
            
            writeIntLE(value: number, offset: number, byteLength: number): number;
            
            writeIntBE(value: number, offset: number, byteLength: number): number;
            
            readBigUInt64BE(offset?: number): bigint;
            
            readBigUint64BE(offset?: number): bigint;
            
            readBigUInt64LE(offset?: number): bigint;
            
            readBigUint64LE(offset?: number): bigint;
            
            readBigInt64BE(offset?: number): bigint;
            
            readBigInt64LE(offset?: number): bigint;
            
            readUIntLE(offset: number, byteLength: number): number;
            
            readUintLE(offset: number, byteLength: number): number;
            
            readUIntBE(offset: number, byteLength: number): number;
            
            readUintBE(offset: number, byteLength: number): number;
            
            readIntLE(offset: number, byteLength: number): number;
            
            readIntBE(offset: number, byteLength: number): number;
            
            readUInt8(offset?: number): number;
            
            readUint8(offset?: number): number;
            
            readUInt16LE(offset?: number): number;
            
            readUint16LE(offset?: number): number;
            
            readUInt16BE(offset?: number): number;
            
            readUint16BE(offset?: number): number;
            
            readUInt32LE(offset?: number): number;
            
            readUint32LE(offset?: number): number;
            
            readUInt32BE(offset?: number): number;
            
            readUint32BE(offset?: number): number;
            
            readInt8(offset?: number): number;
            
            readInt16LE(offset?: number): number;
            
            readInt16BE(offset?: number): number;
            
            readInt32LE(offset?: number): number;
            
            readInt32BE(offset?: number): number;
            
            readFloatLE(offset?: number): number;
            
            readFloatBE(offset?: number): number;
            
            readDoubleLE(offset?: number): number;
            
            readDoubleBE(offset?: number): number;
            reverse(): this;
            
            swap16(): this;
            
            swap32(): this;
            
            swap64(): this;
            
            writeUInt8(value: number, offset?: number): number;
            
            writeUint8(value: number, offset?: number): number;
            
            writeUInt16LE(value: number, offset?: number): number;
            
            writeUint16LE(value: number, offset?: number): number;
            
            writeUInt16BE(value: number, offset?: number): number;
            
            writeUint16BE(value: number, offset?: number): number;
            
            writeUInt32LE(value: number, offset?: number): number;
            
            writeUint32LE(value: number, offset?: number): number;
            
            writeUInt32BE(value: number, offset?: number): number;
            
            writeUint32BE(value: number, offset?: number): number;
            
            writeInt8(value: number, offset?: number): number;
            
            writeInt16LE(value: number, offset?: number): number;
            
            writeInt16BE(value: number, offset?: number): number;
            
            writeInt32LE(value: number, offset?: number): number;
            
            writeInt32BE(value: number, offset?: number): number;
            
            writeFloatLE(value: number, offset?: number): number;
            
            writeFloatBE(value: number, offset?: number): number;
            
            writeDoubleLE(value: number, offset?: number): number;
            
            writeDoubleBE(value: number, offset?: number): number;
            
            fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;
            fill(value: string | Uint8Array | number, offset: number, encoding: BufferEncoding): this;
            fill(value: string | Uint8Array | number, encoding: BufferEncoding): this;
            
            indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            indexOf(value: string | number | Uint8Array, encoding: BufferEncoding): number;
            
            lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            lastIndexOf(value: string | number | Uint8Array, encoding: BufferEncoding): number;
            
            includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
            includes(value: string | number | Buffer, encoding: BufferEncoding): boolean;
        }
        var Buffer: BufferConstructor;
        
        function atob(data: string): string;
        
        function btoa(data: string): string;
        interface Blob extends _Blob {}
        
        var Blob: typeof globalThis extends { onmessage: any; Blob: infer T } ? T
            : typeof import("buffer").Blob;
        interface File extends _File {}
        
        var File: typeof globalThis extends { onmessage: any; File: infer T } ? T
            : typeof import("buffer").File;
    }
}
declare module "node:buffer" {
    export * from "buffer";
}
