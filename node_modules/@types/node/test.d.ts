
declare module "node:test" {
    import { AssertMethodNames } from "node:assert";
    import { Readable } from "node:stream";
    import TestFn = test.TestFn;
    import TestOptions = test.TestOptions;
    
    function test(name?: string, fn?: TestFn): Promise<void>;
    function test(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(options?: TestOptions, fn?: TestFn): Promise<void>;
    function test(fn?: TestFn): Promise<void>;
    namespace test {
        export { test };
        export { suite as describe, test as it };
    }
    namespace test {
        
        function run(options?: RunOptions): TestsStream;
        
        function suite(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function suite(name?: string, fn?: SuiteFn): Promise<void>;
        function suite(options?: TestOptions, fn?: SuiteFn): Promise<void>;
        function suite(fn?: SuiteFn): Promise<void>;
        namespace suite {
            
            function skip(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function skip(name?: string, fn?: SuiteFn): Promise<void>;
            function skip(options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function skip(fn?: SuiteFn): Promise<void>;
            
            function todo(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function todo(name?: string, fn?: SuiteFn): Promise<void>;
            function todo(options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function todo(fn?: SuiteFn): Promise<void>;
            
            function only(name?: string, options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function only(name?: string, fn?: SuiteFn): Promise<void>;
            function only(options?: TestOptions, fn?: SuiteFn): Promise<void>;
            function only(fn?: SuiteFn): Promise<void>;
        }
        
        function skip(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(name?: string, fn?: TestFn): Promise<void>;
        function skip(options?: TestOptions, fn?: TestFn): Promise<void>;
        function skip(fn?: TestFn): Promise<void>;
        
        function todo(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(name?: string, fn?: TestFn): Promise<void>;
        function todo(options?: TestOptions, fn?: TestFn): Promise<void>;
        function todo(fn?: TestFn): Promise<void>;
        
        function only(name?: string, options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(name?: string, fn?: TestFn): Promise<void>;
        function only(options?: TestOptions, fn?: TestFn): Promise<void>;
        function only(fn?: TestFn): Promise<void>;
        
        type TestFn = (t: TestContext, done: (result?: any) => void) => void | Promise<void>;
        
        type SuiteFn = (s: SuiteContext) => void | Promise<void>;
        interface TestShard {
            
            index: number;
            
            total: number;
        }
        interface RunOptions {
            
            concurrency?: number | boolean | undefined;
            
            cwd?: string | undefined;
            
            files?: readonly string[] | undefined;
            
            forceExit?: boolean | undefined;
            
            globPatterns?: readonly string[] | undefined;
            
            inspectPort?: number | (() => number) | undefined;
            
            isolation?: "process" | "none" | undefined;
            
            only?: boolean | undefined;
            
            setup?: ((reporter: TestsStream) => void | Promise<void>) | undefined;
            
            execArgv?: readonly string[] | undefined;
            
            argv?: readonly string[] | undefined;
            
            signal?: AbortSignal | undefined;
            
            testNamePatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
            
            testSkipPatterns?: string | RegExp | ReadonlyArray<string | RegExp> | undefined;
            
            timeout?: number | undefined;
            
            watch?: boolean | undefined;
            
            shard?: TestShard | undefined;
            
            rerunFailuresFilePath?: string | undefined;
            
            coverage?: boolean | undefined;
            
            coverageExcludeGlobs?: string | readonly string[] | undefined;
            
            coverageIncludeGlobs?: string | readonly string[] | undefined;
            
            lineCoverage?: number | undefined;
            
            branchCoverage?: number | undefined;
            
            functionCoverage?: number | undefined;
        }
        
        interface TestsStream extends Readable {
            addListener(event: "test:coverage", listener: (data: EventData.TestCoverage) => void): this;
            addListener(event: "test:complete", listener: (data: EventData.TestComplete) => void): this;
            addListener(event: "test:dequeue", listener: (data: EventData.TestDequeue) => void): this;
            addListener(event: "test:diagnostic", listener: (data: EventData.TestDiagnostic) => void): this;
            addListener(event: "test:enqueue", listener: (data: EventData.TestEnqueue) => void): this;
            addListener(event: "test:fail", listener: (data: EventData.TestFail) => void): this;
            addListener(event: "test:pass", listener: (data: EventData.TestPass) => void): this;
            addListener(event: "test:plan", listener: (data: EventData.TestPlan) => void): this;
            addListener(event: "test:start", listener: (data: EventData.TestStart) => void): this;
            addListener(event: "test:stderr", listener: (data: EventData.TestStderr) => void): this;
            addListener(event: "test:stdout", listener: (data: EventData.TestStdout) => void): this;
            addListener(event: "test:summary", listener: (data: EventData.TestSummary) => void): this;
            addListener(event: "test:watch:drained", listener: () => void): this;
            addListener(event: "test:watch:restarted", listener: () => void): this;
            addListener(event: string, listener: (...args: any[]) => void): this;
            emit(event: "test:coverage", data: EventData.TestCoverage): boolean;
            emit(event: "test:complete", data: EventData.TestComplete): boolean;
            emit(event: "test:dequeue", data: EventData.TestDequeue): boolean;
            emit(event: "test:diagnostic", data: EventData.TestDiagnostic): boolean;
            emit(event: "test:enqueue", data: EventData.TestEnqueue): boolean;
            emit(event: "test:fail", data: EventData.TestFail): boolean;
            emit(event: "test:pass", data: EventData.TestPass): boolean;
            emit(event: "test:plan", data: EventData.TestPlan): boolean;
            emit(event: "test:start", data: EventData.TestStart): boolean;
            emit(event: "test:stderr", data: EventData.TestStderr): boolean;
            emit(event: "test:stdout", data: EventData.TestStdout): boolean;
            emit(event: "test:summary", data: EventData.TestSummary): boolean;
            emit(event: "test:watch:drained"): boolean;
            emit(event: "test:watch:restarted"): boolean;
            emit(event: string | symbol, ...args: any[]): boolean;
            on(event: "test:coverage", listener: (data: EventData.TestCoverage) => void): this;
            on(event: "test:complete", listener: (data: EventData.TestComplete) => void): this;
            on(event: "test:dequeue", listener: (data: EventData.TestDequeue) => void): this;
            on(event: "test:diagnostic", listener: (data: EventData.TestDiagnostic) => void): this;
            on(event: "test:enqueue", listener: (data: EventData.TestEnqueue) => void): this;
            on(event: "test:fail", listener: (data: EventData.TestFail) => void): this;
            on(event: "test:pass", listener: (data: EventData.TestPass) => void): this;
            on(event: "test:plan", listener: (data: EventData.TestPlan) => void): this;
            on(event: "test:start", listener: (data: EventData.TestStart) => void): this;
            on(event: "test:stderr", listener: (data: EventData.TestStderr) => void): this;
            on(event: "test:stdout", listener: (data: EventData.TestStdout) => void): this;
            on(event: "test:summary", listener: (data: EventData.TestSummary) => void): this;
            on(event: "test:watch:drained", listener: () => void): this;
            on(event: "test:watch:restarted", listener: () => void): this;
            on(event: string, listener: (...args: any[]) => void): this;
            once(event: "test:coverage", listener: (data: EventData.TestCoverage) => void): this;
            once(event: "test:complete", listener: (data: EventData.TestComplete) => void): this;
            once(event: "test:dequeue", listener: (data: EventData.TestDequeue) => void): this;
            once(event: "test:diagnostic", listener: (data: EventData.TestDiagnostic) => void): this;
            once(event: "test:enqueue", listener: (data: EventData.TestEnqueue) => void): this;
            once(event: "test:fail", listener: (data: EventData.TestFail) => void): this;
            once(event: "test:pass", listener: (data: EventData.TestPass) => void): this;
            once(event: "test:plan", listener: (data: EventData.TestPlan) => void): this;
            once(event: "test:start", listener: (data: EventData.TestStart) => void): this;
            once(event: "test:stderr", listener: (data: EventData.TestStderr) => void): this;
            once(event: "test:stdout", listener: (data: EventData.TestStdout) => void): this;
            once(event: "test:summary", listener: (data: EventData.TestSummary) => void): this;
            once(event: "test:watch:drained", listener: () => void): this;
            once(event: "test:watch:restarted", listener: () => void): this;
            once(event: string, listener: (...args: any[]) => void): this;
            prependListener(event: "test:coverage", listener: (data: EventData.TestCoverage) => void): this;
            prependListener(event: "test:complete", listener: (data: EventData.TestComplete) => void): this;
            prependListener(event: "test:dequeue", listener: (data: EventData.TestDequeue) => void): this;
            prependListener(event: "test:diagnostic", listener: (data: EventData.TestDiagnostic) => void): this;
            prependListener(event: "test:enqueue", listener: (data: EventData.TestEnqueue) => void): this;
            prependListener(event: "test:fail", listener: (data: EventData.TestFail) => void): this;
            prependListener(event: "test:pass", listener: (data: EventData.TestPass) => void): this;
            prependListener(event: "test:plan", listener: (data: EventData.TestPlan) => void): this;
            prependListener(event: "test:start", listener: (data: EventData.TestStart) => void): this;
            prependListener(event: "test:stderr", listener: (data: EventData.TestStderr) => void): this;
            prependListener(event: "test:stdout", listener: (data: EventData.TestStdout) => void): this;
            prependListener(event: "test:summary", listener: (data: EventData.TestSummary) => void): this;
            prependListener(event: "test:watch:drained", listener: () => void): this;
            prependListener(event: "test:watch:restarted", listener: () => void): this;
            prependListener(event: string, listener: (...args: any[]) => void): this;
            prependOnceListener(event: "test:coverage", listener: (data: EventData.TestCoverage) => void): this;
            prependOnceListener(event: "test:complete", listener: (data: EventData.TestComplete) => void): this;
            prependOnceListener(event: "test:dequeue", listener: (data: EventData.TestDequeue) => void): this;
            prependOnceListener(event: "test:diagnostic", listener: (data: EventData.TestDiagnostic) => void): this;
            prependOnceListener(event: "test:enqueue", listener: (data: EventData.TestEnqueue) => void): this;
            prependOnceListener(event: "test:fail", listener: (data: EventData.TestFail) => void): this;
            prependOnceListener(event: "test:pass", listener: (data: EventData.TestPass) => void): this;
            prependOnceListener(event: "test:plan", listener: (data: EventData.TestPlan) => void): this;
            prependOnceListener(event: "test:start", listener: (data: EventData.TestStart) => void): this;
            prependOnceListener(event: "test:stderr", listener: (data: EventData.TestStderr) => void): this;
            prependOnceListener(event: "test:stdout", listener: (data: EventData.TestStdout) => void): this;
            prependOnceListener(event: "test:summary", listener: (data: EventData.TestSummary) => void): this;
            prependOnceListener(event: "test:watch:drained", listener: () => void): this;
            prependOnceListener(event: "test:watch:restarted", listener: () => void): this;
            prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        }
        namespace EventData {
            interface Error extends globalThis.Error {
                cause: globalThis.Error;
            }
            interface LocationInfo {
                
                column?: number;
                
                file?: string;
                
                line?: number;
            }
            interface TestDiagnostic extends LocationInfo {
                
                message: string;
                
                nesting: number;
                
                level: "info" | "warn" | "error";
            }
            interface TestCoverage {
                
                summary: {
                    
                    files: Array<{
                        
                        path: string;
                        
                        totalLineCount: number;
                        
                        totalBranchCount: number;
                        
                        totalFunctionCount: number;
                        
                        coveredLineCount: number;
                        
                        coveredBranchCount: number;
                        
                        coveredFunctionCount: number;
                        
                        coveredLinePercent: number;
                        
                        coveredBranchPercent: number;
                        
                        coveredFunctionPercent: number;
                        
                        functions: Array<{
                            
                            name: string;
                            
                            line: number;
                            
                            count: number;
                        }>;
                        
                        branches: Array<{
                            
                            line: number;
                            
                            count: number;
                        }>;
                        
                        lines: Array<{
                            
                            line: number;
                            
                            count: number;
                        }>;
                    }>;
                    
                    thresholds: {
                        
                        function: number;
                        
                        branch: number;
                        
                        line: number;
                    };
                    
                    totals: {
                        
                        totalLineCount: number;
                        
                        totalBranchCount: number;
                        
                        totalFunctionCount: number;
                        
                        coveredLineCount: number;
                        
                        coveredBranchCount: number;
                        
                        coveredFunctionCount: number;
                        
                        coveredLinePercent: number;
                        
                        coveredBranchPercent: number;
                        
                        coveredFunctionPercent: number;
                    };
                    
                    workingDirectory: string;
                };
                
                nesting: number;
            }
            interface TestComplete extends LocationInfo {
                
                details: {
                    
                    passed: boolean;
                    
                    duration_ms: number;
                    
                    error?: Error;
                    
                    type?: "suite" | "test";
                };
                
                name: string;
                
                nesting: number;
                
                testNumber: number;
                
                todo?: string | boolean;
                
                skip?: string | boolean;
            }
            interface TestDequeue extends LocationInfo {
                
                name: string;
                
                nesting: number;
                
                type: "suite" | "test";
            }
            interface TestEnqueue extends LocationInfo {
                
                name: string;
                
                nesting: number;
                
                type: "suite" | "test";
            }
            interface TestFail extends LocationInfo {
                
                details: {
                    
                    duration_ms: number;
                    
                    error: Error;
                    
                    type?: "suite" | "test";
                    
                    attempt?: number;
                };
                
                name: string;
                
                nesting: number;
                
                testNumber: number;
                
                todo?: string | boolean;
                
                skip?: string | boolean;
            }
            interface TestPass extends LocationInfo {
                
                details: {
                    
                    duration_ms: number;
                    
                    type?: "suite" | "test";
                    
                    attempt?: number;
                    
                    passed_on_attempt?: number;
                };
                
                name: string;
                
                nesting: number;
                
                testNumber: number;
                
                todo?: string | boolean;
                
                skip?: string | boolean;
            }
            interface TestPlan extends LocationInfo {
                
                nesting: number;
                
                count: number;
            }
            interface TestStart extends LocationInfo {
                
                name: string;
                
                nesting: number;
            }
            interface TestStderr {
                
                file: string;
                
                message: string;
            }
            interface TestStdout {
                
                file: string;
                
                message: string;
            }
            interface TestSummary {
                
                counts: {
                    
                    cancelled: number;
                    
                    passed: number;
                    
                    skipped: number;
                    
                    suites: number;
                    
                    tests: number;
                    
                    todo: number;
                    
                    topLevel: number;
                };
                
                duration_ms: number;
                
                file: string | undefined;
                
                success: boolean;
            }
        }
        
        interface TestContext {
            
            readonly assert: TestContextAssert;
            readonly attempt: number;
            
            before(fn?: TestContextHookFn, options?: HookOptions): void;
            
            beforeEach(fn?: TestContextHookFn, options?: HookOptions): void;
            
            after(fn?: TestContextHookFn, options?: HookOptions): void;
            
            afterEach(fn?: TestContextHookFn, options?: HookOptions): void;
            
            diagnostic(message: string): void;
            
            readonly filePath: string | undefined;
            
            readonly fullName: string;
            
            readonly name: string;
            
            plan(count: number, options?: TestContextPlanOptions): void;
            
            runOnly(shouldRunOnlyTests: boolean): void;
            
            readonly signal: AbortSignal;
            
            skip(message?: string): void;
            
            todo(message?: string): void;
            
            test: typeof test;
            
            waitFor<T>(condition: () => T, options?: TestContextWaitForOptions): Promise<Awaited<T>>;
            
            readonly mock: MockTracker;
        }
        interface TestContextAssert extends Pick<typeof import("assert"), AssertMethodNames> {
            
            fileSnapshot(value: any, path: string, options?: AssertSnapshotOptions): void;
            
            snapshot(value: any, options?: AssertSnapshotOptions): void;
            
            [name: string]: (...args: any[]) => void;
        }
        interface AssertSnapshotOptions {
            
            serializers?: ReadonlyArray<(value: any) => any> | undefined;
        }
        interface TestContextPlanOptions {
            
            wait?: boolean | number | undefined;
        }
        interface TestContextWaitForOptions {
            
            interval?: number | undefined;
            
            timeout?: number | undefined;
        }
        
        interface SuiteContext {
            
            readonly filePath: string | undefined;
            
            readonly name: string;
            
            readonly signal: AbortSignal;
        }
        interface TestOptions {
            
            concurrency?: number | boolean | undefined;
            
            only?: boolean | undefined;
            
            signal?: AbortSignal | undefined;
            
            skip?: boolean | string | undefined;
            
            timeout?: number | undefined;
            
            todo?: boolean | string | undefined;
            
            plan?: number | undefined;
        }
        
        function before(fn?: HookFn, options?: HookOptions): void;
        
        function after(fn?: HookFn, options?: HookOptions): void;
        
        function beforeEach(fn?: HookFn, options?: HookOptions): void;
        
        function afterEach(fn?: HookFn, options?: HookOptions): void;
        
        type HookFn = (c: TestContext | SuiteContext, done: (result?: any) => void) => any;
        
        type TestContextHookFn = (t: TestContext, done: (result?: any) => void) => any;
        
        interface HookOptions {
            
            signal?: AbortSignal | undefined;
            
            timeout?: number | undefined;
        }
        interface MockFunctionOptions {
            
            times?: number | undefined;
        }
        interface MockMethodOptions extends MockFunctionOptions {
            
            getter?: boolean | undefined;
            
            setter?: boolean | undefined;
        }
        type Mock<F extends Function> = F & {
            mock: MockFunctionContext<F>;
        };
        interface MockModuleOptions {
            
            cache?: boolean | undefined;
            
            defaultExport?: any;
            
            namedExports?: object | undefined;
        }
        
        interface MockTracker {
            
            fn<F extends Function = (...args: any[]) => undefined>(
                original?: F,
                options?: MockFunctionOptions,
            ): Mock<F>;
            fn<F extends Function = (...args: any[]) => undefined, Implementation extends Function = F>(
                original?: F,
                implementation?: Implementation,
                options?: MockFunctionOptions,
            ): Mock<F | Implementation>;
            
            method<
                MockedObject extends object,
                MethodName extends FunctionPropertyNames<MockedObject>,
            >(
                object: MockedObject,
                methodName: MethodName,
                options?: MockFunctionOptions,
            ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName]>
                : never;
            method<
                MockedObject extends object,
                MethodName extends FunctionPropertyNames<MockedObject>,
                Implementation extends Function,
            >(
                object: MockedObject,
                methodName: MethodName,
                implementation: Implementation,
                options?: MockFunctionOptions,
            ): MockedObject[MethodName] extends Function ? Mock<MockedObject[MethodName] | Implementation>
                : never;
            method<MockedObject extends object>(
                object: MockedObject,
                methodName: keyof MockedObject,
                options: MockMethodOptions,
            ): Mock<Function>;
            method<MockedObject extends object>(
                object: MockedObject,
                methodName: keyof MockedObject,
                implementation: Function,
                options: MockMethodOptions,
            ): Mock<Function>;
            
            getter<
                MockedObject extends object,
                MethodName extends keyof MockedObject,
            >(
                object: MockedObject,
                methodName: MethodName,
                options?: MockFunctionOptions,
            ): Mock<() => MockedObject[MethodName]>;
            getter<
                MockedObject extends object,
                MethodName extends keyof MockedObject,
                Implementation extends Function,
            >(
                object: MockedObject,
                methodName: MethodName,
                implementation?: Implementation,
                options?: MockFunctionOptions,
            ): Mock<(() => MockedObject[MethodName]) | Implementation>;
            
            setter<
                MockedObject extends object,
                MethodName extends keyof MockedObject,
            >(
                object: MockedObject,
                methodName: MethodName,
                options?: MockFunctionOptions,
            ): Mock<(value: MockedObject[MethodName]) => void>;
            setter<
                MockedObject extends object,
                MethodName extends keyof MockedObject,
                Implementation extends Function,
            >(
                object: MockedObject,
                methodName: MethodName,
                implementation?: Implementation,
                options?: MockFunctionOptions,
            ): Mock<((value: MockedObject[MethodName]) => void) | Implementation>;
            
            module(specifier: string, options?: MockModuleOptions): MockModuleContext;
            
            property<
                MockedObject extends object,
                PropertyName extends keyof MockedObject,
            >(
                object: MockedObject,
                property: PropertyName,
                value?: MockedObject[PropertyName],
            ): MockedObject & { mock: MockPropertyContext<MockedObject[PropertyName]> };
            
            reset(): void;
            
            restoreAll(): void;
            readonly timers: MockTimers;
        }
        const mock: MockTracker;
        interface MockFunctionCall<
            F extends Function,
            ReturnType = F extends (...args: any) => infer T ? T
                : F extends abstract new(...args: any) => infer T ? T
                : unknown,
            Args = F extends (...args: infer Y) => any ? Y
                : F extends abstract new(...args: infer Y) => any ? Y
                : unknown[],
        > {
            
            arguments: Args;
            
            error: unknown | undefined;
            
            result: ReturnType | undefined;
            
            stack: Error;
            
            target: F extends abstract new(...args: any) => any ? F : undefined;
            
            this: unknown;
        }
        
        interface MockFunctionContext<F extends Function> {
            
            readonly calls: MockFunctionCall<F>[];
            
            callCount(): number;
            
            mockImplementation(implementation: F): void;
            
            mockImplementationOnce(implementation: F, onCall?: number): void;
            
            resetCalls(): void;
            
            restore(): void;
        }
        
        interface MockModuleContext {
            
            restore(): void;
        }
        
        class MockPropertyContext<PropertyType = any> {
            
            readonly accesses: Array<{
                type: "get" | "set";
                value: PropertyType;
                stack: Error;
            }>;
            
            accessCount(): number;
            
            mockImplementation(value: PropertyType): void;
            
            mockImplementationOnce(value: PropertyType, onAccess?: number): void;
            
            resetAccesses(): void;
            
            restore(): void;
        }
        interface MockTimersOptions {
            apis: ReadonlyArray<"setInterval" | "setTimeout" | "setImmediate" | "Date">;
            now?: number | Date | undefined;
        }
        
        interface MockTimers {
            
            enable(options?: MockTimersOptions): void;
            
            setTime(time: number): void;
            
            reset(): void;
            
            tick(milliseconds: number): void;
            
            runAll(): void;
            
            [Symbol.dispose](): void;
        }
        
        namespace assert {
            
            function register(name: string, fn: (this: TestContext, ...args: any[]) => void): void;
        }
        
        namespace snapshot {
            
            function setDefaultSnapshotSerializers(serializers: ReadonlyArray<(value: any) => any>): void;
            
            function setResolveSnapshotPath(fn: (path: string | undefined) => string): void;
        }
    }
    type FunctionPropertyNames<T> = {
        [K in keyof T]: T[K] extends Function ? K : never;
    }[keyof T];
    export = test;
}


declare module "node:test/reporters" {
    import { Transform, TransformOptions } from "node:stream";
    import { EventData } from "node:test";

    type TestEvent =
        | { type: "test:coverage"; data: EventData.TestCoverage }
        | { type: "test:complete"; data: EventData.TestComplete }
        | { type: "test:dequeue"; data: EventData.TestDequeue }
        | { type: "test:diagnostic"; data: EventData.TestDiagnostic }
        | { type: "test:enqueue"; data: EventData.TestEnqueue }
        | { type: "test:fail"; data: EventData.TestFail }
        | { type: "test:pass"; data: EventData.TestPass }
        | { type: "test:plan"; data: EventData.TestPlan }
        | { type: "test:start"; data: EventData.TestStart }
        | { type: "test:stderr"; data: EventData.TestStderr }
        | { type: "test:stdout"; data: EventData.TestStdout }
        | { type: "test:summary"; data: EventData.TestSummary }
        | { type: "test:watch:drained"; data: undefined }
        | { type: "test:watch:restarted"; data: undefined };
    type TestEventGenerator = AsyncGenerator<TestEvent, void>;

    interface ReporterConstructorWrapper<T extends new(...args: any[]) => Transform> {
        new(...args: ConstructorParameters<T>): InstanceType<T>;
        (...args: ConstructorParameters<T>): InstanceType<T>;
    }

    
    function dot(source: TestEventGenerator): AsyncGenerator<"\n" | "." | "X", void>;
    
    function tap(source: TestEventGenerator): AsyncGenerator<string, void>;
    class SpecReporter extends Transform {
        constructor();
    }
    
    const spec: ReporterConstructorWrapper<typeof SpecReporter>;
    
    function junit(source: TestEventGenerator): AsyncGenerator<string, void>;
    class LcovReporter extends Transform {
        constructor(opts?: Omit<TransformOptions, "writableObjectMode">);
    }
    
    const lcov: ReporterConstructorWrapper<typeof LcovReporter>;

    export { dot, junit, lcov, spec, tap, TestEvent };
}
