
declare module "module" {
    import { URL } from "node:url";
    class Module {
        constructor(id: string, parent?: Module);
    }
    interface Module extends NodeJS.Module {}
    namespace Module {
        export { Module };
    }
    namespace Module {
        
        const builtinModules: readonly string[];
        
        function createRequire(path: string | URL): NodeJS.Require;
        namespace constants {
            
            namespace compileCacheStatus {
                
                const ENABLED: number;
                
                const ALREADY_ENABLED: number;
                
                const FAILED: number;
                
                const DISABLED: number;
            }
        }
        interface EnableCompileCacheResult {
            
            status: number;
            
            message?: string;
            
            directory?: string;
        }
        
        function enableCompileCache(cacheDir?: string): EnableCompileCacheResult;
        
        function flushCompileCache(): void;
        
        function getCompileCacheDir(): string | undefined;
        
        function findPackageJSON(specifier: string | URL, base?: string | URL): string | undefined;
        
        function isBuiltin(moduleName: string): boolean;
        interface RegisterOptions<Data> {
            
            parentURL?: string | URL | undefined;
            
            data?: Data | undefined;
            
            transferList?: any[] | undefined;
        }
        
        
        function register<Data = any>(
            specifier: string | URL,
            parentURL?: string | URL,
            options?: RegisterOptions<Data>,
        ): void;
        function register<Data = any>(specifier: string | URL, options?: RegisterOptions<Data>): void;
        interface RegisterHooksOptions {
            
            load?: LoadHookSync | undefined;
            
            resolve?: ResolveHookSync | undefined;
        }
        interface ModuleHooks {
            
            deregister(): void;
        }
        
        function registerHooks(options: RegisterHooksOptions): ModuleHooks;
        interface StripTypeScriptTypesOptions {
            
            mode?: "strip" | "transform" | undefined;
            
            sourceMap?: boolean | undefined;
            
            sourceUrl?: string | undefined;
        }
        
        function stripTypeScriptTypes(code: string, options?: StripTypeScriptTypesOptions): string;
        
        
        function syncBuiltinESMExports(): void;
        interface ImportAttributes extends NodeJS.Dict<string> {
            type?: string | undefined;
        }
        type ImportPhase = "source" | "evaluation";
        type ModuleFormat =
            | "addon"
            | "builtin"
            | "commonjs"
            | "commonjs-typescript"
            | "json"
            | "module"
            | "module-typescript"
            | "wasm";
        type ModuleSource = string | ArrayBuffer | NodeJS.TypedArray;
        
        type InitializeHook<Data = any> = (data: Data) => void | Promise<void>;
        interface ResolveHookContext {
            
            conditions: string[];
            
            importAttributes: ImportAttributes;
            
            parentURL: string | undefined;
        }
        interface ResolveFnOutput {
            
            format?: string | null | undefined;
            
            importAttributes?: ImportAttributes | undefined;
            
            shortCircuit?: boolean | undefined;
            
            url: string;
        }
        
        type ResolveHook = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput | Promise<ResolveFnOutput>,
        ) => ResolveFnOutput | Promise<ResolveFnOutput>;
        type ResolveHookSync = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput,
        ) => ResolveFnOutput;
        interface LoadHookContext {
            
            conditions: string[];
            
            format: string | null | undefined;
            
            importAttributes: ImportAttributes;
        }
        interface LoadFnOutput {
            format: string | null | undefined;
            
            shortCircuit?: boolean | undefined;
            
            source?: ModuleSource | undefined;
        }
        
        type LoadHook = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput | Promise<LoadFnOutput>,
        ) => LoadFnOutput | Promise<LoadFnOutput>;
        type LoadHookSync = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput,
        ) => LoadFnOutput;
        interface SourceMapsSupport {
            
            enabled: boolean;
            
            nodeModules: boolean;
            
            generatedCode: boolean;
        }
        
        function getSourceMapsSupport(): SourceMapsSupport;
        
        function findSourceMap(path: string): SourceMap | undefined;
        interface SetSourceMapsSupportOptions {
            
            nodeModules?: boolean | undefined;
            
            generatedCode?: boolean | undefined;
        }
        
        function setSourceMapsSupport(enabled: boolean, options?: SetSourceMapsSupportOptions): void;
        interface SourceMapConstructorOptions {
            
            lineLengths?: readonly number[] | undefined;
        }
        interface SourceMapPayload {
            file: string;
            version: number;
            sources: string[];
            sourcesContent: string[];
            names: string[];
            mappings: string;
            sourceRoot: string;
        }
        interface SourceMapping {
            generatedLine: number;
            generatedColumn: number;
            originalSource: string;
            originalLine: number;
            originalColumn: number;
        }
        interface SourceOrigin {
            
            name: string | undefined;
            
            fileName: string;
            
            lineNumber: number;
            
            columnNumber: number;
        }
        
        class SourceMap {
            constructor(payload: SourceMapPayload, options?: SourceMapConstructorOptions);
            
            readonly payload: SourceMapPayload;
            
            findEntry(lineOffset: number, columnOffset: number): SourceMapping | {};
            
            findOrigin(lineNumber: number, columnNumber: number): SourceOrigin | {};
        }
        function runMain(main?: string): void;
        function wrap(script: string): string;
    }
    global {
        interface ImportMeta {
            
            dirname: string;
            
            filename: string;
            
            url: string;
            
            resolve(specifier: string, parent?: string | URL): string;
            
            main: boolean;
        }
        namespace NodeJS {
            interface Module {
                
                children: Module[];
                
                exports: any;
                
                filename: string;
                
                id: string;
                
                isPreloading: boolean;
                
                loaded: boolean;
                
                parent: Module | null | undefined;
                
                path: string;
                
                paths: string[];
                
                require(id: string): any;
            }
            interface Require {
                
                (id: string): any;
                
                cache: Dict<Module>;
                
                extensions: RequireExtensions;
                
                main: Module | undefined;
                
                resolve: RequireResolve;
            }
            
            interface RequireExtensions extends Dict<(module: Module, filename: string) => any> {
                ".js": (module: Module, filename: string) => any;
                ".json": (module: Module, filename: string) => any;
                ".node": (module: Module, filename: string) => any;
            }
            interface RequireResolveOptions {
                
                paths?: string[] | undefined;
            }
            interface RequireResolve {
                
                (request: string, options?: RequireResolveOptions): string;
                
                paths(request: string): string[] | null;
            }
        }
        
        var __dirname: string;
        
        var __filename: string;
        
        var exports: NodeJS.Module["exports"];
        
        var module: NodeJS.Module;
        
        var require: NodeJS.Require;
        
        
        
        interface NodeModule extends NodeJS.Module {}
        
        interface NodeRequire extends NodeJS.Require {}
        
        interface RequireResolve extends NodeJS.RequireResolve {}
    }
    export = Module;
}
declare module "node:module" {
    import module = require("module");
    export = module;
}
