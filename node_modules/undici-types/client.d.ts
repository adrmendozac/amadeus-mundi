import { URL } from 'url'
import Dispatcher from './dispatcher'
import buildConnector from './connector'
import TClientStats from './client-stats'

type ClientConnectOptions = Omit<Dispatcher.ConnectOptions, 'origin'>


export class Client extends Dispatcher {
  constructor (url: string | URL, options?: Client.Options)
  
  pipelining: number
  
  closed: boolean
  
  destroyed: boolean
  
  readonly stats: TClientStats

  
  override connect (
    options: ClientConnectOptions
  ): Promise<Dispatcher.ConnectData>
  override connect (
    options: ClientConnectOptions,
    callback: (err: Error | null, data: Dispatcher.ConnectData) => void
  ): void
}

export declare namespace Client {
  export interface OptionsInterceptors {
    Client: readonly Dispatcher.DispatchInterceptor[];
  }
  export interface Options {
    
    interceptors?: OptionsInterceptors;
    
    maxHeaderSize?: number;
    
    headersTimeout?: number;
    
    socketTimeout?: never;
    
    requestTimeout?: never;
    
    connectTimeout?: number;
    
    bodyTimeout?: number;
    
    idleTimeout?: never;
    
    keepAlive?: never;
    
    keepAliveTimeout?: number;
    
    maxKeepAliveTimeout?: never;
    
    keepAliveMaxTimeout?: number;
    
    keepAliveTimeoutThreshold?: number;
    
    socketPath?: string;
    
    tls?: never;
    
    strictContentLength?: boolean;
    
    maxCachedSessions?: number;
    
    connect?: Partial<buildConnector.BuildOptions> | buildConnector.connector;
    
    maxRequestsPerClient?: number;
    
    localAddress?: string;
    
    maxResponseSize?: number;
    
    autoSelectFamily?: boolean;
    
    autoSelectFamilyAttemptTimeout?: number;
    
    allowH2?: boolean;
    
    maxConcurrentStreams?: number;
  }
  export interface SocketInfo {
    localAddress?: string
    localPort?: number
    remoteAddress?: string
    remotePort?: number
    remoteFamily?: string
    timeout?: number
    bytesWritten?: number
    bytesRead?: number
  }
}

export default Client
