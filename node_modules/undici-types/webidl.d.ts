
import * as undici from './index'


type Converter<T> = (object: unknown) => T

type SequenceConverter<T> = (object: unknown, iterable?: IterableIterator<T>) => T[]

type RecordConverter<K extends string, V> = (object: unknown) => Record<K, V>

interface ConvertToIntOpts {
  clamp?: boolean
  enforceRange?: boolean
}

interface WebidlErrors {
  
  exception (opts: { header: string, message: string }): TypeError
  
  conversionFailed (opts: {
    prefix: string
    argument: string
    types: string[]
  }): TypeError
  
  invalidArgument (opts: {
    prefix: string
    value: string
    type: string
  }): TypeError
}

interface WebIDLTypes {
  UNDEFINED: 1,
  BOOLEAN: 2,
  STRING: 3,
  SYMBOL: 4,
  NUMBER: 5,
  BIGINT: 6,
  NULL: 7
  OBJECT: 8
}

interface WebidlUtil {
  
  Type (object: unknown): WebIDLTypes[keyof WebIDLTypes]

  TypeValueToString (o: unknown):
    | 'Undefined'
    | 'Boolean'
    | 'String'
    | 'Symbol'
    | 'Number'
    | 'BigInt'
    | 'Null'
    | 'Object'

  Types: WebIDLTypes

  
  ConvertToInt (
    V: unknown,
    bitLength: number,
    signedness: 'signed' | 'unsigned',
    opts?: ConvertToIntOpts
  ): number

  
  IntegerPart (N: number): number

  
  Stringify (V: any): string

  MakeTypeAssertion <I>(I: I): (arg: any) => arg is I

  
  markAsUncloneable (V: any): void
}

interface WebidlConverters {
  
  DOMString (V: unknown, prefix: string, argument: string, opts?: {
    legacyNullToEmptyString: boolean
  }): string

  
  ByteString (V: unknown, prefix: string, argument: string): string

  
  USVString (V: unknown): string

  
  boolean (V: unknown): boolean

  
  any <Value>(V: Value): Value

  
  ['long long'] (V: unknown): number

  
  ['unsigned long long'] (V: unknown): number

  
  ['unsigned long'] (V: unknown): number

  
  ['unsigned short'] (V: unknown, opts?: ConvertToIntOpts): number

  
  ArrayBuffer (V: unknown): ArrayBufferLike
  ArrayBuffer (V: unknown, opts: { allowShared: false }): ArrayBuffer

  
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike
  ): NodeJS.TypedArray | ArrayBufferLike
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike,
    opts?: { allowShared: false }
  ): NodeJS.TypedArray | ArrayBuffer

  
  DataView (V: unknown, opts?: { allowShared: boolean }): DataView

  
  BufferSource (
    V: unknown,
    opts?: { allowShared: boolean }
  ): NodeJS.TypedArray | ArrayBufferLike | DataView

  ['sequence<ByteString>']: SequenceConverter<string>

  ['sequence<sequence<ByteString>>']: SequenceConverter<string[]>

  ['record<ByteString, ByteString>']: RecordConverter<string, string>

  
  RequestInfo (V: unknown): undici.Request | string

  
  RequestInit (V: unknown): undici.RequestInit

  [Key: string]: (...args: any[]) => unknown
}

type WebidlIsFunction<T> = (arg: any) => arg is T

interface WebidlIs {
  Request: WebidlIsFunction<undici.Request>
  Response: WebidlIsFunction<undici.Response>
  ReadableStream: WebidlIsFunction<ReadableStream>
  Blob: WebidlIsFunction<Blob>
  URLSearchParams: WebidlIsFunction<URLSearchParams>
  File: WebidlIsFunction<File>
  FormData: WebidlIsFunction<undici.FormData>
  URL: WebidlIsFunction<URL>
  WebSocketError: WebidlIsFunction<undici.WebSocketError>
  AbortSignal: WebidlIsFunction<AbortSignal>
  MessagePort: WebidlIsFunction<MessagePort>
  USVString: WebidlIsFunction<string>
}

export interface Webidl {
  errors: WebidlErrors
  util: WebidlUtil
  converters: WebidlConverters
  is: WebidlIs

  
  brandCheck <Interface extends new () => unknown>(V: unknown, cls: Interface): asserts V is Interface

  brandCheckMultiple <Interfaces extends (new () => unknown)[]> (list: Interfaces): (V: any) => asserts V is Interfaces[number]

  
  sequenceConverter <Type>(C: Converter<Type>): SequenceConverter<Type>

  illegalConstructor (): never

  
  recordConverter <K extends string, V>(
    keyConverter: Converter<K>,
    valueConverter: Converter<V>
  ): RecordConverter<K, V>

  
  interfaceConverter <Interface>(typeCheck: WebidlIsFunction<Interface>, name: string): (
    V: unknown,
    prefix: string,
    argument: string
  ) => asserts V is Interface

  
  
  
  dictionaryConverter (converters: {
    key: string,
    defaultValue?: () => unknown,
    required?: boolean,
    converter: (...args: unknown[]) => unknown,
    allowedValues?: unknown[]
  }[]): (V: unknown) => Record<string, unknown>

  
  nullableConverter <T>(
    converter: Converter<T>
  ): (V: unknown) => ReturnType<typeof converter> | null

  argumentLengthCheck (args: { length: number }, min: number, context: string): void
}
