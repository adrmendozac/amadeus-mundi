

import { ChannelOptions, channelOptionsEqual } from './channel-options';
import { Subchannel } from './subchannel';
import {
  SubchannelAddress,
  subchannelAddressEqual,
} from './subchannel-address';
import { ChannelCredentials } from './channel-credentials';
import { GrpcUri, uriToString } from './uri-parser';
import { Http2SubchannelConnector } from './transport';



const REF_CHECK_INTERVAL = 10_000;

export class SubchannelPool {
  private pool: {
    [channelTarget: string]: Array<{
      subchannelAddress: SubchannelAddress;
      channelArguments: ChannelOptions;
      channelCredentials: ChannelCredentials;
      subchannel: Subchannel;
    }>;
  } = Object.create(null);

  
  private cleanupTimer: NodeJS.Timeout | null = null;

  
  constructor() {}

  
  unrefUnusedSubchannels(): void {
    let allSubchannelsUnrefed = true;

    
    
    for (const channelTarget in this.pool) {
      const subchannelObjArray = this.pool[channelTarget];

      const refedSubchannels = subchannelObjArray.filter(
        value => !value.subchannel.unrefIfOneRef()
      );

      if (refedSubchannels.length > 0) {
        allSubchannelsUnrefed = false;
      }

      
      this.pool[channelTarget] = refedSubchannels;
    }
    

    
    if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
  }

  
  ensureCleanupTask(): void {
    if (this.cleanupTimer === null) {
      this.cleanupTimer = setInterval(() => {
        this.unrefUnusedSubchannels();
      }, REF_CHECK_INTERVAL);

      
      
      this.cleanupTimer.unref?.();
    }
  }

  
  getOrCreateSubchannel(
    channelTargetUri: GrpcUri,
    subchannelTarget: SubchannelAddress,
    channelArguments: ChannelOptions,
    channelCredentials: ChannelCredentials
  ): Subchannel {
    this.ensureCleanupTask();
    const channelTarget = uriToString(channelTargetUri);
    if (channelTarget in this.pool) {
      const subchannelObjArray = this.pool[channelTarget];
      for (const subchannelObj of subchannelObjArray) {
        if (
          subchannelAddressEqual(
            subchannelTarget,
            subchannelObj.subchannelAddress
          ) &&
          channelOptionsEqual(
            channelArguments,
            subchannelObj.channelArguments
          ) &&
          channelCredentials._equals(subchannelObj.channelCredentials)
        ) {
          return subchannelObj.subchannel;
        }
      }
    }
    
    const subchannel = new Subchannel(
      channelTargetUri,
      subchannelTarget,
      channelArguments,
      channelCredentials,
      new Http2SubchannelConnector(channelTargetUri)
    );
    if (!(channelTarget in this.pool)) {
      this.pool[channelTarget] = [];
    }
    this.pool[channelTarget].push({
      subchannelAddress: subchannelTarget,
      channelArguments,
      channelCredentials,
      subchannel,
    });
    subchannel.ref();
    return subchannel;
  }
}

const globalSubchannelPool = new SubchannelPool();


export function getSubchannelPool(global: boolean): SubchannelPool {
  if (global) {
    return globalSubchannelPool;
  } else {
    return new SubchannelPool();
  }
}
