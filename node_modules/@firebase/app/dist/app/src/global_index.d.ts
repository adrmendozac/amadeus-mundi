


declare class Provider<T extends Name> {
    private readonly name;
    private readonly container;
    private component;
    private readonly instances;
    private readonly instancesDeferred;
    private readonly instancesOptions;
    private onInitCallbacks;
    constructor(name: T, container: ComponentContainer);
    
    get(identifier?: string): Promise<NameServiceMapping[T]>;
    
    getImmediate(options: {
        identifier?: string;
        optional: true;
    }): NameServiceMapping[T] | null;
    getImmediate(options?: {
        identifier?: string;
        optional?: false;
    }): NameServiceMapping[T];
    getComponent(): Component<T> | null;
    setComponent(component: Component<T>): void;
    clearInstance(identifier?: string): void;
    delete(): Promise<void>;
    isComponentSet(): boolean;
    isInitialized(identifier?: string): boolean;
    getOptions(identifier?: string): Record<string, unknown>;
    initialize(opts?: InitializeOptions): NameServiceMapping[T];
    
    onInit(callback: OnInitCallBack<T>, identifier?: string): () => void;
    
    private invokeOnInitCallbacks;
    private getOrInitializeService;
    private normalizeInstanceIdentifier;
    private shouldAutoInitialize;
}




declare class ComponentContainer {
    private readonly name;
    private readonly providers;
    constructor(name: string);
    
    addComponent<T extends Name>(component: Component<T>): void;
    addOrOverwriteComponent<T extends Name>(component: Component<T>): void;
    
    getProvider<T extends Name>(name: T): Provider<T>;
    getProviders(): Array<Provider<Name>>;
}



declare const enum InstantiationMode {
    LAZY = "LAZY",
    EAGER = "EAGER",
    EXPLICIT = "EXPLICIT"
}

declare const enum ComponentType {
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE",
    VERSION = "VERSION"
}
interface InstanceFactoryOptions {
    instanceIdentifier?: string;
    options?: {};
}
type InitializeOptions = InstanceFactoryOptions;

type InstanceFactory<T extends Name> = (container: ComponentContainer, options: InstanceFactoryOptions) => NameServiceMapping[T];
type onInstanceCreatedCallback<T extends Name> = (container: ComponentContainer, instanceIdentifier: string, instance: NameServiceMapping[T]) => void;
interface Dictionary {
    [key: string]: unknown;
}

interface NameServiceMapping {
}
type Name = keyof NameServiceMapping;
type OnInitCallBack<T extends Name> = (instance: NameServiceMapping[T], identifier: string) => void;




declare class Component<T extends Name = Name> {
    readonly name: T;
    readonly instanceFactory: InstanceFactory<T>;
    readonly type: ComponentType;
    multipleInstances: boolean;
    
    serviceProps: Dictionary;
    instantiationMode: InstantiationMode;
    onInstanceCreated: onInstanceCreatedCallback<T> | null;
    
    constructor(name: T, instanceFactory: InstanceFactory<T>, type: ComponentType);
    setInstantiationMode(mode: InstantiationMode): this;
    setMultipleInstances(multipleInstances: boolean): this;
    setServiceProps(props: Dictionary): this;
    setInstanceCreatedCallback(callback: onInstanceCreatedCallback<T>): this;
}


interface VersionService {
    library: string;
    version: string;
}
interface PlatformLoggerService {
    getPlatformInfoString(): string;
}
interface HeartbeatService {
    
    triggerHeartbeat(): Promise<void>;
    
    getHeartbeatsHeader(): Promise<string>;
}




interface FirebaseApp {
    
    readonly name: string;
    
    readonly options: FirebaseOptions;
    
    automaticDataCollectionEnabled: boolean;
}

interface FirebaseServerApp extends FirebaseApp {
    
    name: string;
    
    readonly settings: FirebaseServerAppSettings;
}

interface FirebaseOptions {
    
    apiKey?: string;
    
    authDomain?: string;
    
    databaseURL?: string;
    
    projectId?: string;
    
    storageBucket?: string;
    
    messagingSenderId?: string;
    
    appId?: string;
    
    measurementId?: string;
}

interface FirebaseAppSettings {
    
    name?: string;
    
    automaticDataCollectionEnabled?: boolean;
}

interface FirebaseServerAppSettings extends Omit<FirebaseAppSettings, 'name'> {
    
    authIdToken?: string;
    
    appCheckToken?: string;
    
    releaseOnDeref?: object;
}

interface _FirebaseService {
    app: FirebaseApp;
    
    _delete(): Promise<void>;
}

interface _FirebaseAppInternal extends FirebaseApp {
    container: ComponentContainer;
    isDeleted: boolean;
    checkDestroyed(): void;
}
declare module '@firebase/component' {
    interface NameServiceMapping {
        'app': FirebaseApp;
        'app-version': VersionService;
        'heartbeat': HeartbeatService;
        'platform-logger': PlatformLoggerService;
    }
}


type LogLevelString = 'debug' | 'verbose' | 'info' | 'warn' | 'error' | 'silent';
interface LogOptions {
    level: LogLevelString;
}
type LogCallback = (callbackParams: LogCallbackParams) => void;
interface LogCallbackParams {
    level: LogLevelString;
    message: string;
    args: unknown[];
    type: string;
}


interface FirebaseDefaults {
    config?: Record<string, string>;
    emulatorHosts?: Record<string, string>;
    _authTokenSyncURL?: string;
    _authIdTokenMaxAge?: number;
    
    forceEnvironment?: 'browser' | 'node';
    [key: string]: unknown;
}
declare global {
    var __FIREBASE_DEFAULTS__: FirebaseDefaults | undefined;
}

declare class FirebaseError extends Error {
    
    readonly code: string;
    
    customData?: Record<string, unknown> | undefined;
    
    readonly name: string;
    constructor(
    
    code: string, message: string, 
    
    customData?: Record<string, unknown> | undefined);
}




declare const SDK_VERSION: string;

declare function initializeApp(options: FirebaseOptions, name?: string): FirebaseApp;

declare function initializeApp(options: FirebaseOptions, config?: FirebaseAppSettings): FirebaseApp;

declare function initializeApp(): FirebaseApp;

declare function initializeServerApp(options: FirebaseOptions | FirebaseApp, config?: FirebaseServerAppSettings): FirebaseServerApp;

declare function initializeServerApp(config?: FirebaseServerAppSettings): FirebaseServerApp;

declare function getApp(name?: string): FirebaseApp;

declare function getApps(): FirebaseApp[];

declare function deleteApp(app: FirebaseApp): Promise<void>;

declare function registerVersion(libraryKeyOrName: string, version: string, variant?: string): void;

declare function onLog(logCallback: LogCallback | null, options?: LogOptions): void;

declare function setLogLevel(logLevel: LogLevelString): void;



declare const DEFAULT_ENTRY_NAME = "[DEFAULT]";




declare const _apps: Map<string, FirebaseApp>;

declare const _serverApps: Map<string, FirebaseServerApp>;

declare const _components: Map<string, Component<any>>;

declare function _addComponent<T extends Name>(app: FirebaseApp, component: Component<T>): void;

declare function _addOrOverwriteComponent(app: FirebaseApp, component: Component): void;

declare function _registerComponent<T extends Name>(component: Component<T>): boolean;

declare function _getProvider<T extends Name>(app: FirebaseApp, name: T): Provider<T>;

declare function _removeServiceInstance<T extends Name>(app: FirebaseApp, name: T, instanceIdentifier?: string): void;

declare function _isFirebaseApp(obj: FirebaseApp | FirebaseOptions | FirebaseAppSettings): obj is FirebaseApp;

declare function _isFirebaseServerAppSettings(obj: FirebaseApp | FirebaseOptions | FirebaseAppSettings): obj is FirebaseServerAppSettings;

declare function _isFirebaseServerApp(obj: FirebaseApp | FirebaseServerApp | null | undefined): obj is FirebaseServerApp;

declare function _clearComponents(): void;

export { FirebaseApp, FirebaseAppSettings, FirebaseError, FirebaseOptions, FirebaseServerApp, FirebaseServerAppSettings, SDK_VERSION, DEFAULT_ENTRY_NAME as _DEFAULT_ENTRY_NAME, _FirebaseAppInternal, _FirebaseService, _addComponent, _addOrOverwriteComponent, _apps, _clearComponents, _components, _getProvider, _isFirebaseApp, _isFirebaseServerApp, _isFirebaseServerAppSettings, _registerComponent, _removeServiceInstance, _serverApps, deleteApp, getApp, getApps, initializeApp, initializeServerApp, onLog, registerVersion, setLogLevel };
