
import { FirebaseApp } from '@firebase/app';
import { CompleteFn, ErrorFn, FirebaseError, NextFn, Observer, Unsubscribe } from '@firebase/util';
import { FactorId as FactorIdMap, OperationType as OperationTypeMap, ActionCodeOperation as ActionCodeOperationMap } from './enum_maps';
export { CompleteFn, ErrorFn, NextFn, Unsubscribe };

export interface Config {
    
    apiKey: string;
    
    apiHost: string;
    
    apiScheme: string;
    
    tokenApiHost: string;
    
    sdkClientVersion: string;
    
    authDomain?: string;
}

export interface RecaptchaParameters {
    [key: string]: any;
}

export interface ParsedToken {
    
    'exp'?: string;
    
    'sub'?: string;
    
    'auth_time'?: string;
    
    'iat'?: string;
    
    'firebase'?: {
        'sign_in_provider'?: string;
        'sign_in_second_factor'?: string;
        'identities'?: Record<string, string>;
    };
    
    [key: string]: unknown;
}

export type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;

export interface AuthError extends FirebaseError {
    
    readonly customData: {
        
        readonly appName: string;
        
        readonly email?: string;
        
        readonly phoneNumber?: string;
        
        readonly tenantId?: string;
    };
}

export interface AuthSettings {
    
    appVerificationDisabledForTesting: boolean;
}

export interface Auth {
    
    readonly app: FirebaseApp;
    
    readonly name: string;
    
    readonly config: Config;
    
    setPersistence(persistence: Persistence): Promise<void>;
    
    languageCode: string | null;
    
    tenantId: string | null;
    
    readonly settings: AuthSettings;
    
    onAuthStateChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    beforeAuthStateChanged(callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;
    
    onIdTokenChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    authStateReady(): Promise<void>;
    
    readonly currentUser: User | null;
    
    readonly emulatorConfig: EmulatorConfig | null;
    
    updateCurrentUser(user: User | null): Promise<void>;
    
    useDeviceLanguage(): void;
    
    signOut(): Promise<void>;
}

export interface Persistence {
    
    readonly type: 'SESSION' | 'LOCAL' | 'NONE' | 'COOKIE';
}

export interface IdTokenResult {
    
    authTime: string;
    
    expirationTime: string;
    
    issuedAtTime: string;
    
    signInProvider: string | null;
    
    signInSecondFactor: string | null;
    
    token: string;
    
    claims: ParsedToken;
}

export interface ActionCodeInfo {
    
    data: {
        email?: string | null;
        multiFactorInfo?: MultiFactorInfo | null;
        previousEmail?: string | null;
    };
    
    operation: (typeof ActionCodeOperationMap)[keyof typeof ActionCodeOperationMap];
}

export declare const enum ActionCodeOperation {
    
    EMAIL_SIGNIN = "EMAIL_SIGNIN",
    
    PASSWORD_RESET = "PASSWORD_RESET",
    
    RECOVER_EMAIL = "RECOVER_EMAIL",
    
    REVERT_SECOND_FACTOR_ADDITION = "REVERT_SECOND_FACTOR_ADDITION",
    
    VERIFY_AND_CHANGE_EMAIL = "VERIFY_AND_CHANGE_EMAIL",
    
    VERIFY_EMAIL = "VERIFY_EMAIL"
}

export interface ActionCodeSettings {
    
    android?: {
        installApp?: boolean;
        minimumVersion?: string;
        packageName: string;
    };
    
    handleCodeInApp?: boolean;
    
    iOS?: {
        bundleId: string;
    };
    
    url: string;
    
    dynamicLinkDomain?: string;
    
    linkDomain?: string;
}

export interface ApplicationVerifier {
    
    readonly type: string;
    
    verify(): Promise<string>;
}

export interface AuthProvider {
    
    readonly providerId: string;
}

export declare const enum FactorId {
    
    PHONE = "phone",
    TOTP = "totp"
}

export interface ConfirmationResult {
    
    readonly verificationId: string;
    
    confirm(verificationCode: string): Promise<UserCredential>;
}

export interface MultiFactorAssertion {
    
    readonly factorId: (typeof FactorIdMap)[keyof typeof FactorIdMap];
}

export interface MultiFactorError extends AuthError {
    
    readonly customData: AuthError['customData'] & {
        
        readonly operationType: (typeof OperationTypeMap)[keyof typeof OperationTypeMap];
    };
}

export interface MultiFactorInfo {
    
    readonly uid: string;
    
    readonly displayName?: string | null;
    
    readonly enrollmentTime: string;
    
    readonly factorId: (typeof FactorIdMap)[keyof typeof FactorIdMap];
}

export interface PhoneMultiFactorInfo extends MultiFactorInfo {
    
    readonly phoneNumber: string;
}

export interface TotpMultiFactorInfo extends MultiFactorInfo {
}

export interface MultiFactorResolver {
    
    readonly hints: MultiFactorInfo[];
    
    readonly session: MultiFactorSession;
    
    resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;
}

export interface MultiFactorSession {
}

export interface MultiFactorUser {
    
    readonly enrolledFactors: MultiFactorInfo[];
    
    getSession(): Promise<MultiFactorSession>;
    
    enroll(assertion: MultiFactorAssertion, displayName?: string | null): Promise<void>;
    
    unenroll(option: MultiFactorInfo | string): Promise<void>;
}

export interface PhoneMultiFactorAssertion extends MultiFactorAssertion {
}

export type PhoneInfoOptions = PhoneSingleFactorInfoOptions | PhoneMultiFactorEnrollInfoOptions | PhoneMultiFactorSignInInfoOptions;

export interface PhoneSingleFactorInfoOptions {
    
    phoneNumber: string;
}

export interface PhoneMultiFactorEnrollInfoOptions {
    
    phoneNumber: string;
    
    session: MultiFactorSession;
}

export interface PhoneMultiFactorSignInInfoOptions {
    
    multiFactorHint?: MultiFactorInfo;
    
    multiFactorUid?: string;
    
    session: MultiFactorSession;
}

export interface ReactNativeAsyncStorage {
    
    setItem(key: string, value: string): Promise<void>;
    
    getItem(key: string): Promise<string | null>;
    
    removeItem(key: string): Promise<void>;
}

export interface User extends UserInfo {
    
    readonly emailVerified: boolean;
    
    readonly isAnonymous: boolean;
    
    readonly metadata: UserMetadata;
    
    readonly providerData: UserInfo[];
    
    readonly refreshToken: string;
    
    readonly tenantId: string | null;
    
    delete(): Promise<void>;
    
    getIdToken(forceRefresh?: boolean): Promise<string>;
    
    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
    
    reload(): Promise<void>;
    
    toJSON(): object;
}

export interface UserCredential {
    
    user: User;
    
    providerId: string | null;
    
    operationType: (typeof OperationTypeMap)[keyof typeof OperationTypeMap];
}

export interface UserInfo {
    
    readonly displayName: string | null;
    
    readonly email: string | null;
    
    readonly phoneNumber: string | null;
    
    readonly photoURL: string | null;
    
    readonly providerId: string;
    
    readonly uid: string;
}

export interface UserMetadata {
    
    readonly creationTime?: string;
    
    readonly lastSignInTime?: string;
}

export interface AdditionalUserInfo {
    
    readonly isNewUser: boolean;
    
    readonly profile: Record<string, unknown> | null;
    
    readonly providerId: string | null;
    
    readonly username?: string | null;
}

export type UserProfile = Record<string, unknown>;

export interface PopupRedirectResolver {
}
declare module '@firebase/component' {
    interface NameServiceMapping {
        'auth': Auth;
    }
}

export interface EmulatorConfig {
    
    readonly protocol: string;
    
    readonly host: string;
    
    readonly port: number | null;
    
    readonly options: {
        
        readonly disableWarnings: boolean;
    };
}

export interface AuthErrorMap {
}

export interface Dependencies {
    
    persistence?: Persistence | Persistence[];
    
    popupRedirectResolver?: PopupRedirectResolver;
    
    errorMap?: AuthErrorMap;
}

export interface TotpMultiFactorAssertion extends MultiFactorAssertion {
}

export interface PasswordPolicy {
    
    readonly customStrengthOptions: {
        
        readonly minPasswordLength?: number;
        
        readonly maxPasswordLength?: number;
        
        readonly containsLowercaseLetter?: boolean;
        
        readonly containsUppercaseLetter?: boolean;
        
        readonly containsNumericCharacter?: boolean;
        
        readonly containsNonAlphanumericCharacter?: boolean;
    };
    
    readonly allowedNonAlphanumericCharacters: string;
    
    readonly enforcementState: string;
    
    readonly forceUpgradeOnSignin: boolean;
}

export interface PasswordValidationStatus {
    
    readonly isValid: boolean;
    
    readonly meetsMinPasswordLength?: boolean;
    
    readonly meetsMaxPasswordLength?: boolean;
    
    readonly containsLowercaseLetter?: boolean;
    
    readonly containsUppercaseLetter?: boolean;
    
    readonly containsNumericCharacter?: boolean;
    
    readonly containsNonAlphanumericCharacter?: boolean;
    
    readonly passwordPolicy: PasswordPolicy;
}
