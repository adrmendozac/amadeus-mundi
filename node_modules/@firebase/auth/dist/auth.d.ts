

import { CompleteFn } from '@firebase/util';
import { ErrorFactory } from '@firebase/util';
import { ErrorFn } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseError } from '@firebase/util';
import { NextFn } from '@firebase/util';
import { Observer } from '@firebase/util';
import { Unsubscribe } from '@firebase/util';


export declare interface ActionCodeInfo {
    
    data: {
        email?: string | null;
        multiFactorInfo?: MultiFactorInfo | null;
        previousEmail?: string | null;
    };
    
    operation: (typeof ActionCodeOperation)[keyof typeof ActionCodeOperation];
}


export declare const ActionCodeOperation: {
    
    readonly EMAIL_SIGNIN: "EMAIL_SIGNIN";
    
    readonly PASSWORD_RESET: "PASSWORD_RESET";
    
    readonly RECOVER_EMAIL: "RECOVER_EMAIL";
    
    readonly REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION";
    
    readonly VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL";
    
    readonly VERIFY_EMAIL: "VERIFY_EMAIL";
};


export declare interface ActionCodeSettings {
    
    android?: {
        installApp?: boolean;
        minimumVersion?: string;
        packageName: string;
    };
    
    handleCodeInApp?: boolean;
    
    iOS?: {
        bundleId: string;
    };
    
    url: string;
    
    dynamicLinkDomain?: string;
    
    linkDomain?: string;
}



export declare class ActionCodeURL {
    
    readonly apiKey: string;
    
    readonly code: string;
    
    readonly continueUrl: string | null;
    
    readonly languageCode: string | null;
    
    readonly operation: string;
    
    readonly tenantId: string | null;
    
    constructor(actionLink: string);
    
    static parseLink(link: string): ActionCodeURL | null;
}


export declare interface AdditionalUserInfo {
    
    readonly isNewUser: boolean;
    
    readonly profile: Record<string, unknown> | null;
    
    readonly providerId: string | null;
    
    readonly username?: string | null;
}

declare interface APIUserInfo {
    localId?: string;
    displayName?: string;
    photoUrl?: string;
    email?: string;
    emailVerified?: boolean;
    phoneNumber?: string;
    lastLoginAt?: number;
    createdAt?: number;
    tenantId?: string;
    passwordHash?: string;
    providerUserInfo?: ProviderUserInfo[];
    mfaInfo?: MfaEnrollment[];
}


export declare interface ApplicationVerifier {
    
    readonly type: string;
    
    verify(): Promise<string>;
}

declare interface ApplicationVerifierInternal extends ApplicationVerifier {
    
    _reset(): void;
}


export declare function applyActionCode(auth: Auth, oobCode: string): Promise<void>;

declare type AppName = string;


export declare interface Auth {
    
    readonly app: FirebaseApp;
    
    readonly name: string;
    
    readonly config: Config;
    
    setPersistence(persistence: Persistence): Promise<void>;
    
    languageCode: string | null;
    
    tenantId: string | null;
    
    readonly settings: AuthSettings;
    
    onAuthStateChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    beforeAuthStateChanged(callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;
    
    onIdTokenChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    authStateReady(): Promise<void>;
    
    readonly currentUser: User | null;
    
    readonly emulatorConfig: EmulatorConfig | null;
    
    updateCurrentUser(user: User | null): Promise<void>;
    
    useDeviceLanguage(): void;
    
    signOut(): Promise<void>;
}


export declare class AuthCredential {
    
    readonly providerId: string;
    
    readonly signInMethod: string;
    
    protected constructor(
    
    providerId: string, 
    
    signInMethod: string);
    
    toJSON(): object;
    
    _getIdTokenResponse(_auth: AuthInternal): Promise<PhoneOrOauthTokenResponse>;
    
    _linkToIdToken(_auth: AuthInternal, _idToken: string): Promise<IdTokenResponse>;
    
    _getReauthenticationResolver(_auth: AuthInternal): Promise<IdTokenResponse>;
}


export declare interface AuthError extends FirebaseError {
    
    readonly customData: {
        
        readonly appName: string;
        
        readonly email?: string;
        
        readonly phoneNumber?: string;
        
        readonly tenantId?: string;
    };
}


declare const enum AuthErrorCode {
    ADMIN_ONLY_OPERATION = "admin-restricted-operation",
    ARGUMENT_ERROR = "argument-error",
    APP_NOT_AUTHORIZED = "app-not-authorized",
    APP_NOT_INSTALLED = "app-not-installed",
    CAPTCHA_CHECK_FAILED = "captcha-check-failed",
    CODE_EXPIRED = "code-expired",
    CORDOVA_NOT_READY = "cordova-not-ready",
    CORS_UNSUPPORTED = "cors-unsupported",
    CREDENTIAL_ALREADY_IN_USE = "credential-already-in-use",
    CREDENTIAL_MISMATCH = "custom-token-mismatch",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN = "requires-recent-login",
    DEPENDENT_SDK_INIT_BEFORE_AUTH = "dependent-sdk-initialized-before-auth",
    DYNAMIC_LINK_NOT_ACTIVATED = "dynamic-link-not-activated",
    EMAIL_CHANGE_NEEDS_VERIFICATION = "email-change-needs-verification",
    EMAIL_EXISTS = "email-already-in-use",
    EMULATOR_CONFIG_FAILED = "emulator-config-failed",
    EXPIRED_OOB_CODE = "expired-action-code",
    EXPIRED_POPUP_REQUEST = "cancelled-popup-request",
    INTERNAL_ERROR = "internal-error",
    INVALID_API_KEY = "invalid-api-key",
    INVALID_APP_CREDENTIAL = "invalid-app-credential",
    INVALID_APP_ID = "invalid-app-id",
    INVALID_AUTH = "invalid-user-token",
    INVALID_AUTH_EVENT = "invalid-auth-event",
    INVALID_CERT_HASH = "invalid-cert-hash",
    INVALID_CODE = "invalid-verification-code",
    INVALID_CONTINUE_URI = "invalid-continue-uri",
    INVALID_CORDOVA_CONFIGURATION = "invalid-cordova-configuration",
    INVALID_CUSTOM_TOKEN = "invalid-custom-token",
    INVALID_DYNAMIC_LINK_DOMAIN = "invalid-dynamic-link-domain",
    INVALID_EMAIL = "invalid-email",
    INVALID_EMULATOR_SCHEME = "invalid-emulator-scheme",
    INVALID_CREDENTIAL = "invalid-credential",
    INVALID_MESSAGE_PAYLOAD = "invalid-message-payload",
    INVALID_MFA_SESSION = "invalid-multi-factor-session",
    INVALID_OAUTH_CLIENT_ID = "invalid-oauth-client-id",
    INVALID_OAUTH_PROVIDER = "invalid-oauth-provider",
    INVALID_OOB_CODE = "invalid-action-code",
    INVALID_ORIGIN = "unauthorized-domain",
    INVALID_PASSWORD = "wrong-password",
    INVALID_PERSISTENCE = "invalid-persistence-type",
    INVALID_PHONE_NUMBER = "invalid-phone-number",
    INVALID_PROVIDER_ID = "invalid-provider-id",
    INVALID_RECIPIENT_EMAIL = "invalid-recipient-email",
    INVALID_SENDER = "invalid-sender",
    INVALID_SESSION_INFO = "invalid-verification-id",
    INVALID_TENANT_ID = "invalid-tenant-id",
    LOGIN_BLOCKED = "login-blocked",
    MFA_INFO_NOT_FOUND = "multi-factor-info-not-found",
    MFA_REQUIRED = "multi-factor-auth-required",
    MISSING_ANDROID_PACKAGE_NAME = "missing-android-pkg-name",
    MISSING_APP_CREDENTIAL = "missing-app-credential",
    MISSING_AUTH_DOMAIN = "auth-domain-config-required",
    MISSING_CODE = "missing-verification-code",
    MISSING_CONTINUE_URI = "missing-continue-uri",
    MISSING_IFRAME_START = "missing-iframe-start",
    MISSING_IOS_BUNDLE_ID = "missing-ios-bundle-id",
    MISSING_OR_INVALID_NONCE = "missing-or-invalid-nonce",
    MISSING_MFA_INFO = "missing-multi-factor-info",
    MISSING_MFA_SESSION = "missing-multi-factor-session",
    MISSING_PHONE_NUMBER = "missing-phone-number",
    MISSING_PASSWORD = "missing-password",
    MISSING_SESSION_INFO = "missing-verification-id",
    MODULE_DESTROYED = "app-deleted",
    NEED_CONFIRMATION = "account-exists-with-different-credential",
    NETWORK_REQUEST_FAILED = "network-request-failed",
    NULL_USER = "null-user",
    NO_AUTH_EVENT = "no-auth-event",
    NO_SUCH_PROVIDER = "no-such-provider",
    OPERATION_NOT_ALLOWED = "operation-not-allowed",
    OPERATION_NOT_SUPPORTED = "operation-not-supported-in-this-environment",
    POPUP_BLOCKED = "popup-blocked",
    POPUP_CLOSED_BY_USER = "popup-closed-by-user",
    PROVIDER_ALREADY_LINKED = "provider-already-linked",
    QUOTA_EXCEEDED = "quota-exceeded",
    REDIRECT_CANCELLED_BY_USER = "redirect-cancelled-by-user",
    REDIRECT_OPERATION_PENDING = "redirect-operation-pending",
    REJECTED_CREDENTIAL = "rejected-credential",
    SECOND_FACTOR_ALREADY_ENROLLED = "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED = "maximum-second-factor-count-exceeded",
    TENANT_ID_MISMATCH = "tenant-id-mismatch",
    TIMEOUT = "timeout",
    TOKEN_EXPIRED = "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER = "too-many-requests",
    UNAUTHORIZED_DOMAIN = "unauthorized-continue-uri",
    UNSUPPORTED_FIRST_FACTOR = "unsupported-first-factor",
    UNSUPPORTED_PERSISTENCE = "unsupported-persistence-type",
    UNSUPPORTED_TENANT_OPERATION = "unsupported-tenant-operation",
    UNVERIFIED_EMAIL = "unverified-email",
    USER_CANCELLED = "user-cancelled",
    USER_DELETED = "user-not-found",
    USER_DISABLED = "user-disabled",
    USER_MISMATCH = "user-mismatch",
    USER_SIGNED_OUT = "user-signed-out",
    WEAK_PASSWORD = "weak-password",
    WEB_STORAGE_UNSUPPORTED = "web-storage-unsupported",
    ALREADY_INITIALIZED = "already-initialized",
    RECAPTCHA_NOT_ENABLED = "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN = "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN = "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION = "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE = "missing-client-type",
    MISSING_RECAPTCHA_VERSION = "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION = "invalid-recaptcha-version",
    INVALID_REQ_TYPE = "invalid-req-type",
    UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION = "unsupported-password-policy-schema-version",
    PASSWORD_DOES_NOT_MEET_REQUIREMENTS = "password-does-not-meet-requirements",
    INVALID_HOSTING_LINK_DOMAIN = "invalid-hosting-link-domain"
}


export declare const AuthErrorCodes: {
    readonly ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation";
    readonly ARGUMENT_ERROR: "auth/argument-error";
    readonly APP_NOT_AUTHORIZED: "auth/app-not-authorized";
    readonly APP_NOT_INSTALLED: "auth/app-not-installed";
    readonly CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed";
    readonly CODE_EXPIRED: "auth/code-expired";
    readonly CORDOVA_NOT_READY: "auth/cordova-not-ready";
    readonly CORS_UNSUPPORTED: "auth/cors-unsupported";
    readonly CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use";
    readonly CREDENTIAL_MISMATCH: "auth/custom-token-mismatch";
    readonly CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login";
    readonly DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth";
    readonly DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated";
    readonly EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification";
    readonly EMAIL_EXISTS: "auth/email-already-in-use";
    readonly EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed";
    readonly EXPIRED_OOB_CODE: "auth/expired-action-code";
    readonly EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request";
    readonly INTERNAL_ERROR: "auth/internal-error";
    readonly INVALID_API_KEY: "auth/invalid-api-key";
    readonly INVALID_APP_CREDENTIAL: "auth/invalid-app-credential";
    readonly INVALID_APP_ID: "auth/invalid-app-id";
    readonly INVALID_AUTH: "auth/invalid-user-token";
    readonly INVALID_AUTH_EVENT: "auth/invalid-auth-event";
    readonly INVALID_CERT_HASH: "auth/invalid-cert-hash";
    readonly INVALID_CODE: "auth/invalid-verification-code";
    readonly INVALID_CONTINUE_URI: "auth/invalid-continue-uri";
    readonly INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration";
    readonly INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token";
    readonly INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain";
    readonly INVALID_EMAIL: "auth/invalid-email";
    readonly INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme";
    readonly INVALID_IDP_RESPONSE: "auth/invalid-credential";
    readonly INVALID_LOGIN_CREDENTIALS: "auth/invalid-credential";
    readonly INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload";
    readonly INVALID_MFA_SESSION: "auth/invalid-multi-factor-session";
    readonly INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id";
    readonly INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider";
    readonly INVALID_OOB_CODE: "auth/invalid-action-code";
    readonly INVALID_ORIGIN: "auth/unauthorized-domain";
    readonly INVALID_PASSWORD: "auth/wrong-password";
    readonly INVALID_PERSISTENCE: "auth/invalid-persistence-type";
    readonly INVALID_PHONE_NUMBER: "auth/invalid-phone-number";
    readonly INVALID_PROVIDER_ID: "auth/invalid-provider-id";
    readonly INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email";
    readonly INVALID_SENDER: "auth/invalid-sender";
    readonly INVALID_SESSION_INFO: "auth/invalid-verification-id";
    readonly INVALID_TENANT_ID: "auth/invalid-tenant-id";
    readonly MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found";
    readonly MFA_REQUIRED: "auth/multi-factor-auth-required";
    readonly MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name";
    readonly MISSING_APP_CREDENTIAL: "auth/missing-app-credential";
    readonly MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required";
    readonly MISSING_CODE: "auth/missing-verification-code";
    readonly MISSING_CONTINUE_URI: "auth/missing-continue-uri";
    readonly MISSING_IFRAME_START: "auth/missing-iframe-start";
    readonly MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id";
    readonly MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce";
    readonly MISSING_MFA_INFO: "auth/missing-multi-factor-info";
    readonly MISSING_MFA_SESSION: "auth/missing-multi-factor-session";
    readonly MISSING_PHONE_NUMBER: "auth/missing-phone-number";
    readonly MISSING_SESSION_INFO: "auth/missing-verification-id";
    readonly MODULE_DESTROYED: "auth/app-deleted";
    readonly NEED_CONFIRMATION: "auth/account-exists-with-different-credential";
    readonly NETWORK_REQUEST_FAILED: "auth/network-request-failed";
    readonly NULL_USER: "auth/null-user";
    readonly NO_AUTH_EVENT: "auth/no-auth-event";
    readonly NO_SUCH_PROVIDER: "auth/no-such-provider";
    readonly OPERATION_NOT_ALLOWED: "auth/operation-not-allowed";
    readonly OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment";
    readonly POPUP_BLOCKED: "auth/popup-blocked";
    readonly POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user";
    readonly PROVIDER_ALREADY_LINKED: "auth/provider-already-linked";
    readonly QUOTA_EXCEEDED: "auth/quota-exceeded";
    readonly REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user";
    readonly REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending";
    readonly REJECTED_CREDENTIAL: "auth/rejected-credential";
    readonly SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use";
    readonly SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded";
    readonly TENANT_ID_MISMATCH: "auth/tenant-id-mismatch";
    readonly TIMEOUT: "auth/timeout";
    readonly TOKEN_EXPIRED: "auth/user-token-expired";
    readonly TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests";
    readonly UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri";
    readonly UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor";
    readonly UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type";
    readonly UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation";
    readonly UNVERIFIED_EMAIL: "auth/unverified-email";
    readonly USER_CANCELLED: "auth/user-cancelled";
    readonly USER_DELETED: "auth/user-not-found";
    readonly USER_DISABLED: "auth/user-disabled";
    readonly USER_MISMATCH: "auth/user-mismatch";
    readonly USER_SIGNED_OUT: "auth/user-signed-out";
    readonly WEAK_PASSWORD: "auth/weak-password";
    readonly WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported";
    readonly ALREADY_INITIALIZED: "auth/already-initialized";
    readonly RECAPTCHA_NOT_ENABLED: "auth/recaptcha-not-enabled";
    readonly MISSING_RECAPTCHA_TOKEN: "auth/missing-recaptcha-token";
    readonly INVALID_RECAPTCHA_TOKEN: "auth/invalid-recaptcha-token";
    readonly INVALID_RECAPTCHA_ACTION: "auth/invalid-recaptcha-action";
    readonly MISSING_CLIENT_TYPE: "auth/missing-client-type";
    readonly MISSING_RECAPTCHA_VERSION: "auth/missing-recaptcha-version";
    readonly INVALID_RECAPTCHA_VERSION: "auth/invalid-recaptcha-version";
    readonly INVALID_REQ_TYPE: "auth/invalid-req-type";
    readonly INVALID_HOSTING_LINK_DOMAIN: "auth/invalid-hosting-link-domain";
};


export declare interface AuthErrorMap {
}


declare interface AuthErrorParams extends GenericAuthErrorParams {
    [AuthErrorCode.ARGUMENT_ERROR]: {
        appName?: AppName;
    };
    [AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH]: {
        appName?: AppName;
    };
    [AuthErrorCode.INTERNAL_ERROR]: {
        appName?: AppName;
    };
    [AuthErrorCode.LOGIN_BLOCKED]: {
        appName?: AppName;
        originalMessage?: string;
    };
    [AuthErrorCode.OPERATION_NOT_SUPPORTED]: {
        appName?: AppName;
    };
    [AuthErrorCode.NO_AUTH_EVENT]: {
        appName?: AppName;
    };
    [AuthErrorCode.MFA_REQUIRED]: {
        appName: AppName;
        _serverResponse: IdTokenMfaResponse;
    };
    [AuthErrorCode.INVALID_CORDOVA_CONFIGURATION]: {
        appName: AppName;
        missingPlugin?: string;
    };
}


declare interface AuthEvent {
    type: AuthEventType;
    eventId: string | null;
    urlResponse: string | null;
    sessionId: string | null;
    postBody: string | null;
    tenantId: string | null;
    error?: AuthEventError;
}


declare interface AuthEventConsumer {
    readonly filter: AuthEventType[];
    eventId: string | null;
    onAuthEvent(event: AuthEvent): unknown;
    onError(error: FirebaseError): unknown;
}

declare interface AuthEventError extends Error {
    code: string;
    message: string;
}


declare const enum AuthEventType {
    LINK_VIA_POPUP = "linkViaPopup",
    LINK_VIA_REDIRECT = "linkViaRedirect",
    REAUTH_VIA_POPUP = "reauthViaPopup",
    REAUTH_VIA_REDIRECT = "reauthViaRedirect",
    SIGN_IN_VIA_POPUP = "signInViaPopup",
    SIGN_IN_VIA_REDIRECT = "signInViaRedirect",
    UNKNOWN = "unknown",
    VERIFY_APP = "verifyApp"
}


declare interface AuthInternal extends Auth {
    currentUser: User | null;
    emulatorConfig: EmulatorConfig | null;
    _agentRecaptchaConfig: RecaptchaConfig | null;
    _tenantRecaptchaConfigs: Record<string, RecaptchaConfig>;
    _projectPasswordPolicy: PasswordPolicy | null;
    _tenantPasswordPolicies: Record<string, PasswordPolicy>;
    _canInitEmulator: boolean;
    _isInitialized: boolean;
    _initializationPromise: Promise<void> | null;
    _persistenceManagerAvailable: Promise<void>;
    _updateCurrentUser(user: UserInternal | null): Promise<void>;
    _onStorageEvent(): void;
    _notifyListenersIfCurrent(user: UserInternal): void;
    _persistUserIfCurrent(user: UserInternal): Promise<void>;
    _setRedirectUser(user: UserInternal | null, popupRedirectResolver?: PopupRedirectResolver): Promise<void>;
    _redirectUserForId(id: string): Promise<UserInternal | null>;
    _popupRedirectResolver: PopupRedirectResolverInternal | null;
    _key(): string;
    _startProactiveRefresh(): void;
    _stopProactiveRefresh(): void;
    _getPersistenceType(): string;
    _getPersistence(): PersistenceInternal;
    _getRecaptchaConfig(): RecaptchaConfig | null;
    _getPasswordPolicyInternal(): PasswordPolicyInternal | null;
    _updatePasswordPolicy(): Promise<void>;
    _logFramework(framework: string): void;
    _getFrameworks(): readonly string[];
    _getAdditionalHeaders(): Promise<Record<string, string>>;
    _getAppCheckToken(): Promise<string | undefined>;
    readonly name: AppName;
    readonly config: ConfigInternal;
    languageCode: string | null;
    tenantId: string | null;
    readonly settings: AuthSettings;
    _errorFactory: ErrorFactory<AuthErrorCode, AuthErrorParams>;
    useDeviceLanguage(): void;
    signOut(): Promise<void>;
    validatePassword(password: string): Promise<PasswordValidationStatus>;
    revokeAccessToken(token: string): Promise<void>;
}

declare class AuthPopup {
    readonly window: Window | null;
    associatedEvent: string | null;
    constructor(window: Window | null);
    close(): void;
}


export declare interface AuthProvider {
    
    readonly providerId: string;
}


export declare interface AuthSettings {
    
    appVerificationDisabledForTesting: boolean;
}


declare interface BaseMfaEnrollment {
    mfaEnrollmentId: string;
    enrolledAt: number;
    displayName?: string;
}


declare abstract class BaseOAuthProvider extends FederatedAuthProvider implements AuthProvider {
    
    private scopes;
    
    addScope(scope: string): AuthProvider;
    
    getScopes(): string[];
}


export declare function beforeAuthStateChanged(auth: Auth, callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;


export declare const browserCookiePersistence: Persistence;


export declare const browserLocalPersistence: Persistence;


export declare const browserPopupRedirectResolver: PopupRedirectResolver;


export declare const browserSessionPersistence: Persistence;


export declare function checkActionCode(auth: Auth, oobCode: string): Promise<ActionCodeInfo>;


declare const enum ClientPlatform {
    BROWSER = "Browser",
    NODE = "Node",
    REACT_NATIVE = "ReactNative",
    CORDOVA = "Cordova",
    WORKER = "Worker",
    WEB_EXTENSION = "WebExtension"
}
export { CompleteFn }


export declare interface Config {
    
    apiKey: string;
    
    apiHost: string;
    
    apiScheme: string;
    
    tokenApiHost: string;
    
    sdkClientVersion: string;
    
    authDomain?: string;
}


declare interface ConfigInternal extends Config {
    
    emulator?: {
        url: string;
    };
    
    clientPlatform: ClientPlatform;
}


export declare interface ConfirmationResult {
    
    readonly verificationId: string;
    
    confirm(verificationCode: string): Promise<UserCredential>;
}


export declare function confirmPasswordReset(auth: Auth, oobCode: string, newPassword: string): Promise<void>;


export declare function connectAuthEmulator(auth: Auth, url: string, options?: {
    disableWarnings: boolean;
}): void;


export declare function createUserWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;


export declare type CustomParameters = Record<string, string>;


export declare const debugErrorMap: AuthErrorMap;


export declare function deleteUser(user: User): Promise<void>;


export declare interface Dependencies {
    
    persistence?: Persistence | Persistence[];
    
    popupRedirectResolver?: PopupRedirectResolver;
    
    errorMap?: AuthErrorMap;
}


export declare class EmailAuthCredential extends AuthCredential {
    
    readonly _email: string;
    
    readonly _password: string;
    
    readonly _tenantId: string | null;
    
    private constructor();
    
    static _fromEmailAndPassword(email: string, password: string): EmailAuthCredential;
    
    static _fromEmailAndCode(email: string, oobCode: string, tenantId?: string | null): EmailAuthCredential;
    
    toJSON(): object;
    
    static fromJSON(json: object | string): EmailAuthCredential | null;
    
    _getIdTokenResponse(auth: AuthInternal): Promise<IdTokenResponse>;
    
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
}


export declare class EmailAuthProvider implements AuthProvider {
    
    static readonly PROVIDER_ID: 'password';
    
    static readonly EMAIL_PASSWORD_SIGN_IN_METHOD: 'password';
    
    static readonly EMAIL_LINK_SIGN_IN_METHOD: 'emailLink';
    
    readonly providerId: "password";
    
    static credential(email: string, password: string): EmailAuthCredential;
    
    static credentialWithLink(email: string, emailLink: string): EmailAuthCredential;
}


export declare interface EmulatorConfig {
    
    readonly protocol: string;
    
    readonly host: string;
    
    readonly port: number | null;
    
    readonly options: {
        
        readonly disableWarnings: boolean;
    };
}

declare const enum EnforcementState {
    ENFORCE = "ENFORCE",
    AUDIT = "AUDIT",
    OFF = "OFF",
    ENFORCEMENT_STATE_UNSPECIFIED = "ENFORCEMENT_STATE_UNSPECIFIED"
}
export { ErrorFn }


declare interface EventManager {
    registerConsumer(authEventConsumer: AuthEventConsumer): void;
    unregisterConsumer(authEventConsumer: AuthEventConsumer): void;
}


export declare class FacebookAuthProvider extends BaseOAuthProvider {
    
    static readonly FACEBOOK_SIGN_IN_METHOD: 'facebook.com';
    
    static readonly PROVIDER_ID: 'facebook.com';
    constructor();
    
    static credential(accessToken: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare const FactorId: {
    
    readonly PHONE: "phone";
    readonly TOTP: "totp";
};


declare abstract class FederatedAuthProvider implements AuthProvider {
    readonly providerId: string;
    
    defaultLanguageCode: string | null;
    
    private customParameters;
    
    constructor(providerId: string);
    
    setDefaultLanguage(languageCode: string | null): void;
    
    setCustomParameters(customOAuthParameters: CustomParameters): AuthProvider;
    
    getCustomParameters(): CustomParameters;
}


export declare function fetchSignInMethodsForEmail(auth: Auth, email: string): Promise<string[]>;

declare interface FinalizeMfaResponse {
    idToken: string;
    refreshToken: string;
}


declare type GenericAuthErrorParams = {
    [key in Exclude<AuthErrorCode, AuthErrorCode.ARGUMENT_ERROR | AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH | AuthErrorCode.INTERNAL_ERROR | AuthErrorCode.MFA_REQUIRED | AuthErrorCode.NO_AUTH_EVENT | AuthErrorCode.OPERATION_NOT_SUPPORTED>]: {
        appName?: AppName;
        email?: string;
        phoneNumber?: string;
        message?: string;
    };
};


export declare function getAdditionalUserInfo(userCredential: UserCredential): AdditionalUserInfo | null;


export declare function getAuth(app?: FirebaseApp): Auth;


export declare function getIdToken(user: User, forceRefresh?: boolean): Promise<string>;


export declare function getIdTokenResult(user: User, forceRefresh?: boolean): Promise<IdTokenResult>;


export declare function getMultiFactorResolver(auth: Auth, error: MultiFactorError): MultiFactorResolver;

declare interface GetRecaptchaConfigResponse {
    recaptchaKey: string;
    recaptchaEnforcementState: RecaptchaEnforcementProviderState[];
}


export declare function getRedirectResult(auth: Auth, resolver?: PopupRedirectResolver): Promise<UserCredential | null>;


export declare class GithubAuthProvider extends BaseOAuthProvider {
    
    static readonly GITHUB_SIGN_IN_METHOD: 'github.com';
    
    static readonly PROVIDER_ID: 'github.com';
    constructor();
    
    static credential(accessToken: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare class GoogleAuthProvider extends BaseOAuthProvider {
    
    static readonly GOOGLE_SIGN_IN_METHOD: 'google.com';
    
    static readonly PROVIDER_ID: 'google.com';
    constructor();
    
    static credential(idToken?: string | null, accessToken?: string | null): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


declare type IdToken = string;


declare interface IdTokenMfaResponse extends IdTokenResponse {
    mfaPendingCredential?: string;
    mfaInfo?: MfaEnrollment[];
}


declare interface IdTokenResponse {
    localId: string;
    idToken?: IdToken;
    refreshToken?: string;
    expiresIn?: string;
    providerId?: string;
    displayName?: string | null;
    isNewUser?: boolean;
    kind?: IdTokenResponseKind;
    photoUrl?: string | null;
    rawUserInfo?: string;
    screenName?: string | null;
}


declare const enum IdTokenResponseKind {
    CreateAuthUri = "identitytoolkit#CreateAuthUriResponse",
    DeleteAccount = "identitytoolkit#DeleteAccountResponse",
    DownloadAccount = "identitytoolkit#DownloadAccountResponse",
    EmailLinkSignin = "identitytoolkit#EmailLinkSigninResponse",
    GetAccountInfo = "identitytoolkit#GetAccountInfoResponse",
    GetOobConfirmationCode = "identitytoolkit#GetOobConfirmationCodeResponse",
    GetRecaptchaParam = "identitytoolkit#GetRecaptchaParamResponse",
    ResetPassword = "identitytoolkit#ResetPasswordResponse",
    SetAccountInfo = "identitytoolkit#SetAccountInfoResponse",
    SignupNewUser = "identitytoolkit#SignupNewUserResponse",
    UploadAccount = "identitytoolkit#UploadAccountResponse",
    VerifyAssertion = "identitytoolkit#VerifyAssertionResponse",
    VerifyCustomToken = "identitytoolkit#VerifyCustomTokenResponse",
    VerifyPassword = "identitytoolkit#VerifyPasswordResponse"
}


export declare interface IdTokenResult {
    
    authTime: string;
    
    expirationTime: string;
    
    issuedAtTime: string;
    
    signInProvider: string | null;
    
    signInSecondFactor: string | null;
    
    token: string;
    
    claims: ParsedToken;
}


export declare const indexedDBLocalPersistence: Persistence;


export declare function initializeAuth(app: FirebaseApp, deps?: Dependencies): Auth;


export declare function initializeRecaptchaConfig(auth: Auth): Promise<void>;


export declare const inMemoryPersistence: Persistence;


export declare function isSignInWithEmailLink(auth: Auth, emailLink: string): boolean;


export declare function linkWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;


export declare function linkWithPhoneNumber(user: User, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;


export declare function linkWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function linkWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;


declare type MfaEnrollment = PhoneMfaEnrollment | TotpMfaEnrollment;


export declare function multiFactor(user: User): MultiFactorUser;


export declare interface MultiFactorAssertion {
    
    readonly factorId: (typeof FactorId)[keyof typeof FactorId];
}


export declare interface MultiFactorError extends AuthError {
    
    readonly customData: AuthError['customData'] & {
        
        readonly operationType: (typeof OperationType)[keyof typeof OperationType];
    };
}


export declare interface MultiFactorInfo {
    
    readonly uid: string;
    
    readonly displayName?: string | null;
    
    readonly enrollmentTime: string;
    
    readonly factorId: (typeof FactorId)[keyof typeof FactorId];
}


export declare interface MultiFactorResolver {
    
    readonly hints: MultiFactorInfo[];
    
    readonly session: MultiFactorSession;
    
    resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;
}


export declare interface MultiFactorSession {
}


export declare interface MultiFactorUser {
    
    readonly enrolledFactors: MultiFactorInfo[];
    
    getSession(): Promise<MultiFactorSession>;
    
    enroll(assertion: MultiFactorAssertion, displayName?: string | null): Promise<void>;
    
    unenroll(option: MultiFactorInfo | string): Promise<void>;
}

declare type MutableUserInfo = {
    -readonly [K in keyof UserInfo]: UserInfo[K];
};
export { NextFn }


export declare type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;


export declare class OAuthCredential extends AuthCredential {
    
    idToken?: string;
    
    accessToken?: string;
    
    secret?: string;
    private nonce?;
    private pendingToken;
    
    static _fromParams(params: OAuthCredentialParams): OAuthCredential;
    
    toJSON(): object;
    
    static fromJSON(json: string | object): OAuthCredential | null;
    
    _getIdTokenResponse(auth: AuthInternal): Promise<IdTokenResponse>;
    
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
    private buildRequest;
}


export declare interface OAuthCredentialOptions {
    
    idToken?: string;
    
    accessToken?: string;
    
    rawNonce?: string;
}

declare interface OAuthCredentialParams {
    idToken?: string | null;
    accessToken?: string | null;
    oauthToken?: string;
    secret?: string;
    oauthTokenSecret?: string;
    nonce?: string;
    pendingToken?: string;
    providerId: string;
    signInMethod: string;
}


export declare class OAuthProvider extends BaseOAuthProvider {
    
    static credentialFromJSON(json: object | string): OAuthCredential;
    
    credential(params: OAuthCredentialOptions): OAuthCredential;
    
    private _credential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static oauthCredentialFromTaggedObject;
}


export declare function onAuthStateChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;


export declare function onIdTokenChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;


export declare const OperationType: {
    
    readonly LINK: "link";
    
    readonly REAUTHENTICATE: "reauthenticate";
    
    readonly SIGN_IN: "signIn";
};


export declare function parseActionCodeURL(link: string): ActionCodeURL | null;


export declare interface ParsedToken {
    
    'exp'?: string;
    
    'sub'?: string;
    
    'auth_time'?: string;
    
    'iat'?: string;
    
    'firebase'?: {
        'sign_in_provider'?: string;
        'sign_in_second_factor'?: string;
        'identities'?: Record<string, string>;
    };
    
    [key: string]: unknown;
}


export declare interface PasswordPolicy {
    
    readonly customStrengthOptions: {
        
        readonly minPasswordLength?: number;
        
        readonly maxPasswordLength?: number;
        
        readonly containsLowercaseLetter?: boolean;
        
        readonly containsUppercaseLetter?: boolean;
        
        readonly containsNumericCharacter?: boolean;
        
        readonly containsNonAlphanumericCharacter?: boolean;
    };
    
    readonly allowedNonAlphanumericCharacters: string;
    
    readonly enforcementState: string;
    
    readonly forceUpgradeOnSignin: boolean;
}


declare interface PasswordPolicyCustomStrengthOptions {
    
    minPasswordLength?: number;
    
    maxPasswordLength?: number;
    
    containsLowercaseLetter?: boolean;
    
    containsUppercaseLetter?: boolean;
    
    containsNumericCharacter?: boolean;
    
    containsNonAlphanumericCharacter?: boolean;
}


declare interface PasswordPolicyInternal extends PasswordPolicy {
    
    readonly customStrengthOptions: PasswordPolicyCustomStrengthOptions;
    
    readonly schemaVersion: number;
    
    validatePassword(password: string): PasswordValidationStatus;
}


export declare interface PasswordValidationStatus {
    
    readonly isValid: boolean;
    
    readonly meetsMinPasswordLength?: boolean;
    
    readonly meetsMaxPasswordLength?: boolean;
    
    readonly containsLowercaseLetter?: boolean;
    
    readonly containsUppercaseLetter?: boolean;
    
    readonly containsNumericCharacter?: boolean;
    
    readonly containsNonAlphanumericCharacter?: boolean;
    
    readonly passwordPolicy: PasswordPolicy;
}

declare type PersistedBlob = Record<string, unknown>;


export declare interface Persistence {
    
    readonly type: 'SESSION' | 'LOCAL' | 'NONE' | 'COOKIE';
}

declare interface PersistenceInternal extends Persistence {
    type: PersistenceType;
    _isAvailable(): Promise<boolean>;
    _set(key: string, value: PersistenceValue): Promise<void>;
    _get<T extends PersistenceValue>(key: string): Promise<T | null>;
    _remove(key: string): Promise<void>;
    _addListener(key: string, listener: StorageEventListener): void;
    _removeListener(key: string, listener: StorageEventListener): void;
    _shouldAllowMigration?: boolean;
}

declare const enum PersistenceType {
    SESSION = "SESSION",
    LOCAL = "LOCAL",
    NONE = "NONE",
    COOKIE = "COOKIE"
}

declare type PersistenceValue = PersistedBlob | string;


export declare class PhoneAuthCredential extends AuthCredential {
    private readonly params;
    private constructor();
    
    static _fromVerification(verificationId: string, verificationCode: string): PhoneAuthCredential;
    
    static _fromTokenResponse(phoneNumber: string, temporaryProof: string): PhoneAuthCredential;
    
    _getIdTokenResponse(auth: AuthInternal): Promise<PhoneOrOauthTokenResponse>;
    
    _linkToIdToken(auth: AuthInternal, idToken: string): Promise<IdTokenResponse>;
    
    _getReauthenticationResolver(auth: AuthInternal): Promise<IdTokenResponse>;
    
    _makeVerificationRequest(): SignInWithPhoneNumberRequest;
    
    toJSON(): object;
    
    static fromJSON(json: object | string): PhoneAuthCredential | null;
}


export declare class PhoneAuthProvider {
    
    static readonly PROVIDER_ID: 'phone';
    
    static readonly PHONE_SIGN_IN_METHOD: 'phone';
    
    readonly providerId: "phone";
    private readonly auth;
    
    constructor(auth: Auth);
    
    verifyPhoneNumber(phoneOptions: PhoneInfoOptions | string, applicationVerifier?: ApplicationVerifier): Promise<string>;
    
    static credential(verificationId: string, verificationCode: string): PhoneAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare type PhoneInfoOptions = PhoneSingleFactorInfoOptions | PhoneMultiFactorEnrollInfoOptions | PhoneMultiFactorSignInInfoOptions;


declare interface PhoneMfaEnrollment extends BaseMfaEnrollment {
    phoneInfo: string;
}


export declare interface PhoneMultiFactorAssertion extends MultiFactorAssertion {
}


export declare interface PhoneMultiFactorEnrollInfoOptions {
    
    phoneNumber: string;
    
    session: MultiFactorSession;
}


export declare class PhoneMultiFactorGenerator {
    private constructor();
    
    static assertion(credential: PhoneAuthCredential): PhoneMultiFactorAssertion;
    
    static FACTOR_ID: string;
}


export declare interface PhoneMultiFactorInfo extends MultiFactorInfo {
    
    readonly phoneNumber: string;
}


export declare interface PhoneMultiFactorSignInInfoOptions {
    
    multiFactorHint?: MultiFactorInfo;
    
    multiFactorUid?: string;
    
    session: MultiFactorSession;
}


declare type PhoneOrOauthTokenResponse = SignInWithPhoneNumberResponse | SignInWithIdpResponse | IdTokenResponse;


export declare interface PhoneSingleFactorInfoOptions {
    
    phoneNumber: string;
}


export declare interface PopupRedirectResolver {
}


declare interface PopupRedirectResolverInternal extends PopupRedirectResolver {
    _shouldInitProactively: boolean;
    _initialize(auth: AuthInternal): Promise<EventManager>;
    _openPopup(auth: AuthInternal, provider: AuthProvider, authType: AuthEventType, eventId?: string): Promise<AuthPopup>;
    _openRedirect(auth: AuthInternal, provider: AuthProvider, authType: AuthEventType, eventId?: string): Promise<void | never>;
    _isIframeWebStorageSupported(auth: AuthInternal, cb: (support: boolean) => unknown): void;
    _redirectPersistence: Persistence;
    _originValidation(auth: Auth): Promise<void>;
    _completeRedirectFn: (auth: Auth, resolver: PopupRedirectResolver, bypassAuthState: boolean) => Promise<UserCredential | null>;
    _overrideRedirectResult: (auth: AuthInternal, resultGetter: () => Promise<UserCredentialInternal | null>) => void;
}


export declare const prodErrorMap: AuthErrorMap;


export declare const ProviderId: {
    
    readonly FACEBOOK: "facebook.com";
    
    readonly GITHUB: "github.com";
    
    readonly GOOGLE: "google.com";
    
    readonly PASSWORD: "password";
    
    readonly PHONE: "phone";
    
    readonly TWITTER: "twitter.com";
};



declare const enum ProviderId_2 {
    
    ANONYMOUS = "anonymous",
    
    CUSTOM = "custom",
    
    FACEBOOK = "facebook.com",
    
    FIREBASE = "firebase",
    
    GITHUB = "github.com",
    
    GOOGLE = "google.com",
    
    PASSWORD = "password",
    
    PHONE = "phone",
    
    TWITTER = "twitter.com"
}

declare interface ProviderUserInfo {
    providerId: string;
    rawId?: string;
    email?: string;
    displayName?: string;
    photoUrl?: string;
    phoneNumber?: string;
}


export declare interface ReactNativeAsyncStorage {
    
    setItem(key: string, value: string): Promise<void>;
    
    getItem(key: string): Promise<string | null>;
    
    removeItem(key: string): Promise<void>;
}


export declare function reauthenticateWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;


export declare function reauthenticateWithPhoneNumber(user: User, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;


export declare function reauthenticateWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function reauthenticateWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;

declare interface Recaptcha {
    render: (container: HTMLElement, parameters: RecaptchaParameters) => number;
    getResponse: (id: number) => string;
    execute: (id: number) => unknown;
    reset: (id: number) => unknown;
}

declare class RecaptchaConfig {
    
    siteKey: string;
    
    recaptchaEnforcementState: RecaptchaEnforcementProviderState[];
    constructor(response: GetRecaptchaConfigResponse);
    
    getProviderEnforcementState(providerStr: string): EnforcementState | null;
    
    isProviderEnabled(providerStr: string): boolean;
    
    isAnyProviderEnabled(): boolean;
}

declare interface RecaptchaEnforcementProviderState {
    provider: string;
    enforcementState: string;
}


declare interface ReCaptchaLoader {
    load(auth: AuthInternal, hl?: string): Promise<Recaptcha>;
    clearedOneInstance(): void;
}


export declare interface RecaptchaParameters {
    [key: string]: any;
}


export declare class RecaptchaVerifier implements ApplicationVerifierInternal {
    private readonly parameters;
    
    readonly type = "recaptcha";
    private destroyed;
    private widgetId;
    private readonly container;
    private readonly isInvisible;
    private readonly tokenChangeListeners;
    private renderPromise;
    private readonly auth;
    
    readonly _recaptchaLoader: ReCaptchaLoader;
    private recaptcha;
    
    constructor(authExtern: Auth, containerOrId: HTMLElement | string, parameters?: RecaptchaParameters);
    
    verify(): Promise<string>;
    
    render(): Promise<number>;
    
    _reset(): void;
    
    clear(): void;
    private validateStartingState;
    private makeTokenCallback;
    private assertNotDestroyed;
    private makeRenderPromise;
    private init;
    private getAssertedRecaptcha;
}


export declare function reload(user: User): Promise<void>;


export declare function revokeAccessToken(auth: Auth, token: string): Promise<void>;


export declare class SAMLAuthProvider extends FederatedAuthProvider {
    
    constructor(providerId: string);
    
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    
    static credentialFromJSON(json: string | object): AuthCredential;
    private static samlCredentialFromTaggedObject;
}


export declare function sendEmailVerification(user: User, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;


export declare function sendPasswordResetEmail(auth: Auth, email: string, actionCodeSettings?: ActionCodeSettings): Promise<void>;


export declare function sendSignInLinkToEmail(auth: Auth, email: string, actionCodeSettings: ActionCodeSettings): Promise<void>;


export declare function setPersistence(auth: Auth, persistence: Persistence): Promise<void>;


export declare function signInAnonymously(auth: Auth): Promise<UserCredential>;


export declare const SignInMethod: {
    
    readonly EMAIL_LINK: "emailLink";
    
    readonly EMAIL_PASSWORD: "password";
    
    readonly FACEBOOK: "facebook.com";
    
    readonly GITHUB: "github.com";
    
    readonly GOOGLE: "google.com";
    
    readonly PHONE: "phone";
    
    readonly TWITTER: "twitter.com";
};


export declare function signInWithCredential(auth: Auth, credential: AuthCredential): Promise<UserCredential>;


export declare function signInWithCustomToken(auth: Auth, customToken: string): Promise<UserCredential>;


export declare function signInWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;


export declare function signInWithEmailLink(auth: Auth, email: string, emailLink?: string): Promise<UserCredential>;


declare interface SignInWithIdpResponse extends IdTokenResponse {
    oauthAccessToken?: string;
    oauthTokenSecret?: string;
    nonce?: string;
    oauthIdToken?: string;
    pendingToken?: string;
}


export declare function signInWithPhoneNumber(auth: Auth, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;


declare interface SignInWithPhoneNumberRequest {
    temporaryProof?: string;
    phoneNumber?: string;
    sessionInfo?: string;
    code?: string;
    tenantId?: string;
}


declare interface SignInWithPhoneNumberResponse extends IdTokenResponse {
    temporaryProof?: string;
    phoneNumber?: string;
}


export declare function signInWithPopup(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function signInWithRedirect(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;


export declare function signOut(auth: Auth): Promise<void>;

declare interface StartTotpMfaEnrollmentResponse {
    totpSessionInfo: {
        sharedSecretKey: string;
        verificationCodeLength: number;
        hashingAlgorithm: string;
        periodSec: number;
        sessionInfo: string;
        finalizeEnrollmentTime: number;
    };
}

declare interface StorageEventListener {
    (value: PersistenceValue | null): void;
}


declare class StsTokenManager {
    refreshToken: string | null;
    accessToken: string | null;
    expirationTime: number | null;
    get isExpired(): boolean;
    updateFromServerResponse(response: IdTokenResponse | FinalizeMfaResponse): void;
    updateFromIdToken(idToken: string): void;
    getToken(auth: AuthInternal, forceRefresh?: boolean): Promise<string | null>;
    clearRefreshToken(): void;
    private refresh;
    private updateTokensAndExpiration;
    static fromJSON(appName: string, object: PersistedBlob): StsTokenManager;
    toJSON(): object;
    _assign(stsTokenManager: StsTokenManager): void;
    _clone(): StsTokenManager;
    _performRefresh(): never;
}


declare interface TaggedWithTokenResponse {
    _tokenResponse?: PhoneOrOauthTokenResponse;
}


declare interface TotpMfaEnrollment extends BaseMfaEnrollment {
}


export declare interface TotpMultiFactorAssertion extends MultiFactorAssertion {
}


export declare class TotpMultiFactorGenerator {
    
    static assertionForEnrollment(secret: TotpSecret, oneTimePassword: string): TotpMultiFactorAssertion;
    
    static assertionForSignIn(enrollmentId: string, oneTimePassword: string): TotpMultiFactorAssertion;
    
    static generateSecret(session: MultiFactorSession): Promise<TotpSecret>;
    
    static FACTOR_ID: 'totp';
}


export declare interface TotpMultiFactorInfo extends MultiFactorInfo {
}


export declare class TotpSecret {
    private readonly sessionInfo;
    private readonly auth;
    
    readonly secretKey: string;
    
    readonly hashingAlgorithm: string;
    
    readonly codeLength: number;
    
    readonly codeIntervalSeconds: number;
    
    readonly enrollmentCompletionDeadline: string;
    private constructor();
    
    static _fromStartTotpMfaEnrollmentResponse(response: StartTotpMfaEnrollmentResponse, auth: AuthInternal): TotpSecret;
    
    _makeTotpVerificationInfo(otp: string): TotpVerificationInfo;
    
    generateQrCodeUrl(accountName?: string, issuer?: string): string;
}

declare interface TotpVerificationInfo {
    sessionInfo: string;
    verificationCode: string;
}


export declare class TwitterAuthProvider extends BaseOAuthProvider {
    
    static readonly TWITTER_SIGN_IN_METHOD: 'twitter.com';
    
    static readonly PROVIDER_ID: 'twitter.com';
    constructor();
    
    static credential(token: string, secret: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare function unlink(user: User, providerId: string): Promise<User>;
export { Unsubscribe }


export declare function updateCurrentUser(auth: Auth, user: User | null): Promise<void>;


export declare function updateEmail(user: User, newEmail: string): Promise<void>;


export declare function updatePassword(user: User, newPassword: string): Promise<void>;


export declare function updatePhoneNumber(user: User, credential: PhoneAuthCredential): Promise<void>;


export declare function updateProfile(user: User, { displayName, photoURL: photoUrl }: {
    displayName?: string | null;
    photoURL?: string | null;
}): Promise<void>;


export declare function useDeviceLanguage(auth: Auth): void;


export declare interface User extends UserInfo {
    
    readonly emailVerified: boolean;
    
    readonly isAnonymous: boolean;
    
    readonly metadata: UserMetadata;
    
    readonly providerData: UserInfo[];
    
    readonly refreshToken: string;
    
    readonly tenantId: string | null;
    
    delete(): Promise<void>;
    
    getIdToken(forceRefresh?: boolean): Promise<string>;
    
    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
    
    reload(): Promise<void>;
    
    toJSON(): object;
}


export declare interface UserCredential {
    
    user: User;
    
    providerId: string | null;
    
    operationType: (typeof OperationType)[keyof typeof OperationType];
}


declare interface UserCredentialInternal extends UserCredential, TaggedWithTokenResponse {
    user: UserInternal;
}


export declare interface UserInfo {
    
    readonly displayName: string | null;
    
    readonly email: string | null;
    
    readonly phoneNumber: string | null;
    
    readonly photoURL: string | null;
    
    readonly providerId: string;
    
    readonly uid: string;
}


declare interface UserInternal extends User {
    displayName: string | null;
    email: string | null;
    phoneNumber: string | null;
    photoURL: string | null;
    auth: AuthInternal;
    providerId: ProviderId_2.FIREBASE;
    refreshToken: string;
    emailVerified: boolean;
    tenantId: string | null;
    providerData: MutableUserInfo[];
    metadata: UserMetadata_2;
    stsTokenManager: StsTokenManager;
    _redirectEventId?: string;
    _updateTokensIfNecessary(response: IdTokenResponse | FinalizeMfaResponse, reload?: boolean): Promise<void>;
    _assign(user: UserInternal): void;
    _clone(auth: AuthInternal): UserInternal;
    _onReload: (cb: NextFn<APIUserInfo>) => void;
    _notifyReloadListener: NextFn<APIUserInfo>;
    _startProactiveRefresh: () => void;
    _stopProactiveRefresh: () => void;
    getIdToken(forceRefresh?: boolean): Promise<string>;
    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
    reload(): Promise<void>;
    delete(): Promise<void>;
    toJSON(): PersistedBlob;
}


export declare interface UserMetadata {
    
    readonly creationTime?: string;
    
    readonly lastSignInTime?: string;
}

declare class UserMetadata_2 implements UserMetadata {
    private createdAt?;
    private lastLoginAt?;
    creationTime?: string;
    lastSignInTime?: string;
    constructor(createdAt?: (string | number) | undefined, lastLoginAt?: (string | number) | undefined);
    private _initializeTime;
    _copy(metadata: UserMetadata_2): void;
    toJSON(): object;
}


export declare type UserProfile = Record<string, unknown>;


export declare function validatePassword(auth: Auth, password: string): Promise<PasswordValidationStatus>;


export declare function verifyBeforeUpdateEmail(user: User, newEmail: string, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;


export declare function verifyPasswordResetCode(auth: Auth, code: string): Promise<string>;

export { }
