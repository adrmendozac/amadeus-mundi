

import { CompleteFn } from '@firebase/util';
import { ErrorFactory } from '@firebase/util';
import { ErrorFn } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseError } from '@firebase/util';
import { NextFn } from '@firebase/util';
import { Observer } from '@firebase/util';
import { Unsubscribe } from '@firebase/util';


export declare interface ActionCodeInfo {
    
    data: {
        email?: string | null;
        multiFactorInfo?: MultiFactorInfo | null;
        previousEmail?: string | null;
    };
    
    operation: (typeof ActionCodeOperation)[keyof typeof ActionCodeOperation];
}


export declare const ActionCodeOperation: {
    
    readonly EMAIL_SIGNIN: "EMAIL_SIGNIN";
    
    readonly PASSWORD_RESET: "PASSWORD_RESET";
    
    readonly RECOVER_EMAIL: "RECOVER_EMAIL";
    
    readonly REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION";
    
    readonly VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL";
    
    readonly VERIFY_EMAIL: "VERIFY_EMAIL";
};


export declare interface ActionCodeSettings {
    
    android?: {
        installApp?: boolean;
        minimumVersion?: string;
        packageName: string;
    };
    
    handleCodeInApp?: boolean;
    
    iOS?: {
        bundleId: string;
    };
    
    url: string;
    
    dynamicLinkDomain?: string;
    
    linkDomain?: string;
}



export declare class ActionCodeURL {
    
    readonly apiKey: string;
    
    readonly code: string;
    
    readonly continueUrl: string | null;
    
    readonly languageCode: string | null;
    
    readonly operation: string;
    
    readonly tenantId: string | null;
    
    
    static parseLink(link: string): ActionCodeURL | null;
}


export declare interface AdditionalUserInfo {
    
    readonly isNewUser: boolean;
    
    readonly profile: Record<string, unknown> | null;
    
    readonly providerId: string | null;
    
    readonly username?: string | null;
}

declare interface APIUserInfo {
    localId?: string;
    displayName?: string;
    photoUrl?: string;
    email?: string;
    emailVerified?: boolean;
    phoneNumber?: string;
    lastLoginAt?: number;
    createdAt?: number;
    tenantId?: string;
    passwordHash?: string;
    providerUserInfo?: ProviderUserInfo[];
    mfaInfo?: MfaEnrollment[];
}


export declare interface ApplicationVerifier {
    
    readonly type: string;
    
    verify(): Promise<string>;
}

declare interface ApplicationVerifierInternal extends ApplicationVerifier {
    
}


export declare function applyActionCode(auth: Auth, oobCode: string): Promise<void>;

declare type AppName = string;


export declare interface Auth {
    
    readonly app: FirebaseApp;
    
    readonly name: string;
    
    readonly config: Config;
    
    setPersistence(persistence: Persistence): Promise<void>;
    
    languageCode: string | null;
    
    tenantId: string | null;
    
    readonly settings: AuthSettings;
    
    onAuthStateChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    beforeAuthStateChanged(callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;
    
    onIdTokenChanged(nextOrObserver: NextOrObserver<User | null>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;
    
    authStateReady(): Promise<void>;
    
    readonly currentUser: User | null;
    
    readonly emulatorConfig: EmulatorConfig | null;
    
    updateCurrentUser(user: User | null): Promise<void>;
    
    useDeviceLanguage(): void;
    
    signOut(): Promise<void>;
}


export declare class AuthCredential {
    
    readonly providerId: string;
    
    readonly signInMethod: string;
    
    
    toJSON(): object;
    
    
    
}


export declare interface AuthError extends FirebaseError {
    
    readonly customData: {
        
        readonly appName: string;
        
        readonly email?: string;
        
        readonly phoneNumber?: string;
        
        readonly tenantId?: string;
    };
}




export declare const AuthErrorCodes: {
    readonly ADMIN_ONLY_OPERATION: "auth/admin-restricted-operation";
    readonly ARGUMENT_ERROR: "auth/argument-error";
    readonly APP_NOT_AUTHORIZED: "auth/app-not-authorized";
    readonly APP_NOT_INSTALLED: "auth/app-not-installed";
    readonly CAPTCHA_CHECK_FAILED: "auth/captcha-check-failed";
    readonly CODE_EXPIRED: "auth/code-expired";
    readonly CORDOVA_NOT_READY: "auth/cordova-not-ready";
    readonly CORS_UNSUPPORTED: "auth/cors-unsupported";
    readonly CREDENTIAL_ALREADY_IN_USE: "auth/credential-already-in-use";
    readonly CREDENTIAL_MISMATCH: "auth/custom-token-mismatch";
    readonly CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "auth/requires-recent-login";
    readonly DEPENDENT_SDK_INIT_BEFORE_AUTH: "auth/dependent-sdk-initialized-before-auth";
    readonly DYNAMIC_LINK_NOT_ACTIVATED: "auth/dynamic-link-not-activated";
    readonly EMAIL_CHANGE_NEEDS_VERIFICATION: "auth/email-change-needs-verification";
    readonly EMAIL_EXISTS: "auth/email-already-in-use";
    readonly EMULATOR_CONFIG_FAILED: "auth/emulator-config-failed";
    readonly EXPIRED_OOB_CODE: "auth/expired-action-code";
    readonly EXPIRED_POPUP_REQUEST: "auth/cancelled-popup-request";
    readonly INTERNAL_ERROR: "auth/internal-error";
    readonly INVALID_API_KEY: "auth/invalid-api-key";
    readonly INVALID_APP_CREDENTIAL: "auth/invalid-app-credential";
    readonly INVALID_APP_ID: "auth/invalid-app-id";
    readonly INVALID_AUTH: "auth/invalid-user-token";
    readonly INVALID_AUTH_EVENT: "auth/invalid-auth-event";
    readonly INVALID_CERT_HASH: "auth/invalid-cert-hash";
    readonly INVALID_CODE: "auth/invalid-verification-code";
    readonly INVALID_CONTINUE_URI: "auth/invalid-continue-uri";
    readonly INVALID_CORDOVA_CONFIGURATION: "auth/invalid-cordova-configuration";
    readonly INVALID_CUSTOM_TOKEN: "auth/invalid-custom-token";
    readonly INVALID_DYNAMIC_LINK_DOMAIN: "auth/invalid-dynamic-link-domain";
    readonly INVALID_EMAIL: "auth/invalid-email";
    readonly INVALID_EMULATOR_SCHEME: "auth/invalid-emulator-scheme";
    readonly INVALID_IDP_RESPONSE: "auth/invalid-credential";
    readonly INVALID_LOGIN_CREDENTIALS: "auth/invalid-credential";
    readonly INVALID_MESSAGE_PAYLOAD: "auth/invalid-message-payload";
    readonly INVALID_MFA_SESSION: "auth/invalid-multi-factor-session";
    readonly INVALID_OAUTH_CLIENT_ID: "auth/invalid-oauth-client-id";
    readonly INVALID_OAUTH_PROVIDER: "auth/invalid-oauth-provider";
    readonly INVALID_OOB_CODE: "auth/invalid-action-code";
    readonly INVALID_ORIGIN: "auth/unauthorized-domain";
    readonly INVALID_PASSWORD: "auth/wrong-password";
    readonly INVALID_PERSISTENCE: "auth/invalid-persistence-type";
    readonly INVALID_PHONE_NUMBER: "auth/invalid-phone-number";
    readonly INVALID_PROVIDER_ID: "auth/invalid-provider-id";
    readonly INVALID_RECIPIENT_EMAIL: "auth/invalid-recipient-email";
    readonly INVALID_SENDER: "auth/invalid-sender";
    readonly INVALID_SESSION_INFO: "auth/invalid-verification-id";
    readonly INVALID_TENANT_ID: "auth/invalid-tenant-id";
    readonly MFA_INFO_NOT_FOUND: "auth/multi-factor-info-not-found";
    readonly MFA_REQUIRED: "auth/multi-factor-auth-required";
    readonly MISSING_ANDROID_PACKAGE_NAME: "auth/missing-android-pkg-name";
    readonly MISSING_APP_CREDENTIAL: "auth/missing-app-credential";
    readonly MISSING_AUTH_DOMAIN: "auth/auth-domain-config-required";
    readonly MISSING_CODE: "auth/missing-verification-code";
    readonly MISSING_CONTINUE_URI: "auth/missing-continue-uri";
    readonly MISSING_IFRAME_START: "auth/missing-iframe-start";
    readonly MISSING_IOS_BUNDLE_ID: "auth/missing-ios-bundle-id";
    readonly MISSING_OR_INVALID_NONCE: "auth/missing-or-invalid-nonce";
    readonly MISSING_MFA_INFO: "auth/missing-multi-factor-info";
    readonly MISSING_MFA_SESSION: "auth/missing-multi-factor-session";
    readonly MISSING_PHONE_NUMBER: "auth/missing-phone-number";
    readonly MISSING_SESSION_INFO: "auth/missing-verification-id";
    readonly MODULE_DESTROYED: "auth/app-deleted";
    readonly NEED_CONFIRMATION: "auth/account-exists-with-different-credential";
    readonly NETWORK_REQUEST_FAILED: "auth/network-request-failed";
    readonly NULL_USER: "auth/null-user";
    readonly NO_AUTH_EVENT: "auth/no-auth-event";
    readonly NO_SUCH_PROVIDER: "auth/no-such-provider";
    readonly OPERATION_NOT_ALLOWED: "auth/operation-not-allowed";
    readonly OPERATION_NOT_SUPPORTED: "auth/operation-not-supported-in-this-environment";
    readonly POPUP_BLOCKED: "auth/popup-blocked";
    readonly POPUP_CLOSED_BY_USER: "auth/popup-closed-by-user";
    readonly PROVIDER_ALREADY_LINKED: "auth/provider-already-linked";
    readonly QUOTA_EXCEEDED: "auth/quota-exceeded";
    readonly REDIRECT_CANCELLED_BY_USER: "auth/redirect-cancelled-by-user";
    readonly REDIRECT_OPERATION_PENDING: "auth/redirect-operation-pending";
    readonly REJECTED_CREDENTIAL: "auth/rejected-credential";
    readonly SECOND_FACTOR_ALREADY_ENROLLED: "auth/second-factor-already-in-use";
    readonly SECOND_FACTOR_LIMIT_EXCEEDED: "auth/maximum-second-factor-count-exceeded";
    readonly TENANT_ID_MISMATCH: "auth/tenant-id-mismatch";
    readonly TIMEOUT: "auth/timeout";
    readonly TOKEN_EXPIRED: "auth/user-token-expired";
    readonly TOO_MANY_ATTEMPTS_TRY_LATER: "auth/too-many-requests";
    readonly UNAUTHORIZED_DOMAIN: "auth/unauthorized-continue-uri";
    readonly UNSUPPORTED_FIRST_FACTOR: "auth/unsupported-first-factor";
    readonly UNSUPPORTED_PERSISTENCE: "auth/unsupported-persistence-type";
    readonly UNSUPPORTED_TENANT_OPERATION: "auth/unsupported-tenant-operation";
    readonly UNVERIFIED_EMAIL: "auth/unverified-email";
    readonly USER_CANCELLED: "auth/user-cancelled";
    readonly USER_DELETED: "auth/user-not-found";
    readonly USER_DISABLED: "auth/user-disabled";
    readonly USER_MISMATCH: "auth/user-mismatch";
    readonly USER_SIGNED_OUT: "auth/user-signed-out";
    readonly WEAK_PASSWORD: "auth/weak-password";
    readonly WEB_STORAGE_UNSUPPORTED: "auth/web-storage-unsupported";
    readonly ALREADY_INITIALIZED: "auth/already-initialized";
    readonly RECAPTCHA_NOT_ENABLED: "auth/recaptcha-not-enabled";
    readonly MISSING_RECAPTCHA_TOKEN: "auth/missing-recaptcha-token";
    readonly INVALID_RECAPTCHA_TOKEN: "auth/invalid-recaptcha-token";
    readonly INVALID_RECAPTCHA_ACTION: "auth/invalid-recaptcha-action";
    readonly MISSING_CLIENT_TYPE: "auth/missing-client-type";
    readonly MISSING_RECAPTCHA_VERSION: "auth/missing-recaptcha-version";
    readonly INVALID_RECAPTCHA_VERSION: "auth/invalid-recaptcha-version";
    readonly INVALID_REQ_TYPE: "auth/invalid-req-type";
    readonly INVALID_HOSTING_LINK_DOMAIN: "auth/invalid-hosting-link-domain";
};


export declare interface AuthErrorMap {
}







declare interface AuthEventError extends Error {
    code: string;
    message: string;
}





declare class AuthPopup {
    readonly window: Window | null;
    associatedEvent: string | null;
    constructor(window: Window | null);
    close(): void;
}


export declare interface AuthProvider {
    
    readonly providerId: string;
}


export declare interface AuthSettings {
    
    appVerificationDisabledForTesting: boolean;
}


declare interface BaseMfaEnrollment {
    mfaEnrollmentId: string;
    enrolledAt: number;
    displayName?: string;
}


declare abstract class BaseOAuthProvider extends FederatedAuthProvider implements AuthProvider {
    
    
    addScope(scope: string): AuthProvider;
    
    getScopes(): string[];
}


export declare function beforeAuthStateChanged(auth: Auth, callback: (user: User | null) => void | Promise<void>, onAbort?: () => void): Unsubscribe;




export declare const browserLocalPersistence: Persistence;


export declare const browserPopupRedirectResolver: PopupRedirectResolver;


export declare const browserSessionPersistence: Persistence;


export declare function checkActionCode(auth: Auth, oobCode: string): Promise<ActionCodeInfo>;


export { CompleteFn }


export declare interface Config {
    
    apiKey: string;
    
    apiHost: string;
    
    apiScheme: string;
    
    tokenApiHost: string;
    
    sdkClientVersion: string;
    
    authDomain?: string;
}




export declare interface ConfirmationResult {
    
    readonly verificationId: string;
    
    confirm(verificationCode: string): Promise<UserCredential>;
}


export declare function confirmPasswordReset(auth: Auth, oobCode: string, newPassword: string): Promise<void>;


export declare function connectAuthEmulator(auth: Auth, url: string, options?: {
    disableWarnings: boolean;
}): void;


export declare function createUserWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;


export declare type CustomParameters = Record<string, string>;


export declare const debugErrorMap: AuthErrorMap;


export declare function deleteUser(user: User): Promise<void>;


export declare interface Dependencies {
    
    persistence?: Persistence | Persistence[];
    
    popupRedirectResolver?: PopupRedirectResolver;
    
    errorMap?: AuthErrorMap;
}


export declare class EmailAuthCredential extends AuthCredential {
    
    
    
    
    
    
    
    toJSON(): object;
    
    static fromJSON(json: object | string): EmailAuthCredential | null;
    
    
    
}


export declare class EmailAuthProvider implements AuthProvider {
    
    static readonly PROVIDER_ID: 'password';
    
    static readonly EMAIL_PASSWORD_SIGN_IN_METHOD: 'password';
    
    static readonly EMAIL_LINK_SIGN_IN_METHOD: 'emailLink';
    
    readonly providerId: "password";
    
    static credential(email: string, password: string): EmailAuthCredential;
    
    static credentialWithLink(email: string, emailLink: string): EmailAuthCredential;
}


export declare interface EmulatorConfig {
    
    readonly protocol: string;
    
    readonly host: string;
    
    readonly port: number | null;
    
    readonly options: {
        
        readonly disableWarnings: boolean;
    };
}

declare const enum EnforcementState {
    ENFORCE = "ENFORCE",
    AUDIT = "AUDIT",
    OFF = "OFF",
    ENFORCEMENT_STATE_UNSPECIFIED = "ENFORCEMENT_STATE_UNSPECIFIED"
}
export { ErrorFn }




export declare class FacebookAuthProvider extends BaseOAuthProvider {
    
    static readonly FACEBOOK_SIGN_IN_METHOD: 'facebook.com';
    
    static readonly PROVIDER_ID: 'facebook.com';
    constructor();
    
    static credential(accessToken: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare const FactorId: {
    
    readonly PHONE: "phone";
    readonly TOTP: "totp";
};


declare abstract class FederatedAuthProvider implements AuthProvider {
    readonly providerId: string;
    
    
    
    constructor(providerId: string);
    
    setDefaultLanguage(languageCode: string | null): void;
    
    setCustomParameters(customOAuthParameters: CustomParameters): AuthProvider;
    
    getCustomParameters(): CustomParameters;
}


export declare function fetchSignInMethodsForEmail(auth: Auth, email: string): Promise<string[]>;

declare interface FinalizeMfaResponse {
    idToken: string;
    refreshToken: string;
}




export declare function getAdditionalUserInfo(userCredential: UserCredential): AdditionalUserInfo | null;


export declare function getAuth(app?: FirebaseApp): Auth;


export declare function getIdToken(user: User, forceRefresh?: boolean): Promise<string>;


export declare function getIdTokenResult(user: User, forceRefresh?: boolean): Promise<IdTokenResult>;


export declare function getMultiFactorResolver(auth: Auth, error: MultiFactorError): MultiFactorResolver;

declare interface GetRecaptchaConfigResponse {
    recaptchaKey: string;
    recaptchaEnforcementState: RecaptchaEnforcementProviderState[];
}


export declare function getRedirectResult(auth: Auth, resolver?: PopupRedirectResolver): Promise<UserCredential | null>;


export declare class GithubAuthProvider extends BaseOAuthProvider {
    
    static readonly GITHUB_SIGN_IN_METHOD: 'github.com';
    
    static readonly PROVIDER_ID: 'github.com';
    constructor();
    
    static credential(accessToken: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare class GoogleAuthProvider extends BaseOAuthProvider {
    
    static readonly GOOGLE_SIGN_IN_METHOD: 'google.com';
    
    static readonly PROVIDER_ID: 'google.com';
    constructor();
    
    static credential(idToken?: string | null, accessToken?: string | null): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


declare type IdToken = string;








export declare interface IdTokenResult {
    
    authTime: string;
    
    expirationTime: string;
    
    issuedAtTime: string;
    
    signInProvider: string | null;
    
    signInSecondFactor: string | null;
    
    token: string;
    
    claims: ParsedToken;
}


export declare const indexedDBLocalPersistence: Persistence;


export declare function initializeAuth(app: FirebaseApp, deps?: Dependencies): Auth;


export declare function initializeRecaptchaConfig(auth: Auth): Promise<void>;


export declare const inMemoryPersistence: Persistence;


export declare function isSignInWithEmailLink(auth: Auth, emailLink: string): boolean;


export declare function linkWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;


export declare function linkWithPhoneNumber(user: User, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;


export declare function linkWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function linkWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;


declare type MfaEnrollment = PhoneMfaEnrollment | TotpMfaEnrollment;


export declare function multiFactor(user: User): MultiFactorUser;


export declare interface MultiFactorAssertion {
    
    readonly factorId: (typeof FactorId)[keyof typeof FactorId];
}


export declare interface MultiFactorError extends AuthError {
    
    readonly customData: AuthError['customData'] & {
        
        readonly operationType: (typeof OperationType)[keyof typeof OperationType];
    };
}


export declare interface MultiFactorInfo {
    
    readonly uid: string;
    
    readonly displayName?: string | null;
    
    readonly enrollmentTime: string;
    
    readonly factorId: (typeof FactorId)[keyof typeof FactorId];
}


export declare interface MultiFactorResolver {
    
    readonly hints: MultiFactorInfo[];
    
    readonly session: MultiFactorSession;
    
    resolveSignIn(assertion: MultiFactorAssertion): Promise<UserCredential>;
}


export declare interface MultiFactorSession {
}


export declare interface MultiFactorUser {
    
    readonly enrolledFactors: MultiFactorInfo[];
    
    getSession(): Promise<MultiFactorSession>;
    
    enroll(assertion: MultiFactorAssertion, displayName?: string | null): Promise<void>;
    
    unenroll(option: MultiFactorInfo | string): Promise<void>;
}

declare type MutableUserInfo = {
    -readonly [K in keyof UserInfo]: UserInfo[K];
};
export { NextFn }


export declare type NextOrObserver<T> = NextFn<T | null> | Observer<T | null>;


export declare class OAuthCredential extends AuthCredential {
    
    idToken?: string;
    
    accessToken?: string;
    
    secret?: string;
    private nonce?;
    private pendingToken;
    
    
    toJSON(): object;
    
    static fromJSON(json: string | object): OAuthCredential | null;
    
    
    
    private buildRequest;
}


export declare interface OAuthCredentialOptions {
    
    idToken?: string;
    
    accessToken?: string;
    
    rawNonce?: string;
}

declare interface OAuthCredentialParams {
    idToken?: string | null;
    accessToken?: string | null;
    oauthToken?: string;
    secret?: string;
    oauthTokenSecret?: string;
    nonce?: string;
    pendingToken?: string;
    providerId: string;
    signInMethod: string;
}


export declare class OAuthProvider extends BaseOAuthProvider {
    
    static credentialFromJSON(json: object | string): OAuthCredential;
    
    credential(params: OAuthCredentialOptions): OAuthCredential;
    
    private _credential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static oauthCredentialFromTaggedObject;
}


export declare function onAuthStateChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;


export declare function onIdTokenChanged(auth: Auth, nextOrObserver: NextOrObserver<User>, error?: ErrorFn, completed?: CompleteFn): Unsubscribe;


export declare const OperationType: {
    
    readonly LINK: "link";
    
    readonly REAUTHENTICATE: "reauthenticate";
    
    readonly SIGN_IN: "signIn";
};


export declare function parseActionCodeURL(link: string): ActionCodeURL | null;


export declare interface ParsedToken {
    
    'exp'?: string;
    
    'sub'?: string;
    
    'auth_time'?: string;
    
    'iat'?: string;
    
    'firebase'?: {
        'sign_in_provider'?: string;
        'sign_in_second_factor'?: string;
        'identities'?: Record<string, string>;
    };
    
    [key: string]: unknown;
}


export declare interface PasswordPolicy {
    
    readonly customStrengthOptions: {
        
        readonly minPasswordLength?: number;
        
        readonly maxPasswordLength?: number;
        
        readonly containsLowercaseLetter?: boolean;
        
        readonly containsUppercaseLetter?: boolean;
        
        readonly containsNumericCharacter?: boolean;
        
        readonly containsNonAlphanumericCharacter?: boolean;
    };
    
    readonly allowedNonAlphanumericCharacters: string;
    
    readonly enforcementState: string;
    
    readonly forceUpgradeOnSignin: boolean;
}






export declare interface PasswordValidationStatus {
    
    readonly isValid: boolean;
    
    readonly meetsMinPasswordLength?: boolean;
    
    readonly meetsMaxPasswordLength?: boolean;
    
    readonly containsLowercaseLetter?: boolean;
    
    readonly containsUppercaseLetter?: boolean;
    
    readonly containsNumericCharacter?: boolean;
    
    readonly containsNonAlphanumericCharacter?: boolean;
    
    readonly passwordPolicy: PasswordPolicy;
}

declare type PersistedBlob = Record<string, unknown>;


export declare interface Persistence {
    
    readonly type: 'SESSION' | 'LOCAL' | 'NONE' | 'COOKIE';
}

declare interface PersistenceInternal extends Persistence {
    type: PersistenceType;
    _isAvailable(): Promise<boolean>;
    _set(key: string, value: PersistenceValue): Promise<void>;
    _get<T extends PersistenceValue>(key: string): Promise<T | null>;
    _remove(key: string): Promise<void>;
    _addListener(key: string, listener: StorageEventListener): void;
    _removeListener(key: string, listener: StorageEventListener): void;
    _shouldAllowMigration?: boolean;
}

declare const enum PersistenceType {
    SESSION = "SESSION",
    LOCAL = "LOCAL",
    NONE = "NONE",
    COOKIE = "COOKIE"
}

declare type PersistenceValue = PersistedBlob | string;


export declare class PhoneAuthCredential extends AuthCredential {
    private readonly params;
    private constructor();
    
    
    
    
    
    
    
    toJSON(): object;
    
    static fromJSON(json: object | string): PhoneAuthCredential | null;
}


export declare class PhoneAuthProvider {
    
    static readonly PROVIDER_ID: 'phone';
    
    static readonly PHONE_SIGN_IN_METHOD: 'phone';
    
    readonly providerId: "phone";
    private readonly auth;
    
    constructor(auth: Auth);
    
    verifyPhoneNumber(phoneOptions: PhoneInfoOptions | string, applicationVerifier?: ApplicationVerifier): Promise<string>;
    
    static credential(verificationId: string, verificationCode: string): PhoneAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare type PhoneInfoOptions = PhoneSingleFactorInfoOptions | PhoneMultiFactorEnrollInfoOptions | PhoneMultiFactorSignInInfoOptions;


declare interface PhoneMfaEnrollment extends BaseMfaEnrollment {
    phoneInfo: string;
}


export declare interface PhoneMultiFactorAssertion extends MultiFactorAssertion {
}


export declare interface PhoneMultiFactorEnrollInfoOptions {
    
    phoneNumber: string;
    
    session: MultiFactorSession;
}


export declare class PhoneMultiFactorGenerator {
    private constructor();
    
    static assertion(credential: PhoneAuthCredential): PhoneMultiFactorAssertion;
    
    static FACTOR_ID: string;
}


export declare interface PhoneMultiFactorInfo extends MultiFactorInfo {
    
    readonly phoneNumber: string;
}


export declare interface PhoneMultiFactorSignInInfoOptions {
    
    multiFactorHint?: MultiFactorInfo;
    
    multiFactorUid?: string;
    
    session: MultiFactorSession;
}




export declare interface PhoneSingleFactorInfoOptions {
    
    phoneNumber: string;
}


export declare interface PopupRedirectResolver {
}




export declare const prodErrorMap: AuthErrorMap;


export declare const ProviderId: {
    
    readonly FACEBOOK: "facebook.com";
    
    readonly GITHUB: "github.com";
    
    readonly GOOGLE: "google.com";
    
    readonly PASSWORD: "password";
    
    readonly PHONE: "phone";
    
    readonly TWITTER: "twitter.com";
};



declare interface ProviderUserInfo {
    providerId: string;
    rawId?: string;
    email?: string;
    displayName?: string;
    photoUrl?: string;
    phoneNumber?: string;
}


export declare interface ReactNativeAsyncStorage {
    
    setItem(key: string, value: string): Promise<void>;
    
    getItem(key: string): Promise<string | null>;
    
    removeItem(key: string): Promise<void>;
}


export declare function reauthenticateWithCredential(user: User, credential: AuthCredential): Promise<UserCredential>;


export declare function reauthenticateWithPhoneNumber(user: User, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;


export declare function reauthenticateWithPopup(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function reauthenticateWithRedirect(user: User, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;

declare interface Recaptcha {
    render: (container: HTMLElement, parameters: RecaptchaParameters) => number;
    getResponse: (id: number) => string;
    execute: (id: number) => unknown;
    reset: (id: number) => unknown;
}

declare class RecaptchaConfig {
    
    siteKey: string;
    
    recaptchaEnforcementState: RecaptchaEnforcementProviderState[];
    constructor(response: GetRecaptchaConfigResponse);
    
    getProviderEnforcementState(providerStr: string): EnforcementState | null;
    
    isProviderEnabled(providerStr: string): boolean;
    
    isAnyProviderEnabled(): boolean;
}

declare interface RecaptchaEnforcementProviderState {
    provider: string;
    enforcementState: string;
}




export declare interface RecaptchaParameters {
    [key: string]: any;
}


export declare class RecaptchaVerifier implements ApplicationVerifierInternal {
    private readonly parameters;
    
    readonly type = "recaptcha";
    private destroyed;
    private widgetId;
    private readonly container;
    private readonly isInvisible;
    private readonly tokenChangeListeners;
    private renderPromise;
    private readonly auth;
    
    private recaptcha;
    
    constructor(authExtern: Auth, containerOrId: HTMLElement | string, parameters?: RecaptchaParameters);
    
    verify(): Promise<string>;
    
    render(): Promise<number>;
    
    
    clear(): void;
    private validateStartingState;
    private makeTokenCallback;
    private assertNotDestroyed;
    private makeRenderPromise;
    private init;
    private getAssertedRecaptcha;
}


export declare function reload(user: User): Promise<void>;


export declare function revokeAccessToken(auth: Auth, token: string): Promise<void>;


export declare class SAMLAuthProvider extends FederatedAuthProvider {
    
    constructor(providerId: string);
    
    static credentialFromResult(userCredential: UserCredential): AuthCredential | null;
    
    static credentialFromError(error: FirebaseError): AuthCredential | null;
    
    static credentialFromJSON(json: string | object): AuthCredential;
    private static samlCredentialFromTaggedObject;
}


export declare function sendEmailVerification(user: User, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;


export declare function sendPasswordResetEmail(auth: Auth, email: string, actionCodeSettings?: ActionCodeSettings): Promise<void>;


export declare function sendSignInLinkToEmail(auth: Auth, email: string, actionCodeSettings: ActionCodeSettings): Promise<void>;


export declare function setPersistence(auth: Auth, persistence: Persistence): Promise<void>;


export declare function signInAnonymously(auth: Auth): Promise<UserCredential>;


export declare const SignInMethod: {
    
    readonly EMAIL_LINK: "emailLink";
    
    readonly EMAIL_PASSWORD: "password";
    
    readonly FACEBOOK: "facebook.com";
    
    readonly GITHUB: "github.com";
    
    readonly GOOGLE: "google.com";
    
    readonly PHONE: "phone";
    
    readonly TWITTER: "twitter.com";
};


export declare function signInWithCredential(auth: Auth, credential: AuthCredential): Promise<UserCredential>;


export declare function signInWithCustomToken(auth: Auth, customToken: string): Promise<UserCredential>;


export declare function signInWithEmailAndPassword(auth: Auth, email: string, password: string): Promise<UserCredential>;


export declare function signInWithEmailLink(auth: Auth, email: string, emailLink?: string): Promise<UserCredential>;




export declare function signInWithPhoneNumber(auth: Auth, phoneNumber: string, appVerifier?: ApplicationVerifier): Promise<ConfirmationResult>;






export declare function signInWithPopup(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<UserCredential>;


export declare function signInWithRedirect(auth: Auth, provider: AuthProvider, resolver?: PopupRedirectResolver): Promise<never>;


export declare function signOut(auth: Auth): Promise<void>;

declare interface StartTotpMfaEnrollmentResponse {
    totpSessionInfo: {
        sharedSecretKey: string;
        verificationCodeLength: number;
        hashingAlgorithm: string;
        periodSec: number;
        sessionInfo: string;
        finalizeEnrollmentTime: number;
    };
}

declare interface StorageEventListener {
    (value: PersistenceValue | null): void;
}






declare interface TotpMfaEnrollment extends BaseMfaEnrollment {
}


export declare interface TotpMultiFactorAssertion extends MultiFactorAssertion {
}


export declare class TotpMultiFactorGenerator {
    
    static assertionForEnrollment(secret: TotpSecret, oneTimePassword: string): TotpMultiFactorAssertion;
    
    static assertionForSignIn(enrollmentId: string, oneTimePassword: string): TotpMultiFactorAssertion;
    
    static generateSecret(session: MultiFactorSession): Promise<TotpSecret>;
    
    static FACTOR_ID: 'totp';
}


export declare interface TotpMultiFactorInfo extends MultiFactorInfo {
}


export declare class TotpSecret {
    private readonly sessionInfo;
    private readonly auth;
    
    readonly secretKey: string;
    
    readonly hashingAlgorithm: string;
    
    readonly codeLength: number;
    
    readonly codeIntervalSeconds: number;
    
    readonly enrollmentCompletionDeadline: string;
    private constructor();
    
    
    
    generateQrCodeUrl(accountName?: string, issuer?: string): string;
}

declare interface TotpVerificationInfo {
    sessionInfo: string;
    verificationCode: string;
}


export declare class TwitterAuthProvider extends BaseOAuthProvider {
    
    static readonly TWITTER_SIGN_IN_METHOD: 'twitter.com';
    
    static readonly PROVIDER_ID: 'twitter.com';
    constructor();
    
    static credential(token: string, secret: string): OAuthCredential;
    
    static credentialFromResult(userCredential: UserCredential): OAuthCredential | null;
    
    static credentialFromError(error: FirebaseError): OAuthCredential | null;
    private static credentialFromTaggedObject;
}


export declare function unlink(user: User, providerId: string): Promise<User>;
export { Unsubscribe }


export declare function updateCurrentUser(auth: Auth, user: User | null): Promise<void>;


export declare function updateEmail(user: User, newEmail: string): Promise<void>;


export declare function updatePassword(user: User, newPassword: string): Promise<void>;


export declare function updatePhoneNumber(user: User, credential: PhoneAuthCredential): Promise<void>;


export declare function updateProfile(user: User, { displayName, photoURL: photoUrl }: {
    displayName?: string | null;
    photoURL?: string | null;
}): Promise<void>;


export declare function useDeviceLanguage(auth: Auth): void;


export declare interface User extends UserInfo {
    
    readonly emailVerified: boolean;
    
    readonly isAnonymous: boolean;
    
    readonly metadata: UserMetadata;
    
    readonly providerData: UserInfo[];
    
    readonly refreshToken: string;
    
    readonly tenantId: string | null;
    
    delete(): Promise<void>;
    
    getIdToken(forceRefresh?: boolean): Promise<string>;
    
    getIdTokenResult(forceRefresh?: boolean): Promise<IdTokenResult>;
    
    reload(): Promise<void>;
    
    toJSON(): object;
}


export declare interface UserCredential {
    
    user: User;
    
    providerId: string | null;
    
    operationType: (typeof OperationType)[keyof typeof OperationType];
}




export declare interface UserInfo {
    
    readonly displayName: string | null;
    
    readonly email: string | null;
    
    readonly phoneNumber: string | null;
    
    readonly photoURL: string | null;
    
    readonly providerId: string;
    
    readonly uid: string;
}




export declare interface UserMetadata {
    
    readonly creationTime?: string;
    
    readonly lastSignInTime?: string;
}

declare class UserMetadata_2 implements UserMetadata {
    private createdAt?;
    private lastLoginAt?;
    creationTime?: string;
    lastSignInTime?: string;
    constructor(createdAt?: (string | number) | undefined, lastLoginAt?: (string | number) | undefined);
    private _initializeTime;
    _copy(metadata: UserMetadata_2): void;
    toJSON(): object;
}


export declare type UserProfile = Record<string, unknown>;


export declare function validatePassword(auth: Auth, password: string): Promise<PasswordValidationStatus>;


export declare function verifyBeforeUpdateEmail(user: User, newEmail: string, actionCodeSettings?: ActionCodeSettings | null): Promise<void>;


export declare function verifyPasswordResetCode(auth: Auth, code: string): Promise<string>;

export { }
