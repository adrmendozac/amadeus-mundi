

import { AppCheckInternalComponentName } from '@firebase/app-check-interop-types';
import { AppCheckTokenListener } from '@firebase/app-check-interop-types';
import { AppCheckTokenResult } from '@firebase/app-check-interop-types';
import { EmulatorMockTokenOptions } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseApp as FirebaseApp_2 } from '@firebase/app-types';
import { FirebaseAppCheckInternal } from '@firebase/app-check-interop-types';
import { FirebaseAuthInternal } from '@firebase/auth-interop-types';
import { FirebaseAuthInternalName } from '@firebase/auth-interop-types';
import { FirebaseAuthTokenData } from '@firebase/app-types/private';
import { _FirebaseService } from '@firebase/app';
import { Provider } from '@firebase/component';


declare class AppCheckTokenProvider {
    private appCheckProvider?;
    private appCheck?;
    private serverAppAppCheckToken?;
    private appName;
    constructor(app: FirebaseApp, appCheckProvider?: Provider<AppCheckInternalComponentName>);
    getToken(forceRefresh?: boolean): Promise<AppCheckTokenResult>;
    addTokenChangeListener(listener: AppCheckTokenListener): void;
    notifyForInvalidToken(): void;
}

declare interface AuthTokenProvider {
    getToken(forceRefresh: boolean): Promise<FirebaseAuthTokenData>;
    addTokenChangeListener(listener: (token: string | null) => void): void;
    removeTokenChangeListener(listener: (token: string | null) => void): void;
    notifyForInvalidToken(): void;
}


declare class CacheNode {
    private node_;
    private fullyInitialized_;
    private filtered_;
    constructor(node_: Node_2, fullyInitialized_: boolean, filtered_: boolean);
    
    isFullyInitialized(): boolean;
    
    isFiltered(): boolean;
    isCompleteForPath(path: Path): boolean;
    isCompleteForChild(key: string): boolean;
    getNode(): Node_2;
}

declare class CancelEvent implements Event_2 {
    eventRegistration: EventRegistration;
    error: Error;
    path: Path;
    constructor(eventRegistration: EventRegistration, error: Error, path: Path);
    getPath(): Path;
    getEventType(): string;
    getEventRunner(): () => void;
    toString(): string;
}

declare interface Change {
    
    type: ChangeType;
    
    snapshotNode: Node_2;
    
    childName?: string;
    
    oldSnap?: Node_2;
    
    prevName?: string | null;
}

declare const enum ChangeType {
    
    CHILD_ADDED = "child_added",
    
    CHILD_REMOVED = "child_removed",
    
    CHILD_CHANGED = "child_changed",
    
    CHILD_MOVED = "child_moved",
    
    VALUE = "value"
}


export declare function child(parent: DatabaseReference, path: string): DatabaseReference;

declare class ChildChangeAccumulator {
    private readonly changeMap;
    trackChildChange(change: Change): void;
    getChanges(): Change[];
}



declare type Comparator<K> = (key1: K, key2: K) => number;


declare interface CompleteChildSource {
    getCompleteChild(childKey: string): Node_2 | null;
    getChildAfterChild(index: Index, child: NamedNode, reverse: boolean): NamedNode | null;
}


declare class CompoundWrite {
    writeTree_: ImmutableTree<Node_2>;
    constructor(writeTree_: ImmutableTree<Node_2>);
    static empty(): CompoundWrite;
}


export declare function connectDatabaseEmulator(db: Database, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;


export declare class Database implements _FirebaseService {
    _repoInternal: Repo;
    
    readonly app: FirebaseApp;
    
    readonly 'type' = "database";
    
    _instanceStarted: boolean;
    
    private _rootInternal?;
    
    constructor(_repoInternal: Repo, 
    
    app: FirebaseApp);
    get _repo(): Repo;
    get _root(): _ReferenceImpl;
    _delete(): Promise<void>;
    _checkNotDeleted(apiName: string): void;
}


export declare interface DatabaseReference extends Query {
    
    readonly key: string | null;
    
    readonly parent: DatabaseReference | null;
    
    readonly root: DatabaseReference;
}


export declare class DataSnapshot {
    readonly _node: Node_2;
    
    readonly ref: DatabaseReference;
    readonly _index: Index;
    
    constructor(_node: Node_2, 
    
    ref: DatabaseReference, _index: Index);
    
    get priority(): string | number | null;
    
    get key(): string | null;
    
    get size(): number;
    
    child(path: string): DataSnapshot;
    
    exists(): boolean;
    
    exportVal(): any;
    
    forEach(action: (child: IteratedDataSnapshot) => boolean | void): boolean;
    
    hasChild(path: string): boolean;
    
    hasChildren(): boolean;
    
    toJSON(): object | null;
    
    val(): any;
}
export { EmulatorMockTokenOptions }


export declare function enableLogging(enabled: boolean, persistent?: boolean): any;


export declare function enableLogging(logger: (message: string) => unknown): any;


export declare function endAt(value: number | string | boolean | null, key?: string): QueryConstraint;


export declare function endBefore(value: number | string | boolean | null, key?: string): QueryConstraint;


export declare function equalTo(value: number | string | boolean | null, key?: string): QueryConstraint;


declare interface Event_2 {
    getPath(): Path;
    getEventType(): string;
    getEventRunner(): () => void;
    toString(): string;
}


declare class EventGenerator {
    query_: QueryContext;
    index_: Index;
    constructor(query_: QueryContext);
}

declare interface EventList {
    events: Event_2[];
    path: Path;
}


declare class EventQueue {
    eventLists_: EventList[];
    
    recursionDepth_: number;
}


declare interface EventRegistration {
    
    respondsTo(eventType: string): boolean;
    createEvent(change: Change, query: QueryContext): Event_2;
    
    getEventRunner(eventData: Event_2): () => void;
    createCancelEvent(error: Error, path: Path): CancelEvent | null;
    matches(other: EventRegistration): boolean;
    
    hasAnyCallback(): boolean;
}


export declare type EventType = 'value' | 'child_added' | 'child_changed' | 'child_moved' | 'child_removed';


export declare function forceLongPolling(): void;


export declare function forceWebSockets(): void;


export declare function get(query: Query): Promise<DataSnapshot>;


export declare function getDatabase(app?: FirebaseApp, url?: string): Database;


export declare function goOffline(db: Database): void;


export declare function goOnline(db: Database): void;


declare class ImmutableTree<T> {
    readonly value: T | null;
    readonly children: SortedMap<string, ImmutableTree<T>>;
    static fromObject<T>(obj: {
        [k: string]: T;
    }): ImmutableTree<T>;
    constructor(value: T | null, children?: SortedMap<string, ImmutableTree<T>>);
    
    isEmpty(): boolean;
    
    findRootMostMatchingPathAndValue(relativePath: Path, predicate: (a: T) => boolean): {
        path: Path;
        value: T;
    } | null;
    
    findRootMostValueAndPath(relativePath: Path): {
        path: Path;
        value: T;
    } | null;
    
    subtree(relativePath: Path): ImmutableTree<T>;
    
    set(relativePath: Path, toSet: T | null): ImmutableTree<T>;
    
    remove(relativePath: Path): ImmutableTree<T>;
    
    get(relativePath: Path): T | null;
    
    setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T>;
    
    fold<V>(fn: (path: Path, value: T, children: {
        [k: string]: V;
    }) => V): V;
    
    private fold_;
    
    findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null;
    private findOnPath_;
    foreachOnPath(path: Path, f: (path: Path, value: T) => void): ImmutableTree<T>;
    private foreachOnPath_;
    
    foreach(f: (path: Path, value: T) => void): void;
    private foreach_;
    foreachChild(f: (name: string, value: T) => void): void;
}


export declare function increment(delta: number): object;

declare abstract class Index {
    abstract compare(a: NamedNode, b: NamedNode): number;
    abstract isDefinedOn(node: Node_2): boolean;
    
    getCompare(): Comparator<NamedNode>;
    
    indexedValueChanged(oldNode: Node_2, newNode: Node_2): boolean;
    
    minPost(): NamedNode;
    
    abstract maxPost(): NamedNode;
    abstract makePost(indexValue: unknown, name: string): NamedNode;
    
    abstract toString(): string;
}


export declare function _initStandalone({ app, url, version, customAuthImpl, customAppCheckImpl, nodeAdmin }: {
    app: FirebaseApp_2;
    url: string;
    version: string;
    customAuthImpl: FirebaseAuthInternal;
    customAppCheckImpl?: FirebaseAppCheckInternal;
    nodeAdmin?: boolean;
}): Database;


export declare interface IteratedDataSnapshot extends DataSnapshot {
    key: string;
}


export declare function limitToFirst(limit: number): QueryConstraint;


export declare function limitToLast(limit: number): QueryConstraint;


export declare interface ListenOptions {
    
    readonly onlyOnce?: boolean;
}

declare interface ListenProvider {
    startListening(query: QueryContext, tag: number | null, hashFn: () => string, onComplete: (a: string, b?: unknown) => Event_2[]): Event_2[];
    stopListening(a: QueryContext, b: number | null): void;
}


declare class LLRBEmptyNode<K, V> {
    key: K;
    value: V;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    color: boolean;
    
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBEmptyNode<K, V>;
    
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    
    remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V>;
    
    count(): number;
    
    isEmpty(): boolean;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    minKey(): null;
    maxKey(): null;
    check_(): number;
    
    isRed_(): boolean;
}


declare class LLRBNode<K, V> {
    key: K;
    value: V;
    color: boolean;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    
    constructor(key: K, value: V, color: boolean | null, left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null);
    static RED: boolean;
    static BLACK: boolean;
    
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBNode<K, V>;
    
    count(): number;
    
    isEmpty(): boolean;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    
    private min_;
    
    minKey(): K;
    
    maxKey(): K;
    
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    
    private removeMin_;
    
    remove(key: K, comparator: Comparator<K>): LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    
    isRed_(): boolean;
    
    private fixUp_;
    
    private moveRedLeft_;
    
    private moveRedRight_;
    
    private rotateLeft_;
    
    private rotateRight_;
    
    private colorFlip_;
    
    private checkMaxDepth_;
    check_(): number;
}

declare class NamedNode {
    name: string;
    node: Node_2;
    constructor(name: string, node: Node_2);
    static Wrap(name: string, node: Node_2): NamedNode;
}


declare interface Node_2 {
    
    isLeafNode(): boolean;
    
    getPriority(): Node_2;
    
    updatePriority(newPriorityNode: Node_2): Node_2;
    
    getImmediateChild(childName: string): Node_2;
    
    getChild(path: Path): Node_2;
    
    getPredecessorChildName(childName: string, childNode: Node_2, index: Index): string | null;
    
    updateImmediateChild(childName: string, newChildNode: Node_2): Node_2;
    
    updateChild(path: Path, newChildNode: Node_2): Node_2;
    
    hasChild(childName: string): boolean;
    
    isEmpty(): boolean;
    
    numChildren(): number;
    
    forEachChild(index: Index, action: (a: string, b: Node_2) => void): unknown;
    
    val(exportFormat?: boolean): unknown;
    
    hash(): string;
    
    compareTo(other: Node_2): number;
    
    equals(other: Node_2): boolean;
    
    withIndex(indexDefinition: Index): Node_2;
    isIndexed(indexDefinition: Index): boolean;
}


declare interface NodeFilter_2 {
    
    updateChild(snap: Node_2, key: string, newChild: Node_2, affectedPath: Path, source: CompleteChildSource, optChangeAccumulator: ChildChangeAccumulator | null): Node_2;
    
    updateFullNode(oldSnap: Node_2, newSnap: Node_2, optChangeAccumulator: ChildChangeAccumulator | null): Node_2;
    
    updatePriority(oldSnap: Node_2, newPriority: Node_2): Node_2;
    
    filtersNodes(): boolean;
    
    getIndexedFilter(): NodeFilter_2;
    
    getIndex(): Index;
}


export declare function off(query: Query, eventType?: EventType, callback?: (snapshot: DataSnapshot, previousChildName?: string | null) => unknown): void;


export declare function onChildAdded(query: Query, callback: (snapshot: DataSnapshot, previousChildName?: string | null) => unknown, cancelCallback?: (error: Error) => unknown): Unsubscribe;


export declare function onChildAdded(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildAdded(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, cancelCallback: (error: Error) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildChanged(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, cancelCallback?: (error: Error) => unknown): Unsubscribe;


export declare function onChildChanged(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildChanged(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, cancelCallback: (error: Error) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildMoved(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, cancelCallback?: (error: Error) => unknown): Unsubscribe;


export declare function onChildMoved(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildMoved(query: Query, callback: (snapshot: DataSnapshot, previousChildName: string | null) => unknown, cancelCallback: (error: Error) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildRemoved(query: Query, callback: (snapshot: DataSnapshot) => unknown, cancelCallback?: (error: Error) => unknown): Unsubscribe;


export declare function onChildRemoved(query: Query, callback: (snapshot: DataSnapshot) => unknown, options: ListenOptions): Unsubscribe;


export declare function onChildRemoved(query: Query, callback: (snapshot: DataSnapshot) => unknown, cancelCallback: (error: Error) => unknown, options: ListenOptions): Unsubscribe;


export declare class OnDisconnect {
    private _repo;
    private _path;
    
    constructor(_repo: Repo, _path: Path);
    
    cancel(): Promise<void>;
    
    remove(): Promise<void>;
    
    set(value: unknown): Promise<void>;
    
    setWithPriority(value: unknown, priority: number | string | null): Promise<void>;
    
    update(values: object): Promise<void>;
}


export declare function onDisconnect(ref: DatabaseReference): OnDisconnect;


export declare function onValue(query: Query, callback: (snapshot: DataSnapshot) => unknown, cancelCallback?: (error: Error) => unknown): Unsubscribe;


export declare function onValue(query: Query, callback: (snapshot: DataSnapshot) => unknown, options: ListenOptions): Unsubscribe;


export declare function onValue(query: Query, callback: (snapshot: DataSnapshot) => unknown, cancelCallback: (error: Error) => unknown, options: ListenOptions): Unsubscribe;


export declare function orderByChild(path: string): QueryConstraint;


export declare function orderByKey(): QueryConstraint;


export declare function orderByPriority(): QueryConstraint;


export declare function orderByValue(): QueryConstraint;



declare class Path {
    pieces_: string[];
    pieceNum_: number;
    
    constructor(pathOrString: string | string[], pieceNum?: number);
    toString(): string;
}


declare class PersistentConnection extends ServerActions {
    private repoInfo_;
    private applicationId_;
    private onDataUpdate_;
    private onConnectStatus_;
    private onServerInfoUpdate_;
    private authTokenProvider_;
    private appCheckTokenProvider_;
    private authOverride_?;
    id: number;
    private log_;
    private interruptReasons_;
    private readonly listens;
    private outstandingPuts_;
    private outstandingGets_;
    private outstandingPutCount_;
    private outstandingGetCount_;
    private onDisconnectRequestQueue_;
    private connected_;
    private reconnectDelay_;
    private maxReconnectDelay_;
    private securityDebugCallback_;
    lastSessionId: string | null;
    private establishConnectionTimer_;
    private visible_;
    private requestCBHash_;
    private requestNumber_;
    private realtime_;
    private authToken_;
    private appCheckToken_;
    private forceTokenRefresh_;
    private invalidAuthTokenCount_;
    private invalidAppCheckTokenCount_;
    private firstConnection_;
    private lastConnectionAttemptTime_;
    private lastConnectionEstablishedTime_;
    private static nextPersistentConnectionId_;
    
    private static nextConnectionId_;
    
    constructor(repoInfo_: RepoInfo, applicationId_: string, onDataUpdate_: (a: string, b: unknown, c: boolean, d: number | null) => void, onConnectStatus_: (a: boolean) => void, onServerInfoUpdate_: (a: unknown) => void, authTokenProvider_: AuthTokenProvider, appCheckTokenProvider_: AppCheckTokenProvider, authOverride_?: object | null);
    protected sendRequest(action: string, body: unknown, onResponse?: (a: unknown) => void): void;
    get(query: QueryContext): Promise<string>;
    listen(query: QueryContext, currentHashFn: () => string, tag: number | null, onComplete: (a: string, b: unknown) => void): void;
    private sendGet_;
    private sendListen_;
    private static warnOnListenWarnings_;
    refreshAuthToken(token: string): void;
    private reduceReconnectDelayIfAdminCredential_;
    refreshAppCheckToken(token: string | null): void;
    
    tryAuth(): void;
    
    tryAppCheck(): void;
    
    unlisten(query: QueryContext, tag: number | null): void;
    private sendUnlisten_;
    onDisconnectPut(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void): void;
    onDisconnectMerge(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void): void;
    onDisconnectCancel(pathString: string, onComplete?: (a: string, b: string) => void): void;
    private sendOnDisconnect_;
    put(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void, hash?: string): void;
    merge(pathString: string, data: unknown, onComplete: (a: string, b: string | null) => void, hash?: string): void;
    putInternal(action: string, pathString: string, data: unknown, onComplete: (a: string, b: string | null) => void, hash?: string): void;
    private sendPut_;
    reportStats(stats: {
        [k: string]: unknown;
    }): void;
    private onDataMessage_;
    private onDataPush_;
    private onReady_;
    private scheduleConnect_;
    private initConnection_;
    private onVisible_;
    private onOnline_;
    private onRealtimeDisconnect_;
    private establishConnection_;
    interrupt(reason: string): void;
    resume(reason: string): void;
    private handleTimestamp_;
    private cancelSentTransactions_;
    private onListenRevoked_;
    private removeListen_;
    private onAuthRevoked_;
    private onAppCheckRevoked_;
    private onSecurityDebugPacket_;
    private restoreState_;
    
    private sendConnectStats_;
    private shouldReconnect_;
}

declare class PriorityIndex extends Index {
    compare(a: NamedNode, b: NamedNode): number;
    isDefinedOn(node: Node_2): boolean;
    indexedValueChanged(oldNode: Node_2, newNode: Node_2): boolean;
    minPost(): NamedNode;
    maxPost(): NamedNode;
    makePost(indexValue: unknown, name: string): NamedNode;
    
    toString(): string;
}


export declare function push(parent: DatabaseReference, value?: unknown): ThenableReference;



export declare interface Query extends QueryContext {
    
    readonly ref: DatabaseReference;
    
    isEqual(other: Query | null): boolean;
    
    toJSON(): string;
    
    toString(): string;
}


export declare function query(query: Query, ...queryConstraints: QueryConstraint[]): Query;


export declare abstract class QueryConstraint {
    
    abstract readonly type: QueryConstraintType;
    
    abstract _apply<T>(query: _QueryImpl): _QueryImpl;
}


export declare type QueryConstraintType = 'endAt' | 'endBefore' | 'startAt' | 'startAfter' | 'limitToFirst' | 'limitToLast' | 'orderByChild' | 'orderByKey' | 'orderByPriority' | 'orderByValue' | 'equalTo';

declare interface QueryContext {
    readonly _queryIdentifier: string;
    readonly _queryObject: object;
    readonly _repo: Repo;
    readonly _path: Path;
    readonly _queryParams: _QueryParams;
}


export declare class _QueryImpl implements Query, QueryContext {
    readonly _repo: Repo;
    readonly _path: Path;
    readonly _queryParams: _QueryParams;
    readonly _orderByCalled: boolean;
    
    constructor(_repo: Repo, _path: Path, _queryParams: _QueryParams, _orderByCalled: boolean);
    get key(): string | null;
    get ref(): DatabaseReference;
    get _queryIdentifier(): string;
    
    get _queryObject(): object;
    isEqual(other: _QueryImpl | null): boolean;
    toJSON(): string;
    toString(): string;
}


export declare class _QueryParams {
    limitSet_: boolean;
    startSet_: boolean;
    startNameSet_: boolean;
    startAfterSet_: boolean;
    endSet_: boolean;
    endNameSet_: boolean;
    endBeforeSet_: boolean;
    limit_: number;
    viewFrom_: string;
    indexStartValue_: unknown | null;
    indexStartName_: string;
    indexEndValue_: unknown | null;
    indexEndName_: string;
    index_: PriorityIndex;
    hasStart(): boolean;
    
    isViewFromLeft(): boolean;
    
    getIndexStartValue(): unknown;
    
    getIndexStartName(): string;
    hasEnd(): boolean;
    
    getIndexEndValue(): unknown;
    
    getIndexEndName(): string;
    hasLimit(): boolean;
    
    hasAnchoredLimit(): boolean;
    
    getLimit(): number;
    getIndex(): Index;
    loadsAllData(): boolean;
    isDefault(): boolean;
    copy(): _QueryParams;
}


export declare function ref(db: Database, path?: string): DatabaseReference;


export declare class _ReferenceImpl extends _QueryImpl implements DatabaseReference {
    
    constructor(repo: Repo, path: Path);
    get parent(): _ReferenceImpl | null;
    get root(): _ReferenceImpl;
}


export declare function refFromURL(db: Database, url: string): DatabaseReference;


export declare function remove(ref: DatabaseReference): Promise<void>;


declare class Repo {
    repoInfo_: RepoInfo;
    forceRestClient_: boolean;
    authTokenProvider_: AuthTokenProvider;
    appCheckProvider_: AppCheckTokenProvider;
    
    readonly key: string;
    dataUpdateCount: number;
    infoSyncTree_: SyncTree;
    serverSyncTree_: SyncTree;
    stats_: StatsCollection;
    statsListener_: StatsListener | null;
    eventQueue_: EventQueue;
    nextWriteId_: number;
    server_: ServerActions;
    statsReporter_: StatsReporter;
    infoData_: SnapshotHolder;
    interceptServerDataCallback_: ((a: string, b: unknown) => void) | null;
    
    onDisconnect_: SparseSnapshotTree;
    
    transactionQueueTree_: Tree<Transaction[]>;
    persistentConnection_: PersistentConnection | null;
    constructor(repoInfo_: RepoInfo, forceRestClient_: boolean, authTokenProvider_: AuthTokenProvider, appCheckProvider_: AppCheckTokenProvider);
    
    toString(): string;
}


declare class RepoInfo {
    readonly secure: boolean;
    readonly namespace: string;
    readonly webSocketOnly: boolean;
    readonly nodeAdmin: boolean;
    readonly persistenceKey: string;
    readonly includeNamespaceInQueryParams: boolean;
    readonly isUsingEmulator: boolean;
    readonly emulatorOptions: RepoInfoEmulatorOptions | null;
    private _host;
    private _domain;
    internalHost: string;
    
    constructor(host: string, secure: boolean, namespace: string, webSocketOnly: boolean, nodeAdmin?: boolean, persistenceKey?: string, includeNamespaceInQueryParams?: boolean, isUsingEmulator?: boolean, emulatorOptions?: RepoInfoEmulatorOptions | null);
    isCacheableHost(): boolean;
    isCustomHost(): boolean;
    get host(): string;
    set host(newHost: string);
    toString(): string;
    toURLString(): string;
}

declare interface RepoInfoEmulatorOptions {
    mockUserToken?: string | EmulatorMockTokenOptions;
}


export declare function _repoManagerDatabaseFromApp(app: FirebaseApp, authProvider: Provider<FirebaseAuthInternalName>, appCheckProvider?: Provider<AppCheckInternalComponentName>, url?: string, nodeAdmin?: boolean): Database;


export declare function runTransaction(ref: DatabaseReference, transactionUpdate: (currentData: any) => unknown, options?: TransactionOptions): Promise<TransactionResult>;


declare abstract class ServerActions {
    abstract listen(query: QueryContext, currentHashFn: () => string, tag: number | null, onComplete: (a: string, b: unknown) => void): void;
    
    abstract unlisten(query: QueryContext, tag: number | null): void;
    
    abstract get(query: QueryContext): Promise<string>;
    put(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void, hash?: string): void;
    merge(pathString: string, data: unknown, onComplete: (a: string, b: string | null) => void, hash?: string): void;
    
    refreshAuthToken(token: string): void;
    
    refreshAppCheckToken(token: string): void;
    onDisconnectPut(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void): void;
    onDisconnectMerge(pathString: string, data: unknown, onComplete?: (a: string, b: string) => void): void;
    onDisconnectCancel(pathString: string, onComplete?: (a: string, b: string) => void): void;
    reportStats(stats: {
        [k: string]: unknown;
    }): void;
}



export declare function serverTimestamp(): object;


export declare function set(ref: DatabaseReference, value: unknown): Promise<void>;


export declare function setPriority(ref: DatabaseReference, priority: string | number | null): Promise<void>;


export declare function _setSDKVersion(version: string): void;


export declare function setWithPriority(ref: DatabaseReference, value: unknown, priority: string | number | null): Promise<void>;


declare class SnapshotHolder {
    private rootNode_;
    getNode(path: Path): Node_2;
    updateSnapshot(path: Path, newSnapshotNode: Node_2): void;
}


declare class SortedMap<K, V> {
    private comparator_;
    private root_;
    
    static EMPTY_NODE: LLRBEmptyNode<unknown, unknown>;
    
    constructor(comparator_: Comparator<K>, root_?: LLRBNode<K, V> | LLRBEmptyNode<K, V>);
    
    insert(key: K, value: V): SortedMap<K, V>;
    
    remove(key: K): SortedMap<K, V>;
    
    get(key: K): V | null;
    
    getPredecessorKey(key: K): K | null;
    
    isEmpty(): boolean;
    
    count(): number;
    
    minKey(): K | null;
    
    maxKey(): K | null;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    
    getIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
}


declare class SortedMapIterator<K, V, T> {
    private isReverse_;
    private resultGenerator_;
    private nodeStack_;
    
    constructor(node: LLRBNode<K, V> | LLRBEmptyNode<K, V>, startKey: K | null, comparator: Comparator<K>, isReverse_: boolean, resultGenerator_?: ((k: K, v: V) => T) | null);
    getNext(): T;
    hasNext(): boolean;
    peek(): T;
}


declare interface SparseSnapshotTree {
    value: Node_2 | null;
    readonly children: Map<string, SparseSnapshotTree>;
}


export declare function startAfter(value: number | string | boolean | null, key?: string): QueryConstraint;


export declare function startAt(value?: number | string | boolean | null, key?: string): QueryConstraint;



declare class StatsCollection {
    private counters_;
    incrementCounter(name: string, amount?: number): void;
    get(): {
        [k: string]: number;
    };
}


declare class StatsListener {
    private collection_;
    private last_;
    constructor(collection_: StatsCollection);
    get(): {
        [k: string]: number;
    };
}

declare class StatsReporter {
    private server_;
    private statsListener_;
    statsToReport_: {
        [k: string]: boolean;
    };
    constructor(collection: StatsCollection, server_: ServerActions);
    private reportStats_;
}


declare class SyncPoint {
    
    readonly views: Map<string, View>;
}


declare class SyncTree {
    listenProvider_: ListenProvider;
    
    syncPointTree_: ImmutableTree<SyncPoint>;
    
    pendingWriteTree_: WriteTree;
    readonly tagToQueryMap: Map<number, string>;
    readonly queryToTagMap: Map<string, number>;
    
    constructor(listenProvider_: ListenProvider);
}


export declare const _TEST_ACCESS_forceRestClient: (forceRestClient: boolean) => void;


export declare const _TEST_ACCESS_hijackHash: (newHash: () => string) => () => void;


export declare interface ThenableReference extends DatabaseReference, Pick<Promise<DatabaseReference>, 'then' | 'catch'> {
    key: string;
    parent: DatabaseReference;
}

declare interface Transaction {
    path: Path;
    update: (a: unknown) => unknown;
    onComplete: (error: Error | null, committed: boolean, node: Node_2 | null) => void;
    status: TransactionStatus;
    order: number;
    applyLocally: boolean;
    retryCount: number;
    unwatcher: () => void;
    abortReason: string | null;
    currentWriteId: number;
    currentInputSnapshot: Node_2 | null;
    currentOutputSnapshotRaw: Node_2 | null;
    currentOutputSnapshotResolved: Node_2 | null;
}


export declare interface TransactionOptions {
    
    readonly applyLocally?: boolean;
}


export declare class TransactionResult {
    
    readonly committed: boolean;
    
    readonly snapshot: DataSnapshot;
    
    constructor(
    
    committed: boolean, 
    
    snapshot: DataSnapshot);
    
    toJSON(): object;
}

declare const enum TransactionStatus {
    RUN = 0,
    SENT = 1,
    COMPLETED = 2,
    SENT_NEEDS_ABORT = 3,
    NEEDS_ABORT = 4
}


declare class Tree<T> {
    readonly name: string;
    readonly parent: Tree<T> | null;
    node: TreeNode<T>;
    
    constructor(name?: string, parent?: Tree<T> | null, node?: TreeNode<T>);
}


declare interface TreeNode<T> {
    children: Record<string, TreeNode<T>>;
    childCount: number;
    value?: T;
}


export declare type Unsubscribe = () => void;


export declare function update(ref: DatabaseReference, values: object): Promise<void>;


export declare interface _UserCallback {
    (dataSnapshot: DataSnapshot, previousChildName?: string | null): unknown;
    userCallback?: unknown;
    context?: object | null;
}


export declare const _validatePathString: (fnName: string, argumentName: string, pathString: string, optional: boolean) => void;


export declare const _validateWritablePath: (fnName: string, path: Path) => void;


declare class View {
    private query_;
    processor_: ViewProcessor;
    viewCache_: ViewCache;
    eventRegistrations_: EventRegistration[];
    eventGenerator_: EventGenerator;
    constructor(query_: QueryContext, initialViewCache: ViewCache);
    get query(): QueryContext;
}


declare interface ViewCache {
    readonly eventCache: CacheNode;
    readonly serverCache: CacheNode;
}

declare interface ViewProcessor {
    readonly filter: NodeFilter_2;
}


declare interface WriteRecord {
    writeId: number;
    path: Path;
    snap?: Node_2 | null;
    children?: {
        [k: string]: Node_2;
    } | null;
    visible: boolean;
}


declare interface WriteTree {
    
    visibleWrites: CompoundWrite;
    
    allWrites: WriteRecord[];
    lastWriteId: number;
}

export { }
