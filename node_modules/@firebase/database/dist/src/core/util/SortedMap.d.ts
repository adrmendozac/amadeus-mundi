

export type Comparator<K> = (key1: K, key2: K) => number;

export declare class SortedMapIterator<K, V, T> {
    private isReverse_;
    private resultGenerator_;
    private nodeStack_;
    
    constructor(node: LLRBNode<K, V> | LLRBEmptyNode<K, V>, startKey: K | null, comparator: Comparator<K>, isReverse_: boolean, resultGenerator_?: ((k: K, v: V) => T) | null);
    getNext(): T;
    hasNext(): boolean;
    peek(): T;
}

export declare class LLRBNode<K, V> {
    key: K;
    value: V;
    color: boolean;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    
    constructor(key: K, value: V, color: boolean | null, left?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right?: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null);
    static RED: boolean;
    static BLACK: boolean;
    
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBNode<K, V>;
    
    count(): number;
    
    isEmpty(): boolean;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    
    private min_;
    
    minKey(): K;
    
    maxKey(): K;
    
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    
    private removeMin_;
    
    remove(key: K, comparator: Comparator<K>): LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    
    isRed_(): boolean;
    
    private fixUp_;
    
    private moveRedLeft_;
    
    private moveRedRight_;
    
    private rotateLeft_;
    
    private rotateRight_;
    
    private colorFlip_;
    
    private checkMaxDepth_;
    check_(): number;
}

export declare class LLRBEmptyNode<K, V> {
    key: K;
    value: V;
    left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    color: boolean;
    
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBEmptyNode<K, V>;
    
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    
    remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V>;
    
    count(): number;
    
    isEmpty(): boolean;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    minKey(): null;
    maxKey(): null;
    check_(): number;
    
    isRed_(): boolean;
}

export declare class SortedMap<K, V> {
    private comparator_;
    private root_;
    
    static EMPTY_NODE: LLRBEmptyNode<unknown, unknown>;
    
    constructor(comparator_: Comparator<K>, root_?: LLRBNode<K, V> | LLRBEmptyNode<K, V>);
    
    insert(key: K, value: V): SortedMap<K, V>;
    
    remove(key: K): SortedMap<K, V>;
    
    get(key: K): V | null;
    
    getPredecessorKey(key: K): K | null;
    
    isEmpty(): boolean;
    
    count(): number;
    
    minKey(): K | null;
    
    maxKey(): K | null;
    
    inorderTraversal(action: (k: K, v: V) => unknown): boolean;
    
    reverseTraversal(action: (k: K, v: V) => void): boolean;
    
    getIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIteratorFrom<T>(key: K, resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
    getReverseIterator<T>(resultGenerator?: (k: K, v: V) => T): SortedMapIterator<K, V, T>;
}
