
import { Path } from './Path';
import { SortedMap } from './SortedMap';

export declare class ImmutableTree<T> {
    readonly value: T | null;
    readonly children: SortedMap<string, ImmutableTree<T>>;
    static fromObject<T>(obj: {
        [k: string]: T;
    }): ImmutableTree<T>;
    constructor(value: T | null, children?: SortedMap<string, ImmutableTree<T>>);
    
    isEmpty(): boolean;
    
    findRootMostMatchingPathAndValue(relativePath: Path, predicate: (a: T) => boolean): {
        path: Path;
        value: T;
    } | null;
    
    findRootMostValueAndPath(relativePath: Path): {
        path: Path;
        value: T;
    } | null;
    
    subtree(relativePath: Path): ImmutableTree<T>;
    
    set(relativePath: Path, toSet: T | null): ImmutableTree<T>;
    
    remove(relativePath: Path): ImmutableTree<T>;
    
    get(relativePath: Path): T | null;
    
    setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T>;
    
    fold<V>(fn: (path: Path, value: T, children: {
        [k: string]: V;
    }) => V): V;
    
    private fold_;
    
    findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null;
    private findOnPath_;
    foreachOnPath(path: Path, f: (path: Path, value: T) => void): ImmutableTree<T>;
    private foreachOnPath_;
    
    foreach(f: (path: Path, value: T) => void): void;
    private foreach_;
    foreachChild(f: (name: string, value: T) => void): void;
}
