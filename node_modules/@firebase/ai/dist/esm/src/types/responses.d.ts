
import { Content, FunctionCall, InlineDataPart } from './content';
import { BlockReason, FinishReason, HarmCategory, HarmProbability, HarmSeverity, Modality } from './enums';

export interface GenerateContentResult {
    response: EnhancedGenerateContentResponse;
}

export interface GenerateContentStreamResult {
    stream: AsyncGenerator<EnhancedGenerateContentResponse>;
    response: Promise<EnhancedGenerateContentResponse>;
}

export interface EnhancedGenerateContentResponse extends GenerateContentResponse {
    
    text: () => string;
    
    inlineDataParts: () => InlineDataPart[] | undefined;
    
    functionCalls: () => FunctionCall[] | undefined;
    
    thoughtSummary: () => string | undefined;
}

export interface GenerateContentResponse {
    candidates?: GenerateContentCandidate[];
    promptFeedback?: PromptFeedback;
    usageMetadata?: UsageMetadata;
}

export interface UsageMetadata {
    promptTokenCount: number;
    candidatesTokenCount: number;
    
    thoughtsTokenCount?: number;
    totalTokenCount: number;
    
    toolUsePromptTokenCount?: number;
    promptTokensDetails?: ModalityTokenCount[];
    candidatesTokensDetails?: ModalityTokenCount[];
    
    toolUsePromptTokensDetails?: ModalityTokenCount[];
}

export interface ModalityTokenCount {
    
    modality: Modality;
    
    tokenCount: number;
}

export interface PromptFeedback {
    blockReason?: BlockReason;
    safetyRatings: SafetyRating[];
    
    blockReasonMessage?: string;
}

export interface GenerateContentCandidate {
    index: number;
    content: Content;
    finishReason?: FinishReason;
    finishMessage?: string;
    safetyRatings?: SafetyRating[];
    citationMetadata?: CitationMetadata;
    groundingMetadata?: GroundingMetadata;
    urlContextMetadata?: URLContextMetadata;
}

export interface CitationMetadata {
    citations: Citation[];
}

export interface Citation {
    startIndex?: number;
    endIndex?: number;
    uri?: string;
    license?: string;
    
    title?: string;
    
    publicationDate?: Date;
}

export interface GroundingMetadata {
    
    searchEntryPoint?: SearchEntrypoint;
    
    groundingChunks?: GroundingChunk[];
    
    groundingSupports?: GroundingSupport[];
    
    webSearchQueries?: string[];
    
    retrievalQueries?: string[];
}

export interface SearchEntrypoint {
    
    renderedContent?: string;
}

export interface GroundingChunk {
    
    web?: WebGroundingChunk;
}

export interface WebGroundingChunk {
    
    uri?: string;
    
    title?: string;
    
    domain?: string;
}

export interface GroundingSupport {
    
    segment?: Segment;
    
    groundingChunkIndices?: number[];
}

export interface Segment {
    
    partIndex: number;
    
    startIndex: number;
    
    endIndex: number;
    
    text: string;
}

export interface URLContextMetadata {
    
    urlMetadata: URLMetadata[];
}

export interface URLMetadata {
    
    retrievedUrl?: string;
    
    urlRetrievalStatus?: URLRetrievalStatus;
}

export declare const URLRetrievalStatus: {
    
    URL_RETRIEVAL_STATUS_UNSPECIFIED: string;
    
    URL_RETRIEVAL_STATUS_SUCCESS: string;
    
    URL_RETRIEVAL_STATUS_ERROR: string;
    
    URL_RETRIEVAL_STATUS_PAYWALL: string;
    
    URL_RETRIEVAL_STATUS_UNSAFE: string;
};

export type URLRetrievalStatus = (typeof URLRetrievalStatus)[keyof typeof URLRetrievalStatus];

export interface WebAttribution {
    uri: string;
    title: string;
}

export interface RetrievedContextAttribution {
    uri: string;
    title: string;
}

export interface Date {
    year: number;
    month: number;
    day: number;
}

export interface SafetyRating {
    category: HarmCategory;
    probability: HarmProbability;
    
    severity: HarmSeverity;
    
    probabilityScore: number;
    
    severityScore: number;
    blocked: boolean;
}

export interface CountTokensResponse {
    
    totalTokens: number;
    
    totalBillableCharacters?: number;
    
    promptTokensDetails?: ModalityTokenCount[];
}

export interface LiveServerContent {
    type: 'serverContent';
    
    modelTurn?: Content;
    
    turnComplete?: boolean;
    
    interrupted?: boolean;
}

export interface LiveServerToolCall {
    type: 'toolCall';
    
    functionCalls: FunctionCall[];
}

export interface LiveServerToolCallCancellation {
    type: 'toolCallCancellation';
    
    functionIds: string[];
}

export declare const LiveResponseType: {
    SERVER_CONTENT: string;
    TOOL_CALL: string;
    TOOL_CALL_CANCELLATION: string;
};

export type LiveResponseType = (typeof LiveResponseType)[keyof typeof LiveResponseType];
