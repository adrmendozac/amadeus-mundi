

import { AppCheckTokenResult } from '@firebase/app-check-interop-types';
import { FirebaseApp } from '@firebase/app';
import { FirebaseAuthTokenData } from '@firebase/auth-interop-types';
import { FirebaseError } from '@firebase/util';


export declare interface AI {
    
    app: FirebaseApp;
    
    backend: Backend;
    
    options?: AIOptions;
    
    location: string;
}


export declare class AIError extends FirebaseError {
    readonly code: AIErrorCode;
    readonly customErrorData?: CustomErrorData | undefined;
    
    constructor(code: AIErrorCode, message: string, customErrorData?: CustomErrorData | undefined);
}


export declare const AIErrorCode: {
    
    readonly ERROR: "error";
    
    readonly REQUEST_ERROR: "request-error";
    
    readonly RESPONSE_ERROR: "response-error";
    
    readonly FETCH_ERROR: "fetch-error";
    
    readonly SESSION_CLOSED: "session-closed";
    
    readonly INVALID_CONTENT: "invalid-content";
    
    readonly API_NOT_ENABLED: "api-not-enabled";
    
    readonly INVALID_SCHEMA: "invalid-schema";
    
    readonly NO_API_KEY: "no-api-key";
    
    readonly NO_APP_ID: "no-app-id";
    
    readonly NO_MODEL: "no-model";
    
    readonly NO_PROJECT_ID: "no-project-id";
    
    readonly PARSE_FAILED: "parse-failed";
    
    readonly UNSUPPORTED: "unsupported";
};


export declare type AIErrorCode = (typeof AIErrorCode)[keyof typeof AIErrorCode];


export declare abstract class AIModel {
    
    readonly model: string;
    
    _apiSettings: ApiSettings;
    
    protected constructor(ai: AI, modelName: string);
    
    static normalizeModelName(modelName: string, backendType: BackendType): string;
    
    private static normalizeGoogleAIModelName;
    
    private static normalizeVertexAIModelName;
}


export declare interface AIOptions {
    
    backend?: Backend;
    
    useLimitedUseAppCheckTokens?: boolean;
}


export declare class AnyOfSchema extends Schema {
    anyOf: TypedSchema[];
    constructor(schemaParams: SchemaParams & {
        anyOf: TypedSchema[];
    });
    
    toJSON(): SchemaRequest;
}

declare interface ApiSettings {
    apiKey: string;
    project: string;
    appId: string;
    automaticDataCollectionEnabled?: boolean;
    
    location: string;
    backend: Backend;
    getAuthToken?: () => Promise<FirebaseAuthTokenData | null>;
    getAppCheckToken?: () => Promise<AppCheckTokenResult>;
}


export declare class ArraySchema extends Schema {
    items: TypedSchema;
    constructor(schemaParams: SchemaParams, items: TypedSchema);
    
    toJSON(): SchemaRequest;
}


export declare interface AudioConversationController {
    
    stop: () => Promise<void>;
}


export declare abstract class Backend {
    
    readonly backendType: BackendType;
    
    protected constructor(type: BackendType);
}


export declare const BackendType: {
    
    readonly VERTEX_AI: "VERTEX_AI";
    
    readonly GOOGLE_AI: "GOOGLE_AI";
};


export declare type BackendType = (typeof BackendType)[keyof typeof BackendType];


export declare interface BaseParams {
    safetySettings?: SafetySetting[];
    generationConfig?: GenerationConfig;
}


export declare const BlockReason: {
    
    readonly SAFETY: "SAFETY";
    
    readonly OTHER: "OTHER";
    
    readonly BLOCKLIST: "BLOCKLIST";
    
    readonly PROHIBITED_CONTENT: "PROHIBITED_CONTENT";
};


export declare type BlockReason = (typeof BlockReason)[keyof typeof BlockReason];


export declare class BooleanSchema extends Schema {
    constructor(schemaParams?: SchemaParams);
}


export declare class ChatSession {
    model: string;
    private chromeAdapter?;
    params?: StartChatParams | undefined;
    requestOptions?: RequestOptions | undefined;
    private _apiSettings;
    private _history;
    private _sendPromise;
    constructor(apiSettings: ApiSettings, model: string, chromeAdapter?: ChromeAdapter | undefined, params?: StartChatParams | undefined, requestOptions?: RequestOptions | undefined);
    
    getHistory(): Promise<Content[]>;
    
    sendMessage(request: string | Array<string | Part>): Promise<GenerateContentResult>;
    
    sendMessageStream(request: string | Array<string | Part>): Promise<GenerateContentStreamResult>;
}


export declare interface ChromeAdapter {
    
    isAvailable(request: GenerateContentRequest): Promise<boolean>;
    
    generateContent(request: GenerateContentRequest): Promise<Response>;
    
    generateContentStream(request: GenerateContentRequest): Promise<Response>;
    
    countTokens(request: CountTokensRequest): Promise<Response>;
}


export declare interface Citation {
    startIndex?: number;
    endIndex?: number;
    uri?: string;
    license?: string;
    
    title?: string;
    
    publicationDate?: Date_2;
}


export declare interface CitationMetadata {
    citations: Citation[];
}


export declare interface CodeExecutionResult {
    
    outcome?: Outcome;
    
    output?: string;
}


export declare interface CodeExecutionResultPart {
    text?: never;
    inlineData?: never;
    functionCall?: never;
    functionResponse?: never;
    fileData: never;
    thought?: never;
    
    thoughtSignature?: never;
    executableCode?: never;
    codeExecutionResult?: CodeExecutionResult;
}


export declare interface CodeExecutionTool {
    
    codeExecution: {};
}


export declare interface Content {
    role: Role;
    parts: Part[];
}


export declare interface CountTokensRequest {
    contents: Content[];
    
    systemInstruction?: string | Part | Content;
    
    tools?: Tool[];
    
    generationConfig?: GenerationConfig;
}


export declare interface CountTokensResponse {
    
    totalTokens: number;
    
    totalBillableCharacters?: number;
    
    promptTokensDetails?: ModalityTokenCount[];
}


export declare interface CustomErrorData {
    
    status?: number;
    
    statusText?: string;
    
    response?: GenerateContentResponse;
    
    errorDetails?: ErrorDetails[];
}


declare interface Date_2 {
    year: number;
    month: number;
    day: number;
}
export { Date_2 as Date }


export declare interface EnhancedGenerateContentResponse extends GenerateContentResponse {
    
    text: () => string;
    
    inlineDataParts: () => InlineDataPart[] | undefined;
    
    functionCalls: () => FunctionCall[] | undefined;
    
    thoughtSummary: () => string | undefined;
}


export declare interface ErrorDetails {
    '@type'?: string;
    
    reason?: string;
    
    domain?: string;
    
    metadata?: Record<string, unknown>;
    
    [key: string]: unknown;
}


export declare interface ExecutableCode {
    
    language?: Language;
    
    code?: string;
}


export declare interface ExecutableCodePart {
    text?: never;
    inlineData?: never;
    functionCall?: never;
    functionResponse?: never;
    fileData: never;
    thought?: never;
    
    thoughtSignature?: never;
    executableCode?: ExecutableCode;
    codeExecutionResult?: never;
}


export declare interface FileData {
    mimeType: string;
    fileUri: string;
}


export declare interface FileDataPart {
    text?: never;
    inlineData?: never;
    functionCall?: never;
    functionResponse?: never;
    fileData: FileData;
    thought?: boolean;
    
    thoughtSignature?: never;
    executableCode?: never;
    codeExecutionResult?: never;
}


export declare const FinishReason: {
    
    readonly STOP: "STOP";
    
    readonly MAX_TOKENS: "MAX_TOKENS";
    
    readonly SAFETY: "SAFETY";
    
    readonly RECITATION: "RECITATION";
    
    readonly OTHER: "OTHER";
    
    readonly BLOCKLIST: "BLOCKLIST";
    
    readonly PROHIBITED_CONTENT: "PROHIBITED_CONTENT";
    
    readonly SPII: "SPII";
    
    readonly MALFORMED_FUNCTION_CALL: "MALFORMED_FUNCTION_CALL";
};


export declare type FinishReason = (typeof FinishReason)[keyof typeof FinishReason];


export declare interface FunctionCall {
    
    id?: string;
    name: string;
    args: object;
}


export declare interface FunctionCallingConfig {
    mode?: FunctionCallingMode;
    allowedFunctionNames?: string[];
}


export declare const FunctionCallingMode: {
    
    readonly AUTO: "AUTO";
    
    readonly ANY: "ANY";
    
    readonly NONE: "NONE";
};


export declare type FunctionCallingMode = (typeof FunctionCallingMode)[keyof typeof FunctionCallingMode];


export declare interface FunctionCallPart {
    text?: never;
    inlineData?: never;
    functionCall: FunctionCall;
    functionResponse?: never;
    thought?: boolean;
    
    thoughtSignature?: never;
    executableCode?: never;
    codeExecutionResult?: never;
}


export declare interface FunctionDeclaration {
    
    name: string;
    
    description: string;
    
    parameters?: ObjectSchema | ObjectSchemaRequest;
}


export declare interface FunctionDeclarationsTool {
    
    functionDeclarations?: FunctionDeclaration[];
}


export declare interface FunctionResponse {
    
    id?: string;
    name: string;
    response: object;
}


export declare interface FunctionResponsePart {
    text?: never;
    inlineData?: never;
    functionCall?: never;
    functionResponse: FunctionResponse;
    thought?: boolean;
    
    thoughtSignature?: never;
    executableCode?: never;
    codeExecutionResult?: never;
}


export declare interface GenerateContentCandidate {
    index: number;
    content: Content;
    finishReason?: FinishReason;
    finishMessage?: string;
    safetyRatings?: SafetyRating[];
    citationMetadata?: CitationMetadata;
    groundingMetadata?: GroundingMetadata;
    urlContextMetadata?: URLContextMetadata;
}


export declare interface GenerateContentRequest extends BaseParams {
    contents: Content[];
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: string | Part | Content;
}


export declare interface GenerateContentResponse {
    candidates?: GenerateContentCandidate[];
    promptFeedback?: PromptFeedback;
    usageMetadata?: UsageMetadata;
}


export declare interface GenerateContentResult {
    response: EnhancedGenerateContentResponse;
}


export declare interface GenerateContentStreamResult {
    stream: AsyncGenerator<EnhancedGenerateContentResponse>;
    response: Promise<EnhancedGenerateContentResponse>;
}


export declare interface GenerationConfig {
    candidateCount?: number;
    stopSequences?: string[];
    maxOutputTokens?: number;
    temperature?: number;
    topP?: number;
    topK?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    
    responseMimeType?: string;
    
    responseSchema?: TypedSchema | SchemaRequest;
    
    responseModalities?: ResponseModality[];
    
    thinkingConfig?: ThinkingConfig;
}


export declare interface GenerativeContentBlob {
    mimeType: string;
    
    data: string;
}


export declare class GenerativeModel extends AIModel {
    private chromeAdapter?;
    generationConfig: GenerationConfig;
    safetySettings: SafetySetting[];
    requestOptions?: RequestOptions;
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: Content;
    constructor(ai: AI, modelParams: ModelParams, requestOptions?: RequestOptions, chromeAdapter?: ChromeAdapter | undefined);
    
    generateContent(request: GenerateContentRequest | string | Array<string | Part>): Promise<GenerateContentResult>;
    
    generateContentStream(request: GenerateContentRequest | string | Array<string | Part>): Promise<GenerateContentStreamResult>;
    
    startChat(startChatParams?: StartChatParams): ChatSession;
    
    countTokens(request: CountTokensRequest | string | Array<string | Part>): Promise<CountTokensResponse>;
}


export declare function getAI(app?: FirebaseApp, options?: AIOptions): AI;


export declare function getGenerativeModel(ai: AI, modelParams: ModelParams | HybridParams, requestOptions?: RequestOptions): GenerativeModel;


export declare function getImagenModel(ai: AI, modelParams: ImagenModelParams, requestOptions?: RequestOptions): ImagenModel;


export declare function getLiveGenerativeModel(ai: AI, modelParams: LiveModelParams): LiveGenerativeModel;


export declare class GoogleAIBackend extends Backend {
    
    constructor();
}


export declare interface GoogleAICitationMetadata {
    citationSources: Citation[];
}


export declare interface GoogleAICountTokensRequest {
    generateContentRequest: {
        model: string;
        contents: Content[];
        systemInstruction?: string | Part | Content;
        tools?: Tool[];
        generationConfig?: GenerationConfig;
    };
}


export declare interface GoogleAIGenerateContentCandidate {
    index: number;
    content: Content;
    finishReason?: FinishReason;
    finishMessage?: string;
    safetyRatings?: SafetyRating[];
    citationMetadata?: GoogleAICitationMetadata;
    groundingMetadata?: GroundingMetadata;
    urlContextMetadata?: URLContextMetadata;
}


export declare interface GoogleAIGenerateContentResponse {
    candidates?: GoogleAIGenerateContentCandidate[];
    promptFeedback?: PromptFeedback;
    usageMetadata?: UsageMetadata;
}


export declare interface GoogleSearch {
}


export declare interface GoogleSearchTool {
    
    googleSearch: GoogleSearch;
}


export declare interface GroundingChunk {
    
    web?: WebGroundingChunk;
}


export declare interface GroundingMetadata {
    
    searchEntryPoint?: SearchEntrypoint;
    
    groundingChunks?: GroundingChunk[];
    
    groundingSupports?: GroundingSupport[];
    
    webSearchQueries?: string[];
    
    retrievalQueries?: string[];
}


export declare interface GroundingSupport {
    
    segment?: Segment;
    
    groundingChunkIndices?: number[];
}


export declare const HarmBlockMethod: {
    
    readonly SEVERITY: "SEVERITY";
    
    readonly PROBABILITY: "PROBABILITY";
};


export declare type HarmBlockMethod = (typeof HarmBlockMethod)[keyof typeof HarmBlockMethod];


export declare const HarmBlockThreshold: {
    
    readonly BLOCK_LOW_AND_ABOVE: "BLOCK_LOW_AND_ABOVE";
    
    readonly BLOCK_MEDIUM_AND_ABOVE: "BLOCK_MEDIUM_AND_ABOVE";
    
    readonly BLOCK_ONLY_HIGH: "BLOCK_ONLY_HIGH";
    
    readonly BLOCK_NONE: "BLOCK_NONE";
    
    readonly OFF: "OFF";
};


export declare type HarmBlockThreshold = (typeof HarmBlockThreshold)[keyof typeof HarmBlockThreshold];


export declare const HarmCategory: {
    readonly HARM_CATEGORY_HATE_SPEECH: "HARM_CATEGORY_HATE_SPEECH";
    readonly HARM_CATEGORY_SEXUALLY_EXPLICIT: "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    readonly HARM_CATEGORY_HARASSMENT: "HARM_CATEGORY_HARASSMENT";
    readonly HARM_CATEGORY_DANGEROUS_CONTENT: "HARM_CATEGORY_DANGEROUS_CONTENT";
};


export declare type HarmCategory = (typeof HarmCategory)[keyof typeof HarmCategory];


export declare const HarmProbability: {
    
    readonly NEGLIGIBLE: "NEGLIGIBLE";
    
    readonly LOW: "LOW";
    
    readonly MEDIUM: "MEDIUM";
    
    readonly HIGH: "HIGH";
};


export declare type HarmProbability = (typeof HarmProbability)[keyof typeof HarmProbability];


export declare const HarmSeverity: {
    
    readonly HARM_SEVERITY_NEGLIGIBLE: "HARM_SEVERITY_NEGLIGIBLE";
    
    readonly HARM_SEVERITY_LOW: "HARM_SEVERITY_LOW";
    
    readonly HARM_SEVERITY_MEDIUM: "HARM_SEVERITY_MEDIUM";
    
    readonly HARM_SEVERITY_HIGH: "HARM_SEVERITY_HIGH";
    
    readonly HARM_SEVERITY_UNSUPPORTED: "HARM_SEVERITY_UNSUPPORTED";
};


export declare type HarmSeverity = (typeof HarmSeverity)[keyof typeof HarmSeverity];


export declare interface HybridParams {
    
    mode: InferenceMode;
    
    onDeviceParams?: OnDeviceParams;
    
    inCloudParams?: ModelParams;
}


export declare const ImagenAspectRatio: {
    
    readonly SQUARE: "1:1";
    
    readonly LANDSCAPE_3x4: "3:4";
    
    readonly PORTRAIT_4x3: "4:3";
    
    readonly LANDSCAPE_16x9: "16:9";
    
    readonly PORTRAIT_9x16: "9:16";
};


export declare type ImagenAspectRatio = (typeof ImagenAspectRatio)[keyof typeof ImagenAspectRatio];


export declare interface ImagenGCSImage {
    
    mimeType: string;
    
    gcsURI: string;
}


export declare interface ImagenGenerationConfig {
    
    negativePrompt?: string;
    
    numberOfImages?: number;
    
    aspectRatio?: ImagenAspectRatio;
    
    imageFormat?: ImagenImageFormat;
    
    addWatermark?: boolean;
}


export declare interface ImagenGenerationResponse<T extends ImagenInlineImage | ImagenGCSImage> {
    
    images: T[];
    
    filteredReason?: string;
}



export declare class ImagenImageFormat {
    
    mimeType: string;
    
    compressionQuality?: number;
    private constructor();
    
    static jpeg(compressionQuality?: number): ImagenImageFormat;
    
    static png(): ImagenImageFormat;
}



export declare interface ImagenInlineImage {
    
    mimeType: string;
    
    bytesBase64Encoded: string;
}


export declare class ImagenModel extends AIModel {
    requestOptions?: RequestOptions | undefined;
    
    generationConfig?: ImagenGenerationConfig;
    
    safetySettings?: ImagenSafetySettings;
    
    constructor(ai: AI, modelParams: ImagenModelParams, requestOptions?: RequestOptions | undefined);
    
    generateImages(prompt: string): Promise<ImagenGenerationResponse<ImagenInlineImage>>;
    
    generateImagesGCS(prompt: string, gcsURI: string): Promise<ImagenGenerationResponse<ImagenGCSImage>>;
}


export declare interface ImagenModelParams {
    
    model: string;
    
    generationConfig?: ImagenGenerationConfig;
    
    safetySettings?: ImagenSafetySettings;
}


export declare const ImagenPersonFilterLevel: {
    
    readonly BLOCK_ALL: "dont_allow";
    
    readonly ALLOW_ADULT: "allow_adult";
    
    readonly ALLOW_ALL: "allow_all";
};


export declare type ImagenPersonFilterLevel = (typeof ImagenPersonFilterLevel)[keyof typeof ImagenPersonFilterLevel];


export declare const ImagenSafetyFilterLevel: {
    
    readonly BLOCK_LOW_AND_ABOVE: "block_low_and_above";
    
    readonly BLOCK_MEDIUM_AND_ABOVE: "block_medium_and_above";
    
    readonly BLOCK_ONLY_HIGH: "block_only_high";
    
    readonly BLOCK_NONE: "block_none";
};


export declare type ImagenSafetyFilterLevel = (typeof ImagenSafetyFilterLevel)[keyof typeof ImagenSafetyFilterLevel];


export declare interface ImagenSafetySettings {
    
    safetyFilterLevel?: ImagenSafetyFilterLevel;
    
    personFilterLevel?: ImagenPersonFilterLevel;
}


export declare const InferenceMode: {
    readonly PREFER_ON_DEVICE: "prefer_on_device";
    readonly ONLY_ON_DEVICE: "only_on_device";
    readonly ONLY_IN_CLOUD: "only_in_cloud";
    readonly PREFER_IN_CLOUD: "prefer_in_cloud";
};


export declare type InferenceMode = (typeof InferenceMode)[keyof typeof InferenceMode];


export declare interface InlineDataPart {
    text?: never;
    inlineData: GenerativeContentBlob;
    functionCall?: never;
    functionResponse?: never;
    
    videoMetadata?: VideoMetadata;
    thought?: boolean;
    
    thoughtSignature?: never;
    executableCode?: never;
    codeExecutionResult?: never;
}


export declare class IntegerSchema extends Schema {
    constructor(schemaParams?: SchemaParams);
}


export declare const Language: {
    UNSPECIFIED: string;
    PYTHON: string;
};


export declare type Language = (typeof Language)[keyof typeof Language];


export declare interface LanguageModelCreateCoreOptions {
    topK?: number;
    temperature?: number;
    expectedInputs?: LanguageModelExpected[];
}


export declare interface LanguageModelCreateOptions extends LanguageModelCreateCoreOptions {
    signal?: AbortSignal;
    initialPrompts?: LanguageModelMessage[];
}

 export declare interface LanguageModelExpected {
    type: LanguageModelMessageType;
    languages?: string[];
}


export declare interface LanguageModelMessage {
    role: LanguageModelMessageRole;
    content: LanguageModelMessageContent[];
}


export declare interface LanguageModelMessageContent {
    type: LanguageModelMessageType;
    value: LanguageModelMessageContentValue;
}


export declare type LanguageModelMessageContentValue = ImageBitmapSource | AudioBuffer | BufferSource | string;


export declare type LanguageModelMessageRole = 'system' | 'user' | 'assistant';


export declare type LanguageModelMessageType = 'text' | 'image' | 'audio';


export declare interface LanguageModelPromptOptions {
    responseConstraint?: object;
}


export declare interface LiveGenerationConfig {
    
    speechConfig?: SpeechConfig;
    
    maxOutputTokens?: number;
    
    temperature?: number;
    
    topP?: number;
    
    topK?: number;
    
    presencePenalty?: number;
    
    frequencyPenalty?: number;
    
    responseModalities?: ResponseModality[];
}


export declare class LiveGenerativeModel extends AIModel {
    
    private _webSocketHandler;
    generationConfig: LiveGenerationConfig;
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: Content;
    
    constructor(ai: AI, modelParams: LiveModelParams, 
    
    _webSocketHandler: WebSocketHandler);
    
    connect(): Promise<LiveSession>;
}


export declare interface LiveModelParams {
    model: string;
    generationConfig?: LiveGenerationConfig;
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: string | Part | Content;
}


export declare const LiveResponseType: {
    SERVER_CONTENT: string;
    TOOL_CALL: string;
    TOOL_CALL_CANCELLATION: string;
};


export declare type LiveResponseType = (typeof LiveResponseType)[keyof typeof LiveResponseType];


export declare interface LiveServerContent {
    type: 'serverContent';
    
    modelTurn?: Content;
    
    turnComplete?: boolean;
    
    interrupted?: boolean;
}


export declare interface LiveServerToolCall {
    type: 'toolCall';
    
    functionCalls: FunctionCall[];
}


export declare interface LiveServerToolCallCancellation {
    type: 'toolCallCancellation';
    
    functionIds: string[];
}


export declare class LiveSession {
    private webSocketHandler;
    private serverMessages;
    
    isClosed: boolean;
    
    inConversation: boolean;
    
    constructor(webSocketHandler: WebSocketHandler, serverMessages: AsyncGenerator<unknown>);
    
    send(request: string | Array<string | Part>, turnComplete?: boolean): Promise<void>;
    
    sendMediaChunks(mediaChunks: GenerativeContentBlob[]): Promise<void>;
    
    sendFunctionResponses(functionResponses: FunctionResponse[]): Promise<void>;
    
    sendMediaStream(mediaChunkStream: ReadableStream<GenerativeContentBlob>): Promise<void>;
    
    receive(): AsyncGenerator<LiveServerContent | LiveServerToolCall | LiveServerToolCallCancellation>;
    
    close(): Promise<void>;
}


export declare const Modality: {
    
    readonly MODALITY_UNSPECIFIED: "MODALITY_UNSPECIFIED";
    
    readonly TEXT: "TEXT";
    
    readonly IMAGE: "IMAGE";
    
    readonly VIDEO: "VIDEO";
    
    readonly AUDIO: "AUDIO";
    
    readonly DOCUMENT: "DOCUMENT";
};


export declare type Modality = (typeof Modality)[keyof typeof Modality];


export declare interface ModalityTokenCount {
    
    modality: Modality;
    
    tokenCount: number;
}


export declare interface ModelParams extends BaseParams {
    model: string;
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: string | Part | Content;
}


export declare class NumberSchema extends Schema {
    constructor(schemaParams?: SchemaParams);
}


export declare class ObjectSchema extends Schema {
    properties: {
        [k: string]: TypedSchema;
    };
    optionalProperties: string[];
    constructor(schemaParams: SchemaParams, properties: {
        [k: string]: TypedSchema;
    }, optionalProperties?: string[]);
    
    toJSON(): SchemaRequest;
}


export declare interface ObjectSchemaRequest extends SchemaRequest {
    type: 'object';
    
    optionalProperties?: never;
}


export declare interface OnDeviceParams {
    createOptions?: LanguageModelCreateOptions;
    promptOptions?: LanguageModelPromptOptions;
}


export declare const Outcome: {
    UNSPECIFIED: string;
    OK: string;
    FAILED: string;
    DEADLINE_EXCEEDED: string;
};


export declare type Outcome = (typeof Outcome)[keyof typeof Outcome];


export declare type Part = TextPart | InlineDataPart | FunctionCallPart | FunctionResponsePart | FileDataPart | ExecutableCodePart | CodeExecutionResultPart;


export declare const POSSIBLE_ROLES: readonly ["user", "model", "function", "system"];


export declare interface PrebuiltVoiceConfig {
    
    voiceName?: string;
}


export declare interface PromptFeedback {
    blockReason?: BlockReason;
    safetyRatings: SafetyRating[];
    
    blockReasonMessage?: string;
}


export declare interface RequestOptions {
    
    timeout?: number;
    
    baseUrl?: string;
}


export declare const ResponseModality: {
    
    readonly TEXT: "TEXT";
    
    readonly IMAGE: "IMAGE";
    
    readonly AUDIO: "AUDIO";
};


export declare type ResponseModality = (typeof ResponseModality)[keyof typeof ResponseModality];


export declare interface RetrievedContextAttribution {
    uri: string;
    title: string;
}



export declare type Role = (typeof POSSIBLE_ROLES)[number];


export declare interface SafetyRating {
    category: HarmCategory;
    probability: HarmProbability;
    
    severity: HarmSeverity;
    
    probabilityScore: number;
    
    severityScore: number;
    blocked: boolean;
}


export declare interface SafetySetting {
    category: HarmCategory;
    threshold: HarmBlockThreshold;
    
    method?: HarmBlockMethod;
}


export declare abstract class Schema implements SchemaInterface {
    
    type?: SchemaType;
    
    format?: string;
    
    description?: string;
    
    items?: SchemaInterface;
    
    minItems?: number;
    
    maxItems?: number;
    
    nullable: boolean;
    
    example?: unknown;
    
    [key: string]: unknown;
    constructor(schemaParams: SchemaInterface);
    
    toJSON(): SchemaRequest;
    static array(arrayParams: SchemaParams & {
        items: Schema;
    }): ArraySchema;
    static object(objectParams: SchemaParams & {
        properties: {
            [k: string]: Schema;
        };
        optionalProperties?: string[];
    }): ObjectSchema;
    static string(stringParams?: SchemaParams): StringSchema;
    static enumString(stringParams: SchemaParams & {
        enum: string[];
    }): StringSchema;
    static integer(integerParams?: SchemaParams): IntegerSchema;
    static number(numberParams?: SchemaParams): NumberSchema;
    static boolean(booleanParams?: SchemaParams): BooleanSchema;
    static anyOf(anyOfParams: SchemaParams & {
        anyOf: TypedSchema[];
    }): AnyOfSchema;
}


export declare interface SchemaInterface extends SchemaShared<SchemaInterface> {
    
    type?: SchemaType;
}


export declare interface SchemaParams extends SchemaShared<SchemaInterface> {
}


export declare interface SchemaRequest extends SchemaShared<SchemaRequest> {
    
    type?: SchemaType;
    
    required?: string[];
}


export declare interface SchemaShared<T> {
    
    anyOf?: T[];
    
    format?: string;
    
    description?: string;
    
    title?: string;
    
    items?: T;
    
    minItems?: number;
    
    maxItems?: number;
    
    properties?: {
        [k: string]: T;
    };
    
    propertyOrdering?: string[];
    
    enum?: string[];
    
    example?: unknown;
    
    nullable?: boolean;
    
    minimum?: number;
    
    maximum?: number;
    [key: string]: unknown;
}


export declare const SchemaType: {
    
    readonly STRING: "string";
    
    readonly NUMBER: "number";
    
    readonly INTEGER: "integer";
    
    readonly BOOLEAN: "boolean";
    
    readonly ARRAY: "array";
    
    readonly OBJECT: "object";
};


export declare type SchemaType = (typeof SchemaType)[keyof typeof SchemaType];


export declare interface SearchEntrypoint {
    
    renderedContent?: string;
}


export declare interface Segment {
    
    partIndex: number;
    
    startIndex: number;
    
    endIndex: number;
    
    text: string;
}


export declare interface SpeechConfig {
    
    voiceConfig?: VoiceConfig;
}


export declare function startAudioConversation(liveSession: LiveSession, options?: StartAudioConversationOptions): Promise<AudioConversationController>;


export declare interface StartAudioConversationOptions {
    
    functionCallingHandler?: (functionCalls: FunctionCall[]) => Promise<FunctionResponse>;
}


export declare interface StartChatParams extends BaseParams {
    history?: Content[];
    tools?: Tool[];
    toolConfig?: ToolConfig;
    systemInstruction?: string | Part | Content;
}


export declare class StringSchema extends Schema {
    enum?: string[];
    constructor(schemaParams?: SchemaParams, enumValues?: string[]);
    
    toJSON(): SchemaRequest;
}


export declare interface TextPart {
    text: string;
    inlineData?: never;
    functionCall?: never;
    functionResponse?: never;
    thought?: boolean;
    
    thoughtSignature?: string;
    executableCode?: never;
    codeExecutionResult?: never;
}


export declare interface ThinkingConfig {
    
    thinkingBudget?: number;
    
    includeThoughts?: boolean;
}


export declare type Tool = FunctionDeclarationsTool | GoogleSearchTool | CodeExecutionTool | URLContextTool;


export declare interface ToolConfig {
    functionCallingConfig?: FunctionCallingConfig;
}


export declare type TypedSchema = IntegerSchema | NumberSchema | StringSchema | BooleanSchema | ObjectSchema | ArraySchema | AnyOfSchema;


export declare interface URLContext {
}


export declare interface URLContextMetadata {
    
    urlMetadata: URLMetadata[];
}


export declare interface URLContextTool {
    
    urlContext: URLContext;
}


export declare interface URLMetadata {
    
    retrievedUrl?: string;
    
    urlRetrievalStatus?: URLRetrievalStatus;
}


export declare const URLRetrievalStatus: {
    
    URL_RETRIEVAL_STATUS_UNSPECIFIED: string;
    
    URL_RETRIEVAL_STATUS_SUCCESS: string;
    
    URL_RETRIEVAL_STATUS_ERROR: string;
    
    URL_RETRIEVAL_STATUS_PAYWALL: string;
    
    URL_RETRIEVAL_STATUS_UNSAFE: string;
};


export declare type URLRetrievalStatus = (typeof URLRetrievalStatus)[keyof typeof URLRetrievalStatus];


export declare interface UsageMetadata {
    promptTokenCount: number;
    candidatesTokenCount: number;
    
    thoughtsTokenCount?: number;
    totalTokenCount: number;
    
    toolUsePromptTokenCount?: number;
    promptTokensDetails?: ModalityTokenCount[];
    candidatesTokensDetails?: ModalityTokenCount[];
    
    toolUsePromptTokensDetails?: ModalityTokenCount[];
}


export declare class VertexAIBackend extends Backend {
    
    readonly location: string;
    
    constructor(location?: string);
}


export declare interface VideoMetadata {
    
    startOffset: string;
    
    endOffset: string;
}


export declare interface VoiceConfig {
    
    prebuiltVoiceConfig?: PrebuiltVoiceConfig;
}


export declare interface WebAttribution {
    uri: string;
    title: string;
}


export declare interface WebGroundingChunk {
    
    uri?: string;
    
    title?: string;
    
    domain?: string;
}



declare interface WebSocketHandler {
    
    connect(url: string): Promise<void>;
    
    send(data: string | ArrayBuffer): void;
    
    listen(): AsyncGenerator<unknown>;
    
    close(code?: number, reason?: string): Promise<void>;
}

export { }
