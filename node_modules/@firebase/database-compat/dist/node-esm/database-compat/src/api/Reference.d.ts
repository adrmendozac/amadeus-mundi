
import { DataSnapshot as ModularDataSnapshot, Query as ExpQuery, DatabaseReference as ModularReference } from '@firebase/database';
import { Compat } from '@firebase/util';
import { Database } from './Database';
import { OnDisconnect } from './onDisconnect';
import { TransactionResult } from './TransactionResult';

export declare class DataSnapshot implements Compat<ModularDataSnapshot> {
    readonly _database: Database;
    readonly _delegate: ModularDataSnapshot;
    constructor(_database: Database, _delegate: ModularDataSnapshot);
    
    val(): unknown;
    
    exportVal(): unknown;
    toJSON(): unknown;
    
    exists(): boolean;
    
    child(path: string): DataSnapshot;
    
    hasChild(path: string): boolean;
    
    getPriority(): string | number | null;
    
    forEach(action: (snapshot: IteratedDataSnapshot) => boolean | void): boolean;
    
    hasChildren(): boolean;
    get key(): string;
    
    numChildren(): number;
    
    getRef(): Reference;
    get ref(): Reference;
}

export interface IteratedDataSnapshot extends DataSnapshot {
    key: string;
}
export interface SnapshotCallback {
    (dataSnapshot: DataSnapshot, previousChildName?: string | null): unknown;
}

export declare class Query implements Compat<ExpQuery> {
    readonly database: Database;
    readonly _delegate: ExpQuery;
    constructor(database: Database, _delegate: ExpQuery);
    on(eventType: string, callback: SnapshotCallback, cancelCallbackOrContext?: ((a: Error) => unknown) | object | null, context?: object | null): SnapshotCallback;
    off(eventType?: string, callback?: SnapshotCallback, context?: object | null): void;
    
    get(): Promise<DataSnapshot>;
    
    once(eventType: string, callback?: SnapshotCallback, failureCallbackOrContext?: ((a: Error) => void) | object | null, context?: object | null): Promise<DataSnapshot>;
    
    limitToFirst(limit: number): Query;
    
    limitToLast(limit: number): Query;
    
    orderByChild(path: string): Query;
    
    orderByKey(): Query;
    
    orderByPriority(): Query;
    
    orderByValue(): Query;
    startAt(value?: number | string | boolean | null, name?: string | null): Query;
    startAfter(value?: number | string | boolean | null, name?: string | null): Query;
    endAt(value?: number | string | boolean | null, name?: string | null): Query;
    endBefore(value?: number | string | boolean | null, name?: string | null): Query;
    
    equalTo(value: number | string | boolean | null, name?: string): Query;
    
    toString(): string;
    toJSON(): string;
    
    isEqual(other: Query): boolean;
    
    private static getCancelAndContextArgs_;
    get ref(): Reference;
}
export declare class Reference extends Query implements Compat<ModularReference> {
    readonly database: Database;
    readonly _delegate: ModularReference;
    then: Promise<Reference>['then'];
    catch: Promise<Reference>['catch'];
    
    constructor(database: Database, _delegate: ModularReference);
    
    getKey(): string | null;
    child(pathString: string): Reference;
    
    getParent(): Reference | null;
    
    getRoot(): Reference;
    set(newVal: unknown, onComplete?: (error: Error | null) => void): Promise<void>;
    update(values: object, onComplete?: (a: Error | null) => void): Promise<void>;
    setWithPriority(newVal: unknown, newPriority: string | number | null, onComplete?: (a: Error | null) => void): Promise<void>;
    remove(onComplete?: (a: Error | null) => void): Promise<void>;
    transaction(transactionUpdate: (currentData: unknown) => unknown, onComplete?: (error: Error | null, committed: boolean, dataSnapshot: DataSnapshot | null) => void, applyLocally?: boolean): Promise<TransactionResult>;
    setPriority(priority: string | number | null, onComplete?: (a: Error | null) => void): Promise<void>;
    push(value?: unknown, onComplete?: (a: Error | null) => void): Reference;
    onDisconnect(): OnDisconnect;
    get key(): string | null;
    get parent(): Reference | null;
    get root(): Reference;
}
