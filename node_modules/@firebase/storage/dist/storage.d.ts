

import { AppCheckInternalComponentName } from '@firebase/app-check-interop-types';
import { CompleteFn } from '@firebase/util';
import { EmulatorMockTokenOptions } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseAuthInternalName } from '@firebase/auth-interop-types';
import { FirebaseError } from '@firebase/util';
import { _FirebaseService } from '@firebase/app';
import { NextFn } from '@firebase/util';
import { Provider } from '@firebase/component';
import { Subscribe } from '@firebase/util';
import { Unsubscribe } from '@firebase/util';


declare type CompleteFn_2 = () => void;


declare interface Connection<T extends ConnectionType> {
    
    send(url: string, method: string, isUsingEmulator: boolean, body?: ArrayBufferView | Blob | string | null, headers?: Headers_2): Promise<void>;
    getErrorCode(): ErrorCode;
    getStatus(): number;
    getResponse(): T;
    getErrorText(): string;
    
    abort(): void;
    getResponseHeader(header: string): string | null;
    addUploadProgressListener(listener: (p1: ProgressEvent) => void): void;
    removeUploadProgressListener(listener: (p1: ProgressEvent) => void): void;
}


declare type ConnectionType = string | ArrayBuffer | Blob | ReadableStream<Uint8Array>;


export declare function connectStorageEmulator(storage: FirebaseStorage, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;


export declare function _dataFromString(format: StringFormat, stringData: string): StringData;


export declare function deleteObject(ref: StorageReference): Promise<void>;
export { EmulatorMockTokenOptions }


declare enum ErrorCode {
    NO_ERROR = 0,
    NETWORK_ERROR = 1,
    ABORT = 2
}


declare type ErrorFn = (error: StorageError) => void;


declare type ErrorHandler = (connection: Connection<ConnectionType>, response: StorageError) => StorageError;



export declare class _FbsBlob {
    private data_;
    private size_;
    private type_;
    constructor(data: Blob | Uint8Array | ArrayBuffer, elideCopy?: boolean);
    size(): number;
    type(): string;
    slice(startByte: number, endByte: number): _FbsBlob | null;
    static getBlob(...args: Array<string | _FbsBlob>): _FbsBlob | null;
    uploadData(): Blob | Uint8Array;
}


export declare interface FirebaseStorage extends _FirebaseService {
    
    readonly app: FirebaseApp;
    
    maxUploadRetryTime: number;
    
    maxOperationRetryTime: number;
}


export declare class _FirebaseStorageImpl implements FirebaseStorage {
    
    readonly app: FirebaseApp;
    readonly _authProvider: Provider<FirebaseAuthInternalName>;
    
    readonly _appCheckProvider: Provider<AppCheckInternalComponentName>;
    
    readonly _url?: string | undefined;
    readonly _firebaseVersion?: string | undefined;
    _isUsingEmulator: boolean;
    _bucket: _Location | null;
    
    private _host;
    _protocol: string;
    protected readonly _appId: string | null;
    private readonly _requests;
    private _deleted;
    private _maxOperationRetryTime;
    private _maxUploadRetryTime;
    _overrideAuthToken?: string;
    constructor(
    
    app: FirebaseApp, _authProvider: Provider<FirebaseAuthInternalName>, 
    
    _appCheckProvider: Provider<AppCheckInternalComponentName>, 
    
    _url?: string | undefined, _firebaseVersion?: string | undefined, _isUsingEmulator?: boolean);
    
    get host(): string;
    set host(host: string);
    
    get maxUploadRetryTime(): number;
    set maxUploadRetryTime(time: number);
    
    get maxOperationRetryTime(): number;
    set maxOperationRetryTime(time: number);
    _getAuthToken(): Promise<string | null>;
    _getAppCheckToken(): Promise<string | null>;
    
    _delete(): Promise<void>;
    
    _makeStorageReference(loc: _Location): _Reference;
    
    _makeRequest<I extends ConnectionType, O>(requestInfo: RequestInfo_2<I, O>, requestFactory: () => Connection<I>, authToken: string | null, appCheckToken: string | null, retry?: boolean): Request_2<O>;
    makeRequestWithTokens<I extends ConnectionType, O>(requestInfo: RequestInfo_2<I, O>, requestFactory: () => Connection<I>): Promise<O>;
}


export declare interface FullMetadata extends UploadMetadata {
    
    bucket: string;
    
    fullPath: string;
    
    generation: string;
    
    metageneration: string;
    
    name: string;
    
    size: number;
    
    timeCreated: string;
    
    updated: string;
    
    downloadTokens: string[] | undefined;
    
    ref?: StorageReference | undefined;
}


export declare function getBlob(ref: StorageReference, maxDownloadSizeBytes?: number): Promise<Blob>;


export declare function getBytes(ref: StorageReference, maxDownloadSizeBytes?: number): Promise<ArrayBuffer>;


export declare function _getChild(ref: StorageReference, childPath: string): _Reference;


export declare function getDownloadURL(ref: StorageReference): Promise<string>;


export declare function getMetadata(ref: StorageReference): Promise<FullMetadata>;


export declare function getStorage(app?: FirebaseApp, bucketUrl?: string): FirebaseStorage;


export declare function getStream(ref: StorageReference, maxDownloadSizeBytes?: number): ReadableStream;



declare type Headers_2 = Record<string, string>;


declare const enum InternalTaskState {
    RUNNING = "running",
    PAUSING = "pausing",
    PAUSED = "paused",
    SUCCESS = "success",
    CANCELING = "canceling",
    CANCELED = "canceled",
    ERROR = "error"
}


export declare function _invalidArgument(message: string): StorageError;


export declare function _invalidRootOperation(name: string): StorageError;


export declare function list(ref: StorageReference, options?: ListOptions): Promise<ListResult>;


export declare function listAll(ref: StorageReference): Promise<ListResult>;


export declare interface ListOptions {
    
    maxResults?: number | null;
    
    pageToken?: string | null;
}


export declare interface ListResult {
    
    prefixes: StorageReference[];
    
    items: StorageReference[];
    
    nextPageToken?: string;
}



export declare class _Location {
    readonly bucket: string;
    private path_;
    constructor(bucket: string, path: string);
    get path(): string;
    get isRoot(): boolean;
    fullServerUrl(): string;
    bucketOnlyServerUrl(): string;
    static makeFromBucketSpec(bucketString: string, host: string): _Location;
    static makeFromUrl(url: string, host: string): _Location;
}



declare interface Metadata extends FullMetadata {
    [prop: string]: unknown;
}


declare type NextFn_2<T> = (value: T) => void;


export declare function ref(storage: FirebaseStorage, url?: string): StorageReference;


export declare function ref(storageOrRef: FirebaseStorage | StorageReference, path?: string): StorageReference;


export declare class _Reference {
    private _service;
    _location: _Location;
    constructor(_service: _FirebaseStorageImpl, location: string | _Location);
    
    toString(): string;
    protected _newRef(service: _FirebaseStorageImpl, location: _Location): _Reference;
    
    get root(): _Reference;
    
    get bucket(): string;
    
    get fullPath(): string;
    
    get name(): string;
    
    get storage(): _FirebaseStorageImpl;
    
    get parent(): _Reference | null;
    
    _throwIfRoot(name: string): void;
}

declare interface Request_2<T> {
    getPromise(): Promise<T>;
    
    cancel(appDelete?: boolean): void;
}


declare type RequestHandler<I extends ConnectionType, O> = (connection: Connection<I>, response: I) => O;


declare class RequestInfo_2<I extends ConnectionType, O> {
    url: string;
    method: string;
    
    handler: RequestHandler<I, O>;
    timeout: number;
    urlParams: UrlParams;
    headers: Headers_2;
    body: Blob | string | Uint8Array | null;
    errorHandler: ErrorHandler | null;
    
    progressCallback: ((p1: number, p2: number) => void) | null;
    successCodes: number[];
    additionalRetryCodes: number[];
    constructor(url: string, method: string, 
    
    handler: RequestHandler<I, O>, timeout: number);
}


export declare interface SettableMetadata {
    
    cacheControl?: string | undefined;
    
    contentDisposition?: string | undefined;
    
    contentEncoding?: string | undefined;
    
    contentLanguage?: string | undefined;
    
    contentType?: string | undefined;
    
    customMetadata?: {
        [key: string]: string;
    } | undefined;
}


export declare class StorageError extends FirebaseError {
    private status_;
    private readonly _baseMessage;
    
    customData: {
        serverResponse: string | null;
    };
    
    constructor(code: StorageErrorCode, message: string, status_?: number);
    get status(): number;
    set status(status: number);
    
    _codeEquals(code: StorageErrorCode): boolean;
    
    get serverResponse(): null | string;
    set serverResponse(serverResponse: string | null);
}


export declare enum StorageErrorCode {
    UNKNOWN = "unknown",
    OBJECT_NOT_FOUND = "object-not-found",
    BUCKET_NOT_FOUND = "bucket-not-found",
    PROJECT_NOT_FOUND = "project-not-found",
    QUOTA_EXCEEDED = "quota-exceeded",
    UNAUTHENTICATED = "unauthenticated",
    UNAUTHORIZED = "unauthorized",
    UNAUTHORIZED_APP = "unauthorized-app",
    RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded",
    INVALID_CHECKSUM = "invalid-checksum",
    CANCELED = "canceled",
    INVALID_EVENT_NAME = "invalid-event-name",
    INVALID_URL = "invalid-url",
    INVALID_DEFAULT_BUCKET = "invalid-default-bucket",
    NO_DEFAULT_BUCKET = "no-default-bucket",
    CANNOT_SLICE_BLOB = "cannot-slice-blob",
    SERVER_FILE_WRONG_SIZE = "server-file-wrong-size",
    NO_DOWNLOAD_URL = "no-download-url",
    INVALID_ARGUMENT = "invalid-argument",
    INVALID_ARGUMENT_COUNT = "invalid-argument-count",
    APP_DELETED = "app-deleted",
    INVALID_ROOT_OPERATION = "invalid-root-operation",
    INVALID_FORMAT = "invalid-format",
    INTERNAL_ERROR = "internal-error",
    UNSUPPORTED_ENVIRONMENT = "unsupported-environment"
}


export declare interface StorageObserver<T> {
    next?: NextFn<T> | null;
    error?: (error: StorageError) => void | null;
    complete?: CompleteFn | null;
}


declare interface StorageObserver_2<T> {
    
    next?: NextFn_2<T>;
    
    error?: ErrorFn;
    
    complete?: CompleteFn_2;
}


export declare interface StorageReference {
    
    toString(): string;
    
    root: StorageReference;
    
    bucket: string;
    
    fullPath: string;
    
    name: string;
    
    storage: FirebaseStorage;
    
    parent: StorageReference | null;
}

declare class StringData {
    data: Uint8Array;
    contentType: string | null;
    constructor(data: Uint8Array, contentType?: string | null);
}



export declare type StringFormat = (typeof StringFormat)[keyof typeof StringFormat];


export declare const StringFormat: {
    
    readonly RAW: "raw";
    
    readonly BASE64: "base64";
    
    readonly BASE64URL: "base64url";
    
    readonly DATA_URL: "data_url";
};


declare type Subscribe_2<T> = (next?: NextFn_2<T> | StorageObserver_2<T>, error?: ErrorFn, complete?: CompleteFn_2) => Unsubscribe_2;


export declare type TaskEvent = 'state_changed';




export declare type _TaskEvent = string;


export declare const _TaskEvent: {
    
    STATE_CHANGED: string;
};


export declare type TaskState = 'running' | 'paused' | 'success' | 'canceled' | 'error';


export declare type _TaskState = (typeof _TaskState)[keyof typeof _TaskState];


export declare const _TaskState: {
    
    readonly RUNNING: "running";
    
    readonly PAUSED: "paused";
    
    readonly SUCCESS: "success";
    
    readonly CANCELED: "canceled";
    
    readonly ERROR: "error";
};


declare type Unsubscribe_2 = () => void;


export declare function updateMetadata(ref: StorageReference, metadata: SettableMetadata): Promise<FullMetadata>;


export declare function uploadBytes(ref: StorageReference, data: Blob | Uint8Array | ArrayBuffer, metadata?: UploadMetadata): Promise<UploadResult>;


export declare function uploadBytesResumable(ref: StorageReference, data: Blob | Uint8Array | ArrayBuffer, metadata?: UploadMetadata): UploadTask;


export declare interface UploadMetadata extends SettableMetadata {
    
    md5Hash?: string | undefined;
}


export declare interface UploadResult {
    
    readonly metadata: FullMetadata;
    
    readonly ref: StorageReference;
}


export declare function uploadString(ref: StorageReference, value: string, format?: StringFormat, metadata?: UploadMetadata): Promise<UploadResult>;


export declare interface UploadTask {
    
    cancel(): boolean;
    
    catch(onRejected: (error: StorageError) => unknown): Promise<unknown>;
    
    on(event: TaskEvent, nextOrObserver?: StorageObserver<UploadTaskSnapshot> | null | ((snapshot: UploadTaskSnapshot) => unknown), error?: ((a: StorageError) => unknown) | null, complete?: Unsubscribe | null): Unsubscribe | Subscribe<UploadTaskSnapshot>;
    
    pause(): boolean;
    
    resume(): boolean;
    
    snapshot: UploadTaskSnapshot;
    
    then(onFulfilled?: ((snapshot: UploadTaskSnapshot) => unknown) | null, onRejected?: ((error: StorageError) => unknown) | null): Promise<unknown>;
}


export declare class _UploadTask {
    private _ref;
    
    _blob: _FbsBlob;
    
    _metadata: Metadata | null;
    private _mappings;
    
    _transferred: number;
    private _needToFetchStatus;
    private _needToFetchMetadata;
    private _observers;
    private _resumable;
    
    _state: InternalTaskState;
    private _error?;
    private _uploadUrl?;
    private _request?;
    private _chunkMultiplier;
    private _errorHandler;
    private _metadataErrorHandler;
    private _resolve?;
    private _reject?;
    private pendingTimeout?;
    private _promise;
    private sleepTime;
    private maxSleepTime;
    isExponentialBackoffExpired(): boolean;
    
    constructor(ref: _Reference, blob: _FbsBlob, metadata?: Metadata | null);
    private _makeProgressCallback;
    private _shouldDoResumable;
    private _start;
    private _resolveToken;
    private _createResumable;
    private _fetchStatus;
    private _continueUpload;
    private _increaseMultiplier;
    private _fetchMetadata;
    private _oneShotUpload;
    private _updateProgress;
    private _transition;
    private completeTransitions_;
    
    get snapshot(): UploadTaskSnapshot;
    
    on(type: _TaskEvent, nextOrObserver?: StorageObserver<UploadTaskSnapshot> | null | ((snapshot: UploadTaskSnapshot) => unknown), error?: ((a: StorageError) => unknown) | null, completed?: CompleteFn | null): Unsubscribe_2 | Subscribe_2<UploadTaskSnapshot>;
    
    then<U>(onFulfilled?: ((value: UploadTaskSnapshot) => U | Promise<U>) | null, onRejected?: ((error: StorageError) => U | Promise<U>) | null): Promise<U>;
    
    catch<T>(onRejected: (p1: StorageError) => T | Promise<T>): Promise<T>;
    
    private _addObserver;
    
    private _removeObserver;
    private _notifyObservers;
    private _finishPromise;
    private _notifyObserver;
    
    resume(): boolean;
    
    pause(): boolean;
    
    cancel(): boolean;
}


export declare interface UploadTaskSnapshot {
    
    bytesTransferred: number;
    
    metadata: FullMetadata;
    
    ref: StorageReference;
    
    state: TaskState;
    
    task: UploadTask;
    
    totalBytes: number;
}


declare interface UrlParams {
    [name: string]: string | number;
}

export { }
