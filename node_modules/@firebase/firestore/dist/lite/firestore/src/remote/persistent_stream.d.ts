
import { CredentialsProvider, Token } from '../api/credentials';
import { User } from '../auth/user';
import { SnapshotVersion } from '../core/snapshot_version';
import { TargetId } from '../core/types';
import { TargetData } from '../local/target_data';
import { Mutation, MutationResult } from '../model/mutation';
import { ListenRequest as ProtoListenRequest, ListenResponse as ProtoListenResponse, WriteRequest as ProtoWriteRequest, WriteResponse as ProtoWriteResponse } from '../protos/firestore_proto_api';
import { AsyncQueue, TimerId } from '../util/async_queue';
import { FirestoreError } from '../util/error';
import { ExponentialBackoff } from './backoff';
import { Connection, Stream } from './connection';
import { JsonProtoSerializer } from './serializer';
import { WatchChange } from './watch_change';
export interface WriteRequest extends ProtoWriteRequest {
    database?: string;
}

export interface PersistentStreamListener {
    
    onConnected: () => Promise<void>;
    
    onOpen: () => Promise<void>;
    
    onClose: (err?: FirestoreError) => Promise<void>;
}

export declare abstract class PersistentStream<SendType, ReceiveType, ListenerType extends PersistentStreamListener> {
    private queue;
    private idleTimerId;
    private healthTimerId;
    protected connection: Connection;
    private authCredentialsProvider;
    private appCheckCredentialsProvider;
    protected listener: ListenerType;
    private state;
    
    private closeCount;
    private idleTimer;
    private healthCheck;
    private stream;
    protected backoff: ExponentialBackoff;
    constructor(queue: AsyncQueue, connectionTimerId: TimerId, idleTimerId: TimerId, healthTimerId: TimerId, connection: Connection, authCredentialsProvider: CredentialsProvider<User>, appCheckCredentialsProvider: CredentialsProvider<string>, listener: ListenerType);
    
    protected responseCount: number;
    
    isStarted(): boolean;
    
    isOpen(): boolean;
    
    start(): void;
    
    stop(): Promise<void>;
    
    inhibitBackoff(): void;
    
    markIdle(): void;
    
    protected sendRequest(msg: SendType): void;
    
    private handleIdleCloseTimer;
    
    private cancelIdleCheck;
    
    private cancelHealthCheck;
    
    private close;
    
    protected tearDown(): void;
    
    protected abstract startRpc(authToken: Token | null, appCheckToken: Token | null): Stream<SendType, ReceiveType>;
    
    protected abstract onFirst(message: ReceiveType): Promise<void>;
    
    protected abstract onNext(message: ReceiveType): Promise<void>;
    private auth;
    private startStream;
    private performBackoff;
    handleStreamClose(error?: FirestoreError): Promise<void>;
    
    private getCloseGuardedDispatcher;
}

export interface WatchStreamListener extends PersistentStreamListener {
    
    onWatchChange: (watchChange: WatchChange, snapshot: SnapshotVersion) => Promise<void>;
}

export declare class PersistentListenStream extends PersistentStream<ProtoListenRequest, ProtoListenResponse, WatchStreamListener> {
    private serializer;
    constructor(queue: AsyncQueue, connection: Connection, authCredentials: CredentialsProvider<User>, appCheckCredentials: CredentialsProvider<string>, serializer: JsonProtoSerializer, listener: WatchStreamListener);
    protected startRpc(authToken: Token | null, appCheckToken: Token | null): Stream<ProtoListenRequest, ProtoListenResponse>;
    protected onFirst(watchChangeProto: ProtoListenResponse): Promise<void>;
    protected onNext(watchChangeProto: ProtoListenResponse): Promise<void>;
    
    watch(targetData: TargetData): void;
    
    unwatch(targetId: TargetId): void;
}

export interface WriteStreamListener extends PersistentStreamListener {
    
    onHandshakeComplete: () => Promise<void>;
    
    onMutationResult: (commitVersion: SnapshotVersion, results: MutationResult[]) => Promise<void>;
}

export declare class PersistentWriteStream extends PersistentStream<ProtoWriteRequest, ProtoWriteResponse, WriteStreamListener> {
    private serializer;
    constructor(queue: AsyncQueue, connection: Connection, authCredentials: CredentialsProvider<User>, appCheckCredentials: CredentialsProvider<string>, serializer: JsonProtoSerializer, listener: WriteStreamListener);
    
    private lastStreamToken;
    
    get handshakeComplete(): boolean;
    start(): void;
    protected tearDown(): void;
    protected startRpc(authToken: Token | null, appCheckToken: Token | null): Stream<ProtoWriteRequest, ProtoWriteResponse>;
    protected onFirst(responseProto: ProtoWriteResponse): Promise<void>;
    protected onNext(responseProto: ProtoWriteResponse): Promise<void>;
    
    writeHandshake(): void;
    
    writeMutations(mutations: Mutation[]): void;
}
