
import { FirestoreError } from '../util/error';
import { PersistencePromise } from './persistence_promise';
type SimpleDbTransactionMode = 'readonly' | 'readwrite';
export interface SimpleDbSchemaConverter {
    createOrUpgrade(db: IDBDatabase, txn: IDBTransaction, fromVersion: number, toVersion: number): PersistencePromise<void>;
}

export declare class SimpleDbTransaction {
    private readonly action;
    private readonly transaction;
    private aborted;
    
    private readonly completionDeferred;
    static open(db: IDBDatabase, action: string, mode: IDBTransactionMode, objectStoreNames: string[]): SimpleDbTransaction;
    constructor(action: string, transaction: IDBTransaction);
    get completionPromise(): Promise<void>;
    abort(error?: Error): void;
    maybeCommit(): void;
    
    store<KeyType extends IDBValidKey, ValueType extends unknown>(storeName: string): SimpleDbStore<KeyType, ValueType>;
}

export declare class SimpleDb {
    private readonly name;
    private readonly version;
    private readonly schemaConverter;
    private db?;
    private lastClosedDbVersion;
    private versionchangelistener?;
    
    static delete(name: string): Promise<void>;
    
    static isAvailable(): boolean;
    
    static isMockPersistence(): boolean;
    
    static getStore<KeyType extends IDBValidKey, ValueType extends unknown>(txn: SimpleDbTransaction, store: string): SimpleDbStore<KeyType, ValueType>;
    
    static getIOSVersion(ua: string): number;
    constructor(name: string, version: number, schemaConverter: SimpleDbSchemaConverter);
    
    ensureDb(action: string): Promise<IDBDatabase>;
    setVersionChangeListener(versionChangeListener: (event: IDBVersionChangeEvent) => void): void;
    runTransaction<T>(action: string, mode: SimpleDbTransactionMode, objectStores: string[], transactionFn: (transaction: SimpleDbTransaction) => PersistencePromise<T>): Promise<T>;
    close(): void;
}

export declare function getAndroidVersion(ua: string): number;

export declare class IterationController {
    private dbCursor;
    private shouldStop;
    private nextKey;
    constructor(dbCursor: IDBCursorWithValue);
    get isDone(): boolean;
    get skipToKey(): IDBValidKey | null;
    set cursor(value: IDBCursorWithValue);
    
    done(): void;
    
    skip(key: IDBValidKey): void;
    
    delete(): PersistencePromise<void>;
}

export type IterateCallback<KeyType, ValueType> = (key: KeyType, value: ValueType, control: IterationController) => void | PersistencePromise<void>;

export interface IterateOptions {
    
    index?: string;
    
    range?: IDBKeyRange;
    
    keysOnly?: boolean;
    
    reverse?: boolean;
}

export declare class IndexedDbTransactionError extends FirestoreError {
    name: string;
    constructor(actionName: string, cause: Error | string);
}

export declare function isIndexedDbTransactionError(e: Error): boolean;

export declare class SimpleDbStore<KeyType extends IDBValidKey, ValueType extends unknown> {
    private store;
    constructor(store: IDBObjectStore);
    
    put(value: ValueType): PersistencePromise<void>;
    put(key: KeyType, value: ValueType): PersistencePromise<void>;
    
    add(value: ValueType): PersistencePromise<KeyType>;
    
    get(key: KeyType): PersistencePromise<ValueType | null>;
    delete(key: KeyType | IDBKeyRange): PersistencePromise<void>;
    
    count(): PersistencePromise<number>;
    
    loadAll(): PersistencePromise<ValueType[]>;
    
    loadAll(range: IDBKeyRange): PersistencePromise<ValueType[]>;
    
    loadAll(index: string): PersistencePromise<ValueType[]>;
    
    loadAll(index: string, range: IDBKeyRange): PersistencePromise<ValueType[]>;
    
    loadFirst(range: IDBKeyRange, count: number | null): PersistencePromise<ValueType[]>;
    deleteAll(): PersistencePromise<void>;
    deleteAll(range: IDBKeyRange): PersistencePromise<void>;
    deleteAll(index: string, range: IDBKeyRange): PersistencePromise<void>;
    
    iterate(callback: IterateCallback<KeyType, ValueType>): PersistencePromise<void>;
    iterate(options: IterateOptions, callback: IterateCallback<KeyType, ValueType>): PersistencePromise<void>;
    
    iterateSerial(callback: (k: KeyType, v: ValueType) => PersistencePromise<boolean>): PersistencePromise<void>;
    private iterateCursor;
    private options;
    private cursor;
}
export {};
