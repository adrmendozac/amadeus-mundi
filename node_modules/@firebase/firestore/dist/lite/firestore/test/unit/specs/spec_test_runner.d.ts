
import { IndexConfiguration } from '../../../src/api/index_configuration';
import { ListenOptions } from '../../../src/core/event_manager';
import { Query } from '../../../src/core/query';
import { TargetId } from '../../../src/core/types';
import { FieldIndex } from '../../../src/model/field_index';
import { JsonObject } from '../../../src/model/object_value';
import * as api from '../../../src/protos/firestore_proto_api';
import { TestSnapshotVersion } from '../../util/helpers';
import { ActiveTargetMap } from './spec_builder';
interface DocumentOptions {
    hasLocalMutations?: boolean;
    hasCommittedMutations?: boolean;
}
export declare function parseQuery(querySpec: string | SpecQuery): Query;

export declare function runSpec(name: string, tags: string[], usePersistence: boolean, config: SpecConfig, steps: SpecStep[]): Promise<void>;

export interface SpecConfig {
    
    useEagerGCForMemory: boolean;
    
    numClients: number;
    
    maxConcurrentLimboResolutions?: number;
}

export type PersistenceAction = 'Get next mutation batch' | 'read document' | 'Allocate target' | 'Release target' | 'Execute query' | 'Handle user change' | 'Locally write mutations' | 'Acknowledge batch' | 'Reject batch' | 'Get highest unacknowledged batch id' | 'Get last stream token' | 'Set last stream token' | 'Get last remote snapshot version' | 'Set last remote snapshot version' | 'Apply remote event' | 'notifyLocalViewChanges' | 'Remote document keys' | 'Collect garbage' | 'maybeGarbageCollectMultiClientState' | 'Lookup mutation documents' | 'Get target data' | 'Get new document changes' | 'Synchronize last document change read time' | 'updateClientMetadataAndTryBecomePrimary' | 'getHighestListenSequenceNumber';

export interface SpecStep {
    
    clientIndex?: number;
    
    userListen?: SpecUserListen;
    
    userUnlisten?: SpecUserUnlisten;
    
    userSet?: SpecUserSet;
    
    userPatch?: SpecUserPatch;
    
    userDelete?: SpecUserDelete;
    
    addSnapshotsInSyncListener?: true;
    
    removeSnapshotsInSyncListener?: true;
    
    loadBundle?: string;
    
    watchAck?: SpecWatchAck;
    
    watchCurrent?: SpecWatchCurrent;
    
    watchReset?: SpecWatchReset;
    
    watchRemove?: SpecWatchRemove;
    
    watchEntity?: SpecWatchEntity;
    
    watchFilter?: SpecWatchFilter;
    
    watchSnapshot?: SpecWatchSnapshot;
    
    watchStreamClose?: SpecWatchStreamClose;
    
    writeAck?: SpecWriteAck;
    
    failWrite?: SpecWriteFailure;
    
    waitForPendingWrites?: true;
    
    failDatabase?: false | PersistenceAction[];
    
    setIndexConfiguration?: string | IndexConfiguration;
    
    runTimer?: string;
    
    drainQueue?: true;
    
    enableNetwork?: boolean;
    
    clearPersistence?: true;
    
    applyClientState?: SpecClientState;
    
    changeUser?: string | null;
    
    triggerLruGC?: number;
    
    restart?: true;
    
    shutdown?: true;
    
    expectedSnapshotEvents?: SnapshotEvent[];
    
    expectedState?: StateExpectation;
    
    expectedSnapshotsInSyncEvents?: number;
    
    expectedWaitForPendingWritesEvents?: number;
}
export interface SpecUserListen {
    targetId: TargetId;
    query: string | SpecQuery;
    options?: ListenOptions;
}

export type SpecUserUnlisten = [TargetId, string | SpecQuery];

export type SpecUserSet = [string, JsonObject<unknown>];

export type SpecUserPatch = [string, JsonObject<unknown>];

export type SpecUserDelete = string;

export type SpecWatchAck = TargetId[];

export type SpecWatchCurrent = [TargetId[], string];

export type SpecWatchReset = TargetId[];
export interface SpecError {
    code: number;
    message: string;
}
export interface SpecWatchRemove {
    targetIds: TargetId[];
    cause?: SpecError;
}
export interface SpecWatchSnapshot {
    version: TestSnapshotVersion;
    targetIds: TargetId[];
    resumeToken?: string;
}
export interface SpecWatchStreamClose {
    error: SpecError;
    runBackoffTimer: boolean;
}
export interface SpecWriteAck {
    
    version: TestSnapshotVersion;
    
    keepInQueue?: boolean;
}
export interface SpecWriteFailure {
    
    error: SpecError;
    
    keepInQueue?: boolean;
}
export interface SpecWatchEntity {
    key?: string;
    
    doc?: SpecDocument;
    
    docs?: SpecDocument[];
    
    targets?: TargetId[];
    
    removedTargets?: TargetId[];
}
export interface SpecClientState {
    
    visibility?: DocumentVisibilityState;
    
    primary?: true;
}

export interface SpecWatchFilter {
    targetIds: TargetId[];
    keys: string[];
    bloomFilter?: api.BloomFilter;
}
export type SpecLimitType = 'LimitToFirst' | 'LimitToLast';

export type SpecQueryFilter = [string, string, unknown];

export type SpecQueryOrderBy = [string, string];

export interface SpecQuery {
    path: string;
    collectionGroup?: string;
    limit?: number;
    limitType?: SpecLimitType;
    filters?: SpecQueryFilter[];
    orderBys?: SpecQueryOrderBy[];
}

export interface SpecDocument {
    key: string;
    version: TestSnapshotVersion;
    createTime: TestSnapshotVersion;
    value: JsonObject<unknown> | null;
    options?: DocumentOptions;
}
export interface SnapshotEvent {
    query: SpecQuery;
    errorCode?: number;
    fromCache?: boolean;
    hasPendingWrites?: boolean;
    added?: SpecDocument[];
    removed?: SpecDocument[];
    modified?: SpecDocument[];
    metadata?: SpecDocument[];
}
export interface StateExpectation {
    
    numOutstandingWrites?: number;
    
    numActiveClients?: number;
    
    writeStreamRequestCount?: number;
    
    watchStreamRequestCount?: number;
    
    activeLimboDocs?: string[];
    
    enqueuedLimboDocs?: string[];
    
    isPrimary?: boolean;
    
    isShutdown?: boolean;
    
    activeTargets?: ActiveTargetMap;
    
    userCallbacks?: {
        acknowledgedDocs: string[];
        rejectedDocs: string[];
    };
    
    indexes?: FieldIndex[];
}
export {};
