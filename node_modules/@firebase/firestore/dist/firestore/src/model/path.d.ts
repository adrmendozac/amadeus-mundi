
export declare const DOCUMENT_KEY_NAME = "__name__";

declare abstract class BasePath<B extends BasePath<B>> {
    private segments;
    private offset;
    private len;
    constructor(segments: string[], offset?: number, length?: number);
    
    protected abstract construct(segments: string[], offset?: number, length?: number): B;
    
    abstract toString(): string;
    get length(): number;
    isEqual(other: B): boolean;
    child(nameOrPath: string | B): B;
    
    private limit;
    popFirst(size?: number): B;
    popLast(): B;
    firstSegment(): string;
    lastSegment(): string;
    get(index: number): string;
    isEmpty(): boolean;
    isPrefixOf(other: this): boolean;
    isImmediateParentOf(potentialChild: this): boolean;
    forEach(fn: (segment: string) => void): void;
    toArray(): string[];
    
    static comparator<T extends BasePath<T>>(p1: BasePath<T>, p2: BasePath<T>): number;
    private static compareSegments;
    private static isNumericId;
    private static extractNumericId;
}

export declare class ResourcePath extends BasePath<ResourcePath> {
    protected construct(segments: string[], offset?: number, length?: number): ResourcePath;
    canonicalString(): string;
    toString(): string;
    
    toUriEncodedString(): string;
    
    static fromString(...pathComponents: string[]): ResourcePath;
    static emptyPath(): ResourcePath;
}

export declare class FieldPath extends BasePath<FieldPath> {
    protected construct(segments: string[], offset?: number, length?: number): FieldPath;
    
    private static isValidIdentifier;
    canonicalString(): string;
    toString(): string;
    
    isKeyField(): boolean;
    
    static keyField(): FieldPath;
    
    static fromServerFormat(path: string): FieldPath;
    static emptyPath(): FieldPath;
}
export {};
