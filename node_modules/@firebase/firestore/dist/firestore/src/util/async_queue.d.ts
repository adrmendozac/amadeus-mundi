
import { FirestoreError } from './error';

export declare const enum TimerId {
    
    All = "all",
    
    ListenStreamIdle = "listen_stream_idle",
    ListenStreamConnectionBackoff = "listen_stream_connection_backoff",
    WriteStreamIdle = "write_stream_idle",
    WriteStreamConnectionBackoff = "write_stream_connection_backoff",
    HealthCheckTimeout = "health_check_timeout",
    
    OnlineStateTimeout = "online_state_timeout",
    
    ClientMetadataRefresh = "client_metadata_refresh",
    
    LruGarbageCollection = "lru_garbage_collection",
    
    TransactionRetry = "transaction_retry",
    
    AsyncQueueRetry = "async_queue_retry",
    
    IndexBackfill = "index_backfill"
}

export declare class DelayedOperation<T extends unknown> implements PromiseLike<T> {
    private readonly asyncQueue;
    readonly timerId: TimerId;
    readonly targetTimeMs: number;
    private readonly op;
    private readonly removalCallback;
    private timerHandle;
    private readonly deferred;
    private constructor();
    get promise(): Promise<T>;
    
    static createAndSchedule<R extends unknown>(asyncQueue: AsyncQueue, timerId: TimerId, delayMs: number, op: () => Promise<R>, removalCallback: (op: DelayedOperation<R>) => void): DelayedOperation<R>;
    
    private start;
    
    skipDelay(): void;
    
    cancel(reason?: string): void;
    then: <TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
    private handleDelayElapsed;
    private clearTimeout;
}
export interface AsyncQueue {
    readonly isShuttingDown: boolean;
    
    enqueueAndForget<T extends unknown>(op: () => Promise<T>): void;
    
    enqueueAndForgetEvenWhileRestricted<T extends unknown>(op: () => Promise<T>): void;
    
    enterRestrictedMode(purgeExistingTasks?: boolean): void;
    
    enqueue<T extends unknown>(op: () => Promise<T>): Promise<T>;
    
    enqueueRetryable(op: () => Promise<void>): void;
    
    enqueueAfterDelay<T extends unknown>(timerId: TimerId, delayMs: number, op: () => Promise<T>): DelayedOperation<T>;
    
    verifyOperationInProgress(): void;
}

export declare function wrapInUserErrorIfRecoverable(e: Error, msg: string): FirestoreError;
