
interface VersionService {
    library: string;
    version: string;
}
interface PlatformLoggerService {
    getPlatformInfoString(): string;
}
interface HeartbeatService {
    
    triggerHeartbeat(): Promise<void>;
    
    getHeartbeatsHeader(): Promise<string>;
}




interface FirebaseApp {
    
    readonly name: string;
    
    readonly options: FirebaseOptions;
    
    automaticDataCollectionEnabled: boolean;
}

interface FirebaseOptions {
    
    apiKey?: string;
    
    authDomain?: string;
    
    databaseURL?: string;
    
    projectId?: string;
    
    storageBucket?: string;
    
    messagingSenderId?: string;
    
    appId?: string;
    
    measurementId?: string;
}

interface _FirebaseService {
    app: FirebaseApp;
    
    _delete(): Promise<void>;
}
declare module '@firebase/component' {
    interface NameServiceMapping {
        'app': FirebaseApp;
        'app-version': VersionService;
        'heartbeat': HeartbeatService;
        'platform-logger': PlatformLoggerService;
    }
}


type LogLevelString = 'debug' | 'verbose' | 'info' | 'warn' | 'error' | 'silent';


interface FirebaseDefaults {
    config?: Record<string, string>;
    emulatorHosts?: Record<string, string>;
    _authTokenSyncURL?: string;
    _authIdTokenMaxAge?: number;
    
    forceEnvironment?: 'browser' | 'node';
    [key: string]: unknown;
}
declare global {
    var __FIREBASE_DEFAULTS__: FirebaseDefaults | undefined;
}


type FirebaseSignInProvider = 'custom' | 'email' | 'password' | 'phone' | 'anonymous' | 'google.com' | 'facebook.com' | 'github.com' | 'twitter.com' | 'microsoft.com' | 'apple.com';
interface FirebaseIdToken {
    iss: string;
    aud: string;
    sub: string;
    iat: number;
    exp: number;
    user_id: string;
    auth_time: number;
    provider_id?: 'anonymous';
    email?: string;
    email_verified?: boolean;
    phone_number?: string;
    name?: string;
    picture?: string;
    firebase: {
        sign_in_provider: FirebaseSignInProvider;
        identities?: {
            [provider in FirebaseSignInProvider]?: string[];
        };
    };
    [claim: string]: unknown;
    uid?: never;
}
type EmulatorMockTokenOptions = ({
    user_id: string;
} | {
    sub: string;
}) & Partial<FirebaseIdToken>;

declare class FirebaseError extends Error {
    
    readonly code: string;
    
    customData?: Record<string, unknown> | undefined;
    
    readonly name: string;
    constructor(
    
    code: string, message: string, 
    
    customData?: Record<string, unknown> | undefined);
}



declare class User {
    readonly uid: string | null;
    
    static readonly UNAUTHENTICATED: User;
    static readonly GOOGLE_CREDENTIALS: User;
    static readonly FIRST_PARTY: User;
    static readonly MOCK_USER: User;
    constructor(uid: string | null);
    isAuthenticated(): boolean;
    
    toKey(): string;
    isEqual(otherUser: User): boolean;
}



interface FirebaseAppCheckInternal {
  
  
  getToken(forceRefresh?: boolean): Promise<AppCheckTokenResult>;

  
  
  getLimitedUseToken(): Promise<AppCheckTokenResult>;

  
  
  
  
  addTokenListener(listener: AppCheckTokenListener): void;

  
  removeTokenListener(listener: AppCheckTokenListener): void;
}

type AppCheckTokenListener = (token: AppCheckTokenResult) => void;


interface AppCheckTokenResult {
  readonly token: string;
  readonly error?: Error;
}

declare module '@firebase/component' {
  interface NameServiceMapping {
    'app-check-internal': FirebaseAppCheckInternal;
  }
}



interface FirebaseAuthTokenData {
  accessToken: string;
}

interface FirebaseAuthInternal {
  getToken(refreshToken?: boolean): Promise<FirebaseAuthTokenData | null>;
  getUid(): string | null;
  addAuthTokenListener(fn: (token: string | null) => void): void;
  removeAuthTokenListener(fn: (token: string | null) => void): void;
}

declare module '@firebase/component' {
  interface NameServiceMapping {
    'auth-internal': FirebaseAuthInternal;
  }
}




type FirestoreErrorCode$1 = 'cancelled' | 'unknown' | 'invalid-argument' | 'deadline-exceeded' | 'not-found' | 'already-exists' | 'permission-denied' | 'resource-exhausted' | 'failed-precondition' | 'aborted' | 'out-of-range' | 'unimplemented' | 'internal' | 'unavailable' | 'data-loss' | 'unauthenticated';

declare class FirestoreError$1 extends FirebaseError {
    
    readonly code: FirestoreErrorCode$1;
    
    readonly message: string;
    
    readonly stack?: string;
    
    constructor(
    
    code: FirestoreErrorCode$1, 
    
    message: string);
}




declare const enum TimerId {
    
    All = "all",
    
    ListenStreamIdle = "listen_stream_idle",
    ListenStreamConnectionBackoff = "listen_stream_connection_backoff",
    WriteStreamIdle = "write_stream_idle",
    WriteStreamConnectionBackoff = "write_stream_connection_backoff",
    HealthCheckTimeout = "health_check_timeout",
    
    OnlineStateTimeout = "online_state_timeout",
    
    ClientMetadataRefresh = "client_metadata_refresh",
    
    LruGarbageCollection = "lru_garbage_collection",
    
    TransactionRetry = "transaction_retry",
    
    AsyncQueueRetry = "async_queue_retry",
    
    IndexBackfill = "index_backfill"
}

declare class DelayedOperation<T extends unknown> implements PromiseLike<T> {
    private readonly asyncQueue;
    readonly timerId: TimerId;
    readonly targetTimeMs: number;
    private readonly op;
    private readonly removalCallback;
    private timerHandle;
    private readonly deferred;
    private constructor();
    get promise(): Promise<T>;
    
    static createAndSchedule<R extends unknown>(asyncQueue: AsyncQueue, timerId: TimerId, delayMs: number, op: () => Promise<R>, removalCallback: (op: DelayedOperation<R>) => void): DelayedOperation<R>;
    
    private start;
    
    skipDelay(): void;
    
    cancel(reason?: string): void;
    then: <TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
    private handleDelayElapsed;
    private clearTimeout;
}
interface AsyncQueue {
    readonly isShuttingDown: boolean;
    
    enqueueAndForget<T extends unknown>(op: () => Promise<T>): void;
    
    enqueueAndForgetEvenWhileRestricted<T extends unknown>(op: () => Promise<T>): void;
    
    enterRestrictedMode(purgeExistingTasks?: boolean): void;
    
    enqueue<T extends unknown>(op: () => Promise<T>): Promise<T>;
    
    enqueueRetryable(op: () => Promise<void>): void;
    
    enqueueAfterDelay<T extends unknown>(timerId: TimerId, delayMs: number, op: () => Promise<T>): DelayedOperation<T>;
    
    verifyOperationInProgress(): void;
}




type AuthTokenFactory = () => string;

interface FirstPartyCredentialsSettings {
    ['type']: 'firstParty';
    ['sessionIndex']: string;
    ['iamToken']: string | null;
    ['authTokenFactory']: AuthTokenFactory | null;
}
interface ProviderCredentialsSettings {
    ['type']: 'provider';
    ['client']: CredentialsProvider<User>;
}

type CredentialsSettings = FirstPartyCredentialsSettings | ProviderCredentialsSettings;
type TokenType = 'OAuth' | 'FirstParty' | 'AppCheck';
interface Token {
    
    type: TokenType;
    
    user?: User;
    
    headers: Map<string, string>;
}

type CredentialChangeListener<T> = (credential: T) => Promise<void>;

interface CredentialsProvider<T> {
    
    start(asyncQueue: AsyncQueue, changeListener: CredentialChangeListener<T>): void;
    
    getToken(): Promise<Token | null>;
    
    invalidateToken(): void;
    shutdown(): void;
}

declare class EmptyAuthCredentialsProvider implements CredentialsProvider<User> {
    getToken(): Promise<Token | null>;
    invalidateToken(): void;
    start(asyncQueue: AsyncQueue, changeListener: CredentialChangeListener<User>): void;
    shutdown(): void;
}

declare class EmptyAppCheckTokenProvider implements CredentialsProvider<string> {
    getToken(): Promise<Token | null>;
    invalidateToken(): void;
    start(asyncQueue: AsyncQueue, changeListener: CredentialChangeListener<string>): void;
    shutdown(): void;
}



interface ExperimentalLongPollingOptions {
    
    timeoutSeconds?: number;
}


declare class DatabaseInfo {
    readonly databaseId: DatabaseId;
    readonly appId: string;
    readonly persistenceKey: string;
    readonly host: string;
    readonly ssl: boolean;
    readonly forceLongPolling: boolean;
    readonly autoDetectLongPolling: boolean;
    readonly longPollingOptions: ExperimentalLongPollingOptions;
    readonly useFetchStreams: boolean;
    readonly isUsingEmulator: boolean;
    
    constructor(databaseId: DatabaseId, appId: string, persistenceKey: string, host: string, ssl: boolean, forceLongPolling: boolean, autoDetectLongPolling: boolean, longPollingOptions: ExperimentalLongPollingOptions, useFetchStreams: boolean, isUsingEmulator: boolean);
}

declare class DatabaseId {
    readonly projectId: string;
    readonly database: string;
    constructor(projectId: string, database?: string);
    static empty(): DatabaseId;
    get isDefaultDatabase(): boolean;
    isEqual(other: {}): boolean;
}



type BatchId = number;

type TargetId = number;
type ListenSequenceNumber = number;

declare const enum OnlineState {
    
    Unknown = "Unknown",
    
    Online = "Online",
    
    Offline = "Offline"
}


declare abstract class BasePath<B extends BasePath<B>> {
    private segments;
    private offset;
    private len;
    constructor(segments: string[], offset?: number, length?: number);
    
    protected abstract construct(segments: string[], offset?: number, length?: number): B;
    
    abstract toString(): string;
    get length(): number;
    isEqual(other: B): boolean;
    child(nameOrPath: string | B): B;
    
    private limit;
    popFirst(size?: number): B;
    popLast(): B;
    firstSegment(): string;
    lastSegment(): string;
    get(index: number): string;
    isEmpty(): boolean;
    isPrefixOf(other: this): boolean;
    isImmediateParentOf(potentialChild: this): boolean;
    forEach(fn: (segment: string) => void): void;
    toArray(): string[];
    
    static comparator<T extends BasePath<T>>(p1: BasePath<T>, p2: BasePath<T>): number;
    private static compareSegments;
    private static isNumericId;
    private static extractNumericId;
}

declare class ResourcePath extends BasePath<ResourcePath> {
    protected construct(segments: string[], offset?: number, length?: number): ResourcePath;
    canonicalString(): string;
    toString(): string;
    
    toUriEncodedString(): string;
    
    static fromString(...pathComponents: string[]): ResourcePath;
    static emptyPath(): ResourcePath;
}

declare class FieldPath$2 extends BasePath<FieldPath$2> {
    protected construct(segments: string[], offset?: number, length?: number): FieldPath$2;
    
    private static isValidIdentifier;
    canonicalString(): string;
    toString(): string;
    
    isKeyField(): boolean;
    
    static keyField(): FieldPath$2;
    
    static fromServerFormat(path: string): FieldPath$2;
    static emptyPath(): FieldPath$2;
}




type AggregateType = 'count' | 'avg' | 'sum';



type JsonTypeDesc = 'object' | 'string' | 'number' | 'boolean' | 'null' | 'undefined';

type TSType<T extends JsonTypeDesc> = T extends 'object' ? object : T extends 'string' ? string : T extends 'number' ? number : T extends 'boolean' ? boolean : T extends 'null' ? null : T extends 'undefined' ? undefined : never;

interface Property<T extends JsonTypeDesc> {
    value?: TSType<T>;
    typeString: JsonTypeDesc;
}




declare class Timestamp$1 {
    
    readonly seconds: number;
    
    readonly nanoseconds: number;
    
    static now(): Timestamp$1;
    
    static fromDate(date: Date): Timestamp$1;
    
    static fromMillis(milliseconds: number): Timestamp$1;
    
    constructor(
    
    seconds: number, 
    
    nanoseconds: number);
    
    toDate(): Date;
    
    toMillis(): number;
    _compareTo(other: Timestamp$1): number;
    
    isEqual(other: Timestamp$1): boolean;
    
    toString(): string;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        seconds: Property<"number">;
        nanoseconds: Property<"number">;
    };
    
    toJSON(): {
        seconds: number;
        nanoseconds: number;
        type: string;
    };
    
    static fromJSON(json: object): Timestamp$1;
    
    valueOf(): string;
}




declare class SnapshotVersion {
    private timestamp;
    static fromTimestamp(value: Timestamp$1): SnapshotVersion;
    static min(): SnapshotVersion;
    static max(): SnapshotVersion;
    private constructor();
    compareTo(other: SnapshotVersion): number;
    isEqual(other: SnapshotVersion): boolean;
    
    toMicroseconds(): number;
    toString(): string;
    toTimestamp(): Timestamp$1;
}




declare class DocumentKey {
    readonly path: ResourcePath;
    constructor(path: ResourcePath);
    static fromPath(path: string): DocumentKey;
    static fromName(name: string): DocumentKey;
    static empty(): DocumentKey;
    get collectionGroup(): string;
    
    hasCollectionId(collectionId: string): boolean;
    
    getCollectionGroup(): string;
    
    getCollectionPath(): ResourcePath;
    isEqual(other: DocumentKey | null): boolean;
    toString(): string;
    static comparator(k1: DocumentKey, k2: DocumentKey): number;
    static isDocumentKey(path: ResourcePath): boolean;
    
    static fromSegments(segments: string[]): DocumentKey;
}

interface ApiClientObjectMap<T> {
    [k: string]: T;
}
declare type Timestamp = string | {
    seconds?: string | number;
    nanos?: number;
};
declare type CompositeFilterOp = 'OPERATOR_UNSPECIFIED' | 'AND' | 'OR';
declare type FieldFilterOp = 'OPERATOR_UNSPECIFIED' | 'LESS_THAN' | 'LESS_THAN_OR_EQUAL' | 'GREATER_THAN' | 'GREATER_THAN_OR_EQUAL' | 'EQUAL' | 'NOT_EQUAL' | 'ARRAY_CONTAINS' | 'IN' | 'ARRAY_CONTAINS_ANY' | 'NOT_IN';
declare type FieldTransformSetToServerValue = 'SERVER_VALUE_UNSPECIFIED' | 'REQUEST_TIME';
declare type IndexFieldMode = 'MODE_UNSPECIFIED' | 'ASCENDING' | 'DESCENDING';
declare type IndexState$1 = 'STATE_UNSPECIFIED' | 'CREATING' | 'READY' | 'ERROR';
declare type OrderDirection = 'DIRECTION_UNSPECIFIED' | 'ASCENDING' | 'DESCENDING';
declare type TargetChangeTargetChangeType = 'NO_CHANGE' | 'ADD' | 'REMOVE' | 'CURRENT' | 'RESET';
declare type UnaryFilterOp = 'OPERATOR_UNSPECIFIED' | 'IS_NAN' | 'IS_NULL' | 'IS_NOT_NAN' | 'IS_NOT_NULL';
declare type ValueNullValue = 'NULL_VALUE';
declare namespace firestoreV1ApiClientInterfaces {
    interface ArrayValue {
        values?: Value[];
    }
    interface BatchGetDocumentsRequest {
        database?: string;
        documents?: string[];
        mask?: DocumentMask;
        transaction?: string;
        newTransaction?: TransactionOptions;
        readTime?: string;
    }
    interface BatchGetDocumentsResponse {
        found?: Document;
        missing?: string;
        transaction?: string;
        readTime?: string;
    }
    interface BeginTransactionRequest {
        options?: TransactionOptions;
    }
    interface BeginTransactionResponse {
        transaction?: string;
    }
    interface CollectionSelector {
        collectionId?: string;
        allDescendants?: boolean;
    }
    interface CommitRequest {
        database?: string;
        writes?: Write[];
        transaction?: string;
    }
    interface CommitResponse {
        writeResults?: WriteResult[];
        commitTime?: string;
    }
    interface CompositeFilter {
        op?: CompositeFilterOp;
        filters?: Filter[];
    }
    interface Cursor {
        values?: Value[];
        before?: boolean;
    }
    interface Document {
        name?: string;
        fields?: ApiClientObjectMap<Value>;
        createTime?: Timestamp;
        updateTime?: Timestamp;
    }
    interface DocumentChange {
        document?: Document;
        targetIds?: number[];
        removedTargetIds?: number[];
    }
    interface DocumentDelete {
        document?: string;
        removedTargetIds?: number[];
        readTime?: Timestamp;
    }
    interface DocumentMask {
        fieldPaths?: string[];
    }
    interface DocumentRemove {
        document?: string;
        removedTargetIds?: number[];
        readTime?: string;
    }
    interface DocumentTransform {
        document?: string;
        fieldTransforms?: FieldTransform[];
    }
    interface DocumentsTarget {
        documents?: string[];
    }
    interface Empty {
    }
    interface ExistenceFilter {
        targetId?: number;
        count?: number;
        unchangedNames?: BloomFilter;
    }
    interface BloomFilter {
        bits?: BitSequence;
        hashCount?: number;
    }
    interface BitSequence {
        bitmap?: string | Uint8Array;
        padding?: number;
    }
    interface FieldFilter {
        field?: FieldReference;
        op?: FieldFilterOp;
        value?: Value;
    }
    interface FieldReference {
        fieldPath?: string;
    }
    interface FieldTransform {
        fieldPath?: string;
        setToServerValue?: FieldTransformSetToServerValue;
        appendMissingElements?: ArrayValue;
        removeAllFromArray?: ArrayValue;
        increment?: Value;
    }
    interface Filter {
        compositeFilter?: CompositeFilter;
        fieldFilter?: FieldFilter;
        unaryFilter?: UnaryFilter;
    }
    interface Index {
        name?: string;
        collectionId?: string;
        fields?: IndexField[];
        state?: IndexState$1;
    }
    interface IndexField {
        fieldPath?: string;
        mode?: IndexFieldMode;
    }
    interface LatLng {
        latitude?: number;
        longitude?: number;
    }
    interface ListCollectionIdsRequest {
        pageSize?: number;
        pageToken?: string;
    }
    interface ListCollectionIdsResponse {
        collectionIds?: string[];
        nextPageToken?: string;
    }
    interface ListDocumentsResponse {
        documents?: Document[];
        nextPageToken?: string;
    }
    interface ListIndexesResponse {
        indexes?: Index[];
        nextPageToken?: string;
    }
    interface ListenRequest {
        addTarget?: Target;
        removeTarget?: number;
        labels?: ApiClientObjectMap<string>;
    }
    interface ListenResponse {
        targetChange?: TargetChange;
        documentChange?: DocumentChange;
        documentDelete?: DocumentDelete;
        documentRemove?: DocumentRemove;
        filter?: ExistenceFilter;
    }
    interface MapValue {
        fields?: ApiClientObjectMap<Value>;
    }
    interface Operation {
        name?: string;
        metadata?: ApiClientObjectMap<any>;
        done?: boolean;
        error?: Status;
        response?: ApiClientObjectMap<any>;
    }
    interface Order {
        field?: FieldReference;
        direction?: OrderDirection;
    }
    interface Precondition {
        exists?: boolean;
        updateTime?: Timestamp;
    }
    interface Projection {
        fields?: FieldReference[];
    }
    interface QueryTarget {
        parent?: string;
        structuredQuery?: StructuredQuery;
    }
    interface ReadOnly {
        readTime?: string;
    }
    interface ReadWrite {
        retryTransaction?: string;
    }
    interface RollbackRequest {
        transaction?: string;
    }
    interface RunQueryRequest {
        parent?: string;
        structuredQuery?: StructuredQuery;
        transaction?: string;
        newTransaction?: TransactionOptions;
        readTime?: string;
    }
    interface RunQueryResponse {
        transaction?: string;
        document?: Document;
        readTime?: string;
        skippedResults?: number;
    }
    interface RunAggregationQueryRequest {
        parent?: string;
        structuredAggregationQuery?: StructuredAggregationQuery;
        transaction?: string;
        newTransaction?: TransactionOptions;
        readTime?: string;
    }
    interface RunAggregationQueryResponse {
        result?: AggregationResult;
        transaction?: string;
        readTime?: string;
    }
    interface AggregationResult {
        aggregateFields?: ApiClientObjectMap<Value>;
    }
    interface StructuredAggregationQuery {
        structuredQuery?: StructuredQuery;
        aggregations?: Aggregation[];
    }
    interface Aggregation {
        count?: Count;
        sum?: Sum;
        avg?: Avg;
        alias?: string;
    }
    interface Count {
        upTo?: number;
    }
    interface Sum {
        field?: FieldReference;
    }
    interface Avg {
        field?: FieldReference;
    }
    interface Status {
        code?: number;
        message?: string;
        details?: Array<ApiClientObjectMap<any>>;
    }
    interface StructuredQuery {
        select?: Projection;
        from?: CollectionSelector[];
        where?: Filter;
        orderBy?: Order[];
        startAt?: Cursor;
        endAt?: Cursor;
        offset?: number;
        limit?: number | {
            value: number;
        };
    }
    interface Target {
        query?: QueryTarget;
        documents?: DocumentsTarget;
        resumeToken?: string | Uint8Array;
        readTime?: Timestamp;
        targetId?: number;
        once?: boolean;
        expectedCount?: number | {
            value: number;
        };
    }
    interface TargetChange {
        targetChangeType?: TargetChangeTargetChangeType;
        targetIds?: number[];
        cause?: Status;
        resumeToken?: string | Uint8Array;
        readTime?: Timestamp;
    }
    interface TransactionOptions {
        readOnly?: ReadOnly;
        readWrite?: ReadWrite;
    }
    interface UnaryFilter {
        op?: UnaryFilterOp;
        field?: FieldReference;
    }
    interface Value {
        nullValue?: ValueNullValue;
        booleanValue?: boolean;
        integerValue?: string | number;
        doubleValue?: string | number;
        timestampValue?: Timestamp;
        stringValue?: string;
        bytesValue?: string | Uint8Array;
        referenceValue?: string;
        geoPointValue?: LatLng;
        arrayValue?: ArrayValue;
        mapValue?: MapValue;
    }
    interface Write {
        update?: Document;
        delete?: string;
        verify?: string;
        transform?: DocumentTransform;
        updateMask?: DocumentMask;
        updateTransforms?: FieldTransform[];
        currentDocument?: Precondition;
    }
    interface WriteRequest {
        streamId?: string;
        writes?: Write[];
        streamToken?: string | Uint8Array;
        labels?: ApiClientObjectMap<string>;
    }
    interface WriteResponse {
        streamId?: string;
        streamToken?: string | Uint8Array;
        writeResults?: WriteResult[];
        commitTime?: Timestamp;
    }
    interface WriteResult {
        updateTime?: Timestamp;
        transformResults?: Value[];
    }
}
declare type MapValue = firestoreV1ApiClientInterfaces.MapValue;
declare type StructuredQuery = firestoreV1ApiClientInterfaces.StructuredQuery;
declare type Value = firestoreV1ApiClientInterfaces.Value;




declare class FieldMask {
    readonly fields: FieldPath$2[];
    constructor(fields: FieldPath$2[]);
    static empty(): FieldMask;
    
    unionWith(extraFields: FieldPath$2[]): FieldMask;
    
    covers(fieldPath: FieldPath$2): boolean;
    isEqual(other: FieldMask): boolean;
}




declare class ObjectValue {
    readonly value: {
        mapValue: MapValue;
    };
    constructor(value: {
        mapValue: MapValue;
    });
    static empty(): ObjectValue;
    
    field(path: FieldPath$2): Value | null;
    
    set(path: FieldPath$2, value: Value): void;
    
    setAll(data: Map<FieldPath$2, Value | null>): void;
    
    delete(path: FieldPath$2): void;
    isEqual(other: ObjectValue): boolean;
    
    private getFieldsMap;
    
    private applyChanges;
    clone(): ObjectValue;
}




interface Document {
    
    readonly key: DocumentKey;
    
    readonly version: SnapshotVersion;
    
    readonly readTime: SnapshotVersion;
    
    readonly createTime: SnapshotVersion;
    
    readonly data: ObjectValue;
    
    readonly hasLocalMutations: boolean;
    
    readonly hasCommittedMutations: boolean;
    
    readonly hasPendingWrites: boolean;
    
    isValidDocument(): boolean;
    
    isFoundDocument(): boolean;
    
    isNoDocument(): boolean;
    
    isUnknownDocument(): boolean;
    isEqual(other: Document | null | undefined): boolean;
    
    mutableCopy(): MutableDocument;
    toString(): string;
}

declare class MutableDocument implements Document {
    readonly key: DocumentKey;
    private documentType;
    version: SnapshotVersion;
    readTime: SnapshotVersion;
    createTime: SnapshotVersion;
    data: ObjectValue;
    private documentState;
    private constructor();
    
    static newInvalidDocument(documentKey: DocumentKey): MutableDocument;
    
    static newFoundDocument(documentKey: DocumentKey, version: SnapshotVersion, createTime: SnapshotVersion, value: ObjectValue): MutableDocument;
    
    static newNoDocument(documentKey: DocumentKey, version: SnapshotVersion): MutableDocument;
    
    static newUnknownDocument(documentKey: DocumentKey, version: SnapshotVersion): MutableDocument;
    
    convertToFoundDocument(version: SnapshotVersion, value: ObjectValue): MutableDocument;
    
    convertToNoDocument(version: SnapshotVersion): MutableDocument;
    
    convertToUnknownDocument(version: SnapshotVersion): MutableDocument;
    setHasCommittedMutations(): MutableDocument;
    setHasLocalMutations(): MutableDocument;
    setReadTime(readTime: SnapshotVersion): MutableDocument;
    get hasLocalMutations(): boolean;
    get hasCommittedMutations(): boolean;
    get hasPendingWrites(): boolean;
    isValidDocument(): boolean;
    isFoundDocument(): boolean;
    isNoDocument(): boolean;
    isUnknownDocument(): boolean;
    isEqual(other: Document | null | undefined): boolean;
    mutableCopy(): MutableDocument;
    toString(): string;
}



declare const enum Operator {
    LESS_THAN = "<",
    LESS_THAN_OR_EQUAL = "<=",
    EQUAL = "==",
    NOT_EQUAL = "!=",
    GREATER_THAN = ">",
    GREATER_THAN_OR_EQUAL = ">=",
    ARRAY_CONTAINS = "array-contains",
    IN = "in",
    NOT_IN = "not-in",
    ARRAY_CONTAINS_ANY = "array-contains-any"
}
declare const enum CompositeOperator {
    OR = "or",
    AND = "and"
}
declare abstract class Filter {
    abstract matches(doc: Document): boolean;
    abstract getFlattenedFilters(): readonly FieldFilter[];
    abstract getFilters(): Filter[];
}
declare class FieldFilter extends Filter {
    readonly field: FieldPath$2;
    readonly op: Operator;
    readonly value: Value;
    protected constructor(field: FieldPath$2, op: Operator, value: Value);
    
    static create(field: FieldPath$2, op: Operator, value: Value): FieldFilter;
    private static createKeyFieldInFilter;
    matches(doc: Document): boolean;
    protected matchesComparison(comparison: number): boolean;
    isInequality(): boolean;
    getFlattenedFilters(): readonly FieldFilter[];
    getFilters(): Filter[];
}




declare const enum Direction {
    ASCENDING = "asc",
    DESCENDING = "desc"
}

declare class OrderBy {
    readonly field: FieldPath$2;
    readonly dir: Direction;
    constructor(field: FieldPath$2, dir?: Direction);
}


type Comparator<K> = (key1: K, key2: K) => number;
interface Entry<K, V> {
    key: K;
    value: V;
}
declare class SortedMap<K, V> {
    comparator: Comparator<K>;
    root: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    constructor(comparator: Comparator<K>, root?: LLRBNode<K, V> | LLRBEmptyNode<K, V>);
    insert(key: K, value: V): SortedMap<K, V>;
    remove(key: K): SortedMap<K, V>;
    get(key: K): V | null;
    indexOf(key: K): number;
    isEmpty(): boolean;
    get size(): number;
    minKey(): K | null;
    maxKey(): K | null;
    inorderTraversal<T>(action: (k: K, v: V) => T): T;
    forEach(fn: (k: K, v: V) => void): void;
    toString(): string;
    reverseTraversal<T>(action: (k: K, v: V) => T): T;
    getIterator(): SortedMapIterator<K, V>;
    getIteratorFrom(key: K): SortedMapIterator<K, V>;
    getReverseIterator(): SortedMapIterator<K, V>;
    getReverseIteratorFrom(key: K): SortedMapIterator<K, V>;
}
declare class SortedMapIterator<K, V> {
    private isReverse;
    private nodeStack;
    constructor(node: LLRBNode<K, V> | LLRBEmptyNode<K, V>, startKey: K | null, comparator: Comparator<K>, isReverse: boolean);
    getNext(): Entry<K, V>;
    hasNext(): boolean;
    peek(): Entry<K, V> | null;
}
declare class LLRBNode<K, V> {
    key: K;
    value: V;
    readonly color: boolean;
    readonly left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    readonly right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    readonly size: number;
    static EMPTY: LLRBEmptyNode<any, any>;
    static RED: boolean;
    static BLACK: boolean;
    constructor(key: K, value: V, color?: boolean, left?: LLRBNode<K, V> | LLRBEmptyNode<K, V>, right?: LLRBNode<K, V> | LLRBEmptyNode<K, V>);
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBNode<K, V>;
    isEmpty(): boolean;
    inorderTraversal<T>(action: (k: K, v: V) => T): T;
    reverseTraversal<T>(action: (k: K, v: V) => T): T;
    private min;
    minKey(): K | null;
    maxKey(): K | null;
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    private removeMin;
    remove(key: K, comparator: Comparator<K>): LLRBNode<K, V> | LLRBEmptyNode<K, V>;
    isRed(): boolean;
    private fixUp;
    private moveRedLeft;
    private moveRedRight;
    private rotateLeft;
    private rotateRight;
    private colorFlip;
    checkMaxDepth(): boolean;
    protected check(): number;
}
declare class LLRBEmptyNode<K, V> {
    get key(): never;
    get value(): never;
    get color(): never;
    get left(): never;
    get right(): never;
    size: number;
    copy(key: K | null, value: V | null, color: boolean | null, left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null, right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null): LLRBEmptyNode<K, V>;
    insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V>;
    remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V>;
    isEmpty(): boolean;
    inorderTraversal(action: (k: K, v: V) => boolean): boolean;
    reverseTraversal(action: (k: K, v: V) => boolean): boolean;
    minKey(): K | null;
    maxKey(): K | null;
    isRed(): boolean;
    checkMaxDepth(): boolean;
    protected check(): 0;
}




declare class SortedSet<T> {
    private comparator;
    private data;
    constructor(comparator: (left: T, right: T) => number);
    has(elem: T): boolean;
    first(): T | null;
    last(): T | null;
    get size(): number;
    indexOf(elem: T): number;
    
    forEach(cb: (elem: T) => void): void;
    
    forEachInRange(range: [T, T], cb: (elem: T) => void): void;
    
    forEachWhile(cb: (elem: T) => boolean, start?: T): void;
    
    firstAfterOrEqual(elem: T): T | null;
    getIterator(): SortedSetIterator<T>;
    getIteratorFrom(key: T): SortedSetIterator<T>;
    
    add(elem: T): SortedSet<T>;
    
    delete(elem: T): SortedSet<T>;
    isEmpty(): boolean;
    unionWith(other: SortedSet<T>): SortedSet<T>;
    isEqual(other: SortedSet<T>): boolean;
    toArray(): T[];
    toString(): string;
    private copy;
}
declare class SortedSetIterator<T> {
    private iter;
    constructor(iter: SortedMapIterator<T, boolean>);
    getNext(): T;
    hasNext(): boolean;
}




declare class Bound {
    readonly position: Value[];
    readonly inclusive: boolean;
    constructor(position: Value[], inclusive: boolean);
}




declare class FieldIndex {
    
    readonly indexId: number;
    
    readonly collectionGroup: string;
    
    readonly fields: IndexSegment[];
    
    readonly indexState: IndexState;
    
    static UNKNOWN_ID: number;
    constructor(
    
    indexId: number, 
    
    collectionGroup: string, 
    
    fields: IndexSegment[], 
    
    indexState: IndexState);
}

declare const enum IndexKind {
    
    ASCENDING = 0,
    
    DESCENDING = 1,
    
    CONTAINS = 2
}

declare class IndexSegment {
    
    readonly fieldPath: FieldPath$2;
    
    readonly kind: IndexKind;
    constructor(
    
    fieldPath: FieldPath$2, 
    
    kind: IndexKind);
}

declare class IndexState {
    
    readonly sequenceNumber: number;
    
    readonly offset: IndexOffset;
    constructor(
    
    sequenceNumber: number, 
    
    offset: IndexOffset);
    
    static empty(): IndexState;
}

declare class IndexOffset {
    
    readonly readTime: SnapshotVersion;
    
    readonly documentKey: DocumentKey;
    readonly largestBatchId: number;
    constructor(
    
    readTime: SnapshotVersion, 
    
    documentKey: DocumentKey, largestBatchId: number);
    
    static min(): IndexOffset;
    
    static max(): IndexOffset;
}




interface Target {
    readonly path: ResourcePath;
    readonly collectionGroup: string | null;
    readonly orderBy: OrderBy[];
    readonly filters: Filter[];
    readonly limit: number | null;
    readonly startAt: Bound | null;
    readonly endAt: Bound | null;
}



declare const enum LimitType$1 {
    First = "F",
    Last = "L"
}

interface Query$2 {
    readonly path: ResourcePath;
    readonly collectionGroup: string | null;
    readonly explicitOrderBy: OrderBy[];
    readonly filters: Filter[];
    readonly limit: number | null;
    readonly limitType: LimitType$1;
    readonly startAt: Bound | null;
    readonly endAt: Bound | null;
}



declare class ByteString {
    private readonly binaryString;
    static readonly EMPTY_BYTE_STRING: ByteString;
    private constructor();
    static fromBase64String(base64: string): ByteString;
    static fromUint8Array(array: Uint8Array): ByteString;
    [Symbol.iterator](): Iterator<number>;
    toBase64(): string;
    toUint8Array(): Uint8Array;
    approximateByteSize(): number;
    compareTo(other: ByteString): number;
    isEqual(other: ByteString): boolean;
}




declare const enum TargetPurpose {
    
    Listen = "TargetPurposeListen",
    
    ExistenceFilterMismatch = "TargetPurposeExistenceFilterMismatch",
    
    ExistenceFilterMismatchBloom = "TargetPurposeExistenceFilterMismatchBloom",
    
    LimboResolution = "TargetPurposeLimboResolution"
}

declare class TargetData {
    
    readonly target: Target;
    
    readonly targetId: TargetId;
    
    readonly purpose: TargetPurpose;
    
    readonly sequenceNumber: ListenSequenceNumber;
    
    readonly snapshotVersion: SnapshotVersion;
    
    readonly lastLimboFreeSnapshotVersion: SnapshotVersion;
    
    readonly resumeToken: ByteString;
    
    readonly expectedCount: number | null;
    constructor(
    
    target: Target, 
    
    targetId: TargetId, 
    
    purpose: TargetPurpose, 
    
    sequenceNumber: ListenSequenceNumber, 
    
    snapshotVersion?: SnapshotVersion, 
    
    lastLimboFreeSnapshotVersion?: SnapshotVersion, 
    
    resumeToken?: ByteString, 
    
    expectedCount?: number | null);
    
    withSequenceNumber(sequenceNumber: number): TargetData;
    
    withResumeToken(resumeToken: ByteString, snapshotVersion: SnapshotVersion): TargetData;
    
    withExpectedCount(expectedCount: number): TargetData;
    
    withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion: SnapshotVersion): TargetData;
}




interface Serializer {
    readonly useProto3Json: boolean;
}




declare class TransformOperation {
    private _;
}




declare class FieldTransform {
    readonly field: FieldPath$2;
    readonly transform: TransformOperation;
    constructor(field: FieldPath$2, transform: TransformOperation);
}

declare class MutationResult {
    
    readonly version: SnapshotVersion;
    
    readonly transformResults: Array<Value | null>;
    constructor(
    
    version: SnapshotVersion, 
    
    transformResults: Array<Value | null>);
}
declare const enum MutationType {
    Set = 0,
    Patch = 1,
    Delete = 2,
    Verify = 3
}

declare class Precondition {
    readonly updateTime?: SnapshotVersion | undefined;
    readonly exists?: boolean | undefined;
    private constructor();
    
    static none(): Precondition;
    
    static exists(exists: boolean): Precondition;
    
    static updateTime(version: SnapshotVersion): Precondition;
    
    get isNone(): boolean;
    isEqual(other: Precondition): boolean;
}

declare abstract class Mutation {
    abstract readonly type: MutationType;
    abstract readonly key: DocumentKey;
    abstract readonly precondition: Precondition;
    abstract readonly fieldTransforms: FieldTransform[];
    
    abstract getFieldMask(): FieldMask | null;
}




declare class OverlayedDocument {
    readonly overlayedDocument: Document;
    
    readonly mutatedFields: FieldMask | null;
    constructor(overlayedDocument: Document, 
    
    mutatedFields: FieldMask | null);
}



declare class ObjectMap<KeyType, ValueType> {
    private mapKeyFn;
    private equalsFn;
    
    private inner;
    
    private innerSize;
    constructor(mapKeyFn: (key: KeyType) => string, equalsFn: (l: KeyType, r: KeyType) => boolean);
    
    get(key: KeyType): ValueType | undefined;
    has(key: KeyType): boolean;
    
    set(key: KeyType, value: ValueType): void;
    
    delete(key: KeyType): boolean;
    forEach(fn: (key: KeyType, val: ValueType) => void): void;
    isEmpty(): boolean;
    size(): number;
}




declare class Overlay {
    readonly largestBatchId: number;
    readonly mutation: Mutation;
    constructor(largestBatchId: number, mutation: Mutation);
    getKey(): DocumentKey;
    isEqual(other: Overlay | null): boolean;
    toString(): string;
}




type MutableDocumentMap = SortedMap<DocumentKey, MutableDocument>;
type DocumentMap = SortedMap<DocumentKey, Document>;
type OverlayedDocumentMap = DocumentKeyMap<OverlayedDocument>;
type OverlayMap = DocumentKeyMap<Overlay>;
type MutationMap = DocumentKeyMap<Mutation>;
type DocumentKeyMap<T> = ObjectMap<DocumentKey, T>;
type DocumentVersionMap = SortedMap<DocumentKey, SnapshotVersion>;
type DocumentKeySet = SortedSet<DocumentKey>;




declare class RemoteEvent {
    
    readonly snapshotVersion: SnapshotVersion;
    
    readonly targetChanges: Map<TargetId, TargetChange>;
    
    readonly targetMismatches: SortedMap<TargetId, TargetPurpose>;
    
    readonly documentUpdates: MutableDocumentMap;
    
    readonly resolvedLimboDocuments: DocumentKeySet;
    constructor(
    
    snapshotVersion: SnapshotVersion, 
    
    targetChanges: Map<TargetId, TargetChange>, 
    
    targetMismatches: SortedMap<TargetId, TargetPurpose>, 
    
    documentUpdates: MutableDocumentMap, 
    
    resolvedLimboDocuments: DocumentKeySet);
    
    static createSynthesizedRemoteEventForCurrentChange(targetId: TargetId, current: boolean, resumeToken: ByteString): RemoteEvent;
}

declare class TargetChange {
    
    readonly resumeToken: ByteString;
    
    readonly current: boolean;
    
    readonly addedDocuments: DocumentKeySet;
    
    readonly modifiedDocuments: DocumentKeySet;
    
    readonly removedDocuments: DocumentKeySet;
    constructor(
    
    resumeToken: ByteString, 
    
    current: boolean, 
    
    addedDocuments: DocumentKeySet, 
    
    modifiedDocuments: DocumentKeySet, 
    
    removedDocuments: DocumentKeySet);
    
    static createSynthesizedTargetChangeForCurrentChange(targetId: TargetId, current: boolean, resumeToken: ByteString): TargetChange;
}




declare class JsonProtoSerializer implements Serializer {
    readonly databaseId: DatabaseId;
    readonly useProto3Json: boolean;
    constructor(databaseId: DatabaseId, useProto3Json: boolean);
}




type DocumentData$1 = { [field: string]: any };

type UpdateData$1 = { [fieldPath: string]: any };

interface Settings {
  host?: string;
  ssl?: boolean;
  cacheSizeBytes?: number;
  experimentalForceLongPolling?: boolean;
  experimentalAutoDetectLongPolling?: boolean;
  ignoreUndefinedProperties?: boolean;
  merge?: boolean;
}

interface PersistenceSettings$1 {
  synchronizeTabs?: boolean;
  experimentalTabSynchronization?: boolean;
  experimentalForceOwningTab?: boolean;
}

interface FirestoreDataConverter$2<T> {
  toFirestore(modelObject: T): DocumentData$1;
  toFirestore(modelObject: Partial<T>, options: SetOptions$1): DocumentData$1;

  fromFirestore(snapshot: QueryDocumentSnapshot$2, options: SnapshotOptions$1): T;
}

declare class FirebaseFirestore {
  private constructor();

  settings(settings: Settings): void;

  useEmulator(
    host: string,
    port: number,
    options?: {
      mockUserToken?: EmulatorMockTokenOptions | string;
    }
  ): void;

  enablePersistence(settings?: PersistenceSettings$1): Promise<void>;

  collection(collectionPath: string): CollectionReference$1<DocumentData$1>;

  doc(documentPath: string): DocumentReference$1<DocumentData$1>;

  collectionGroup(collectionId: string): Query$1<DocumentData$1>;

  runTransaction<T>(
    updateFunction: (transaction: Transaction$3) => Promise<T>
  ): Promise<T>;

  batch(): WriteBatch$1;

  app: any;

  clearPersistence(): Promise<void>;

  enableNetwork(): Promise<void>;

  disableNetwork(): Promise<void>;

  waitForPendingWrites(): Promise<void>;

  onSnapshotsInSync(observer: {
    next?: (value: void) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
  }): () => void;
  onSnapshotsInSync(onSync: () => void): () => void;

  terminate(): Promise<void>;

  loadBundle(
    bundleData: ArrayBuffer | ReadableStream<Uint8Array> | string
  ): LoadBundleTask$1;

  namedQuery(name: string): Promise<Query$1<DocumentData$1> | null>;

  INTERNAL: { delete: () => Promise<void> };
}

interface LoadBundleTask$1 extends PromiseLike<LoadBundleTaskProgress$1> {
  onProgress(
    next?: (progress: LoadBundleTaskProgress$1) => any,
    error?: (error: Error) => any,
    complete?: () => void
  ): void;

  then<T, R>(
    onFulfilled?: (a: LoadBundleTaskProgress$1) => T | PromiseLike<T>,
    onRejected?: (a: Error) => R | PromiseLike<R>
  ): Promise<T | R>;

  catch<R>(
    onRejected: (a: Error) => R | PromiseLike<R>
  ): Promise<R | LoadBundleTaskProgress$1>;
}

interface LoadBundleTaskProgress$1 {
  documentsLoaded: number;
  totalDocuments: number;
  bytesLoaded: number;
  totalBytes: number;
  taskState: TaskState$1;
}

type TaskState$1 = 'Error' | 'Running' | 'Success';

declare class Transaction$3 {
  private constructor();

  get<T>(documentRef: DocumentReference$1<T>): Promise<DocumentSnapshot$2<T>>;

  set<T>(
    documentRef: DocumentReference$1<T>,
    data: Partial<T>,
    options: SetOptions$1
  ): Transaction$3;
  set<T>(documentRef: DocumentReference$1<T>, data: T): Transaction$3;

  update(documentRef: DocumentReference$1<any>, data: UpdateData$1): Transaction$3;
  update(
    documentRef: DocumentReference$1<any>,
    field: string | FieldPath$1,
    value: any,
    ...moreFieldsAndValues: any[]
  ): Transaction$3;

  delete(documentRef: DocumentReference$1<any>): Transaction$3;
}

declare class WriteBatch$1 {
  private constructor();

  set<T>(
    documentRef: DocumentReference$1<T>,
    data: Partial<T>,
    options: SetOptions$1
  ): WriteBatch$1;
  set<T>(documentRef: DocumentReference$1<T>, data: T): WriteBatch$1;

  update(documentRef: DocumentReference$1<any>, data: UpdateData$1): WriteBatch$1;
  update(
    documentRef: DocumentReference$1<any>,
    field: string | FieldPath$1,
    value: any,
    ...moreFieldsAndValues: any[]
  ): WriteBatch$1;

  delete(documentRef: DocumentReference$1<any>): WriteBatch$1;

  commit(): Promise<void>;
}

interface SnapshotListenOptions$1 {
  readonly includeMetadataChanges?: boolean;
}

interface SetOptions$1 {
  readonly merge?: boolean;
  readonly mergeFields?: (string | FieldPath$1)[];
}

interface GetOptions {
  readonly source?: 'default' | 'server' | 'cache';
}

declare class DocumentReference$1<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> {
  private constructor();

  readonly id: string;
  readonly firestore: FirebaseFirestore;
  readonly parent: CollectionReference$1<T>;
  readonly path: string;

  collection(collectionPath: string): CollectionReference$1<DocumentData$1>;

  isEqual(other: DocumentReference$1<T>): boolean;

  set(data: Partial<T>, options: SetOptions$1): Promise<void>;
  set(data: T): Promise<void>;

  update(data: UpdateData$1): Promise<void>;
  update(
    field: string | FieldPath$1,
    value: any,
    ...moreFieldsAndValues: any[]
  ): Promise<void>;

  delete(): Promise<void>;

  get(options?: GetOptions): Promise<DocumentSnapshot$2<T>>;

  onSnapshot(observer: {
    next?: (snapshot: DocumentSnapshot$2<T>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
  }): () => void;
  onSnapshot(
    options: SnapshotListenOptions$1,
    observer: {
      next?: (snapshot: DocumentSnapshot$2<T>) => void;
      error?: (error: FirestoreError) => void;
      complete?: () => void;
    }
  ): () => void;
  onSnapshot(
    onNext: (snapshot: DocumentSnapshot$2<T>) => void,
    onError?: (error: FirestoreError) => void,
    onCompletion?: () => void
  ): () => void;
  onSnapshot(
    options: SnapshotListenOptions$1,
    onNext: (snapshot: DocumentSnapshot$2<T>) => void,
    onError?: (error: FirestoreError) => void,
    onCompletion?: () => void
  ): () => void;

  withConverter(converter: null): DocumentReference$1<DocumentData$1>;
  withConverter<U>(converter: FirestoreDataConverter$2<U>): DocumentReference$1<U>;
}

interface SnapshotOptions$1 {
  readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
}

interface SnapshotMetadata$1 {
  readonly hasPendingWrites: boolean;
  readonly fromCache: boolean;

  isEqual(other: SnapshotMetadata$1): boolean;
}

declare class DocumentSnapshot$2<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> {
  protected constructor();

  readonly exists: boolean;
  readonly ref: DocumentReference$1<T>;
  readonly id: string;
  readonly metadata: SnapshotMetadata$1;

  data(options?: SnapshotOptions$1): T | undefined;

  get(fieldPath: string | FieldPath$1, options?: SnapshotOptions$1): any;

  isEqual(other: DocumentSnapshot$2<T>): boolean;
}

declare class QueryDocumentSnapshot$2<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> extends DocumentSnapshot$2<T, T2> {
  private constructor();

  data(options?: SnapshotOptions$1): T;
}

type OrderByDirection$1 = 'desc' | 'asc';

type WhereFilterOp$1 =
  | '<'
  | '<='
  | '=='
  | '!='
  | '>='
  | '>'
  | 'array-contains'
  | 'in'
  | 'array-contains-any'
  | 'not-in';

declare class Query$1<T = DocumentData$1, T2 extends DocumentData$1 = DocumentData$1> {
  protected constructor();

  readonly firestore: FirebaseFirestore;

  where(
    fieldPath: string | FieldPath$1,
    opStr: WhereFilterOp$1,
    value: any
  ): Query$1<T>;

  orderBy(
    fieldPath: string | FieldPath$1,
    directionStr?: OrderByDirection$1
  ): Query$1<T>;

  limit(limit: number): Query$1<T>;

  limitToLast(limit: number): Query$1<T>;

  startAt(snapshot: DocumentSnapshot$2<any>): Query$1<T>;
  startAt(...fieldValues: any[]): Query$1<T>;

  startAfter(snapshot: DocumentSnapshot$2<any>): Query$1<T>;
  startAfter(...fieldValues: any[]): Query$1<T>;

  endBefore(snapshot: DocumentSnapshot$2<any>): Query$1<T>;
  endBefore(...fieldValues: any[]): Query$1<T>;

  endAt(snapshot: DocumentSnapshot$2<any>): Query$1<T>;
  endAt(...fieldValues: any[]): Query$1<T>;

  isEqual(other: Query$1<T>): boolean;

  get(options?: GetOptions): Promise<QuerySnapshot$1<T>>;

  onSnapshot(observer: {
    next?: (snapshot: QuerySnapshot$1<T>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
  }): () => void;
  onSnapshot(
    options: SnapshotListenOptions$1,
    observer: {
      next?: (snapshot: QuerySnapshot$1<T>) => void;
      error?: (error: FirestoreError) => void;
      complete?: () => void;
    }
  ): () => void;
  onSnapshot(
    onNext: (snapshot: QuerySnapshot$1<T>) => void,
    onError?: (error: FirestoreError) => void,
    onCompletion?: () => void
  ): () => void;
  onSnapshot(
    options: SnapshotListenOptions$1,
    onNext: (snapshot: QuerySnapshot$1<T>) => void,
    onError?: (error: FirestoreError) => void,
    onCompletion?: () => void
  ): () => void;

  withConverter(converter: null): Query$1<DocumentData$1>;
  withConverter<U>(converter: FirestoreDataConverter$2<U>): Query$1<U>;
}

declare class QuerySnapshot$1<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> {
  private constructor();

  readonly query: Query$1<T>;
  readonly metadata: SnapshotMetadata$1;
  readonly docs: Array<QueryDocumentSnapshot$2<T>>;
  readonly size: number;
  readonly empty: boolean;

  docChanges(options?: SnapshotListenOptions$1): Array<DocumentChange$1<T>>;

  forEach(
    callback: (result: QueryDocumentSnapshot$2<T>) => void,
    thisArg?: any
  ): void;

  isEqual(other: QuerySnapshot$1<T>): boolean;
}

type DocumentChangeType$1 = 'added' | 'removed' | 'modified';

interface DocumentChange$1<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> {
  readonly type: DocumentChangeType$1;
  readonly doc: QueryDocumentSnapshot$2<T>;
  readonly oldIndex: number;
  readonly newIndex: number;
}

declare class CollectionReference$1<
  T = DocumentData$1,
  T2 extends DocumentData$1 = DocumentData$1
> extends Query$1<T, T2> {
  private constructor();

  readonly id: string;
  readonly parent: DocumentReference$1<DocumentData$1> | null;
  readonly path: string;

  doc(documentPath?: string): DocumentReference$1<T>;

  add(data: T): Promise<DocumentReference$1<T>>;

  isEqual(other: CollectionReference$1<T>): boolean;

  withConverter(converter: null): CollectionReference$1<DocumentData$1>;
  withConverter<U>(
    converter: FirestoreDataConverter$2<U>
  ): CollectionReference$1<U>;
}

declare class FieldPath$1 {
  constructor(...fieldNames: string[]);

  static documentId(): FieldPath$1;

  isEqual(other: FieldPath$1): boolean;
}

type FirestoreErrorCode =
  | 'cancelled'
  | 'unknown'
  | 'invalid-argument'
  | 'deadline-exceeded'
  | 'not-found'
  | 'already-exists'
  | 'permission-denied'
  | 'resource-exhausted'
  | 'failed-precondition'
  | 'aborted'
  | 'out-of-range'
  | 'unimplemented'
  | 'internal'
  | 'unavailable'
  | 'data-loss'
  | 'unauthenticated';

interface FirestoreError {
  code: FirestoreErrorCode;
  message: string;
  name: string;
  stack?: string;
}

declare module '@firebase/component' {
  interface NameServiceMapping {
    'firestore-compat': FirebaseFirestore;
  }
}




interface BundledQuery {
    
    parent?: string | null;
    
    structuredQuery?: StructuredQuery | null;
    
    limitType?: LimitType | null;
}

type LimitType = 'FIRST' | 'LAST';

interface NamedQuery$1 {
    
    name?: string | null;
    
    bundledQuery?: BundledQuery | null;
    
    readTime?: Timestamp | null;
}

interface BundleMetadata$1 {
    
    id?: string | null;
    
    createTime?: Timestamp | null;
    
    version?: number | null;
    
    totalDocuments?: number | null;
    
    totalBytes?: number | null;
}




interface BundleMetadata {
    
    readonly id: string;
    
    readonly version: number;
    
    readonly createTime: SnapshotVersion;
}

interface NamedQuery {
    
    readonly name: string;
    
    readonly query: Query$2;
    
    readonly readTime: SnapshotVersion;
}


type FulfilledHandler<T, R> = ((result: T) => R | PersistencePromise<R>) | null;
type RejectedHandler<R> = ((reason: Error) => R | PersistencePromise<R>) | null;
type Resolver<T> = (value?: T) => void;
type Rejector = (error: Error) => void;

declare class PersistencePromise<T> {
    private nextCallback;
    private catchCallback;
    private result;
    private error;
    private isDone;
    private callbackAttached;
    constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void);
    catch<R>(fn: (error: Error) => R | PersistencePromise<R>): PersistencePromise<R>;
    next<R>(nextFn?: FulfilledHandler<T, R>, catchFn?: RejectedHandler<R>): PersistencePromise<R>;
    toPromise(): Promise<T>;
    private wrapUserFunction;
    private wrapSuccess;
    private wrapFailure;
    static resolve(): PersistencePromise<void>;
    static resolve<R>(result: R): PersistencePromise<R>;
    static reject<R>(error: Error): PersistencePromise<R>;
    static waitFor(all: {
        forEach: (cb: (el: PersistencePromise<any>) => void) => void;
    }): PersistencePromise<void>;
    
    static or(predicates: Array<() => PersistencePromise<boolean>>): PersistencePromise<boolean>;
    
    static forEach<R, S>(collection: {
        forEach: (cb: (r: R, s: S) => void) => void;
    }, f: ((r: R, s: S) => PersistencePromise<void>) | ((r: R) => PersistencePromise<void>)): PersistencePromise<void>;
    static forEach<R>(collection: {
        forEach: (cb: (r: R) => void) => void;
    }, f: (r: R) => PersistencePromise<void>): PersistencePromise<void>;
    
    static mapArray<T, U>(array: T[], f: (t: T) => PersistencePromise<U>): PersistencePromise<U[]>;
    
    static doWhile(condition: () => boolean, action: () => PersistencePromise<void>): PersistencePromise<void>;
}




type PersistenceTransactionMode = 'readonly' | 'readwrite' | 'readwrite-primary';

declare abstract class PersistenceTransaction {
    private readonly onCommittedListeners;
    abstract readonly currentSequenceNumber: ListenSequenceNumber;
    addOnCommittedListener(listener: () => void): void;
    raiseOnCommittedEvent(): void;
}




interface BundleCache {
    
    getBundleMetadata(transaction: PersistenceTransaction, bundleId: string): PersistencePromise<BundleMetadata | undefined>;
    
    saveBundleMetadata(transaction: PersistenceTransaction, metadata: BundleMetadata$1): PersistencePromise<void>;
    
    getNamedQuery(transaction: PersistenceTransaction, queryName: string): PersistencePromise<NamedQuery | undefined>;
    
    saveNamedQuery(transaction: PersistenceTransaction, query: NamedQuery$1): PersistencePromise<void>;
}




interface DocumentOverlayCache {
    
    getOverlay(transaction: PersistenceTransaction, key: DocumentKey): PersistencePromise<Overlay | null>;
    
    getOverlays(transaction: PersistenceTransaction, keys: DocumentKey[]): PersistencePromise<OverlayMap>;
    
    saveOverlays(transaction: PersistenceTransaction, largestBatchId: number, overlays: MutationMap): PersistencePromise<void>;
    
    removeOverlaysForBatchId(transaction: PersistenceTransaction, documentKeys: DocumentKeySet, batchId: number): PersistencePromise<void>;
    
    getOverlaysForCollection(transaction: PersistenceTransaction, collection: ResourcePath, sinceBatchId: number): PersistencePromise<OverlayMap>;
    
    getOverlaysForCollectionGroup(transaction: PersistenceTransaction, collectionGroup: string, sinceBatchId: number, count: number): PersistencePromise<OverlayMap>;
}




interface GlobalsCache {
    
    getSessionToken(transaction: PersistenceTransaction): PersistencePromise<ByteString>;
    
    setSessionToken(transaction: PersistenceTransaction, sessionToken: ByteString): PersistencePromise<void>;
}




declare const enum IndexType {
    
    NONE = 0,
    
    PARTIAL = 1,
    
    FULL = 2
}

interface IndexManager {
    
    addToCollectionParentIndex(transaction: PersistenceTransaction, collectionPath: ResourcePath): PersistencePromise<void>;
    
    getCollectionParents(transaction: PersistenceTransaction, collectionId: string): PersistencePromise<ResourcePath[]>;
    
    addFieldIndex(transaction: PersistenceTransaction, index: FieldIndex): PersistencePromise<void>;
    
    deleteFieldIndex(transaction: PersistenceTransaction, index: FieldIndex): PersistencePromise<void>;
    
    deleteAllFieldIndexes(transaction: PersistenceTransaction): PersistencePromise<void>;
    
    createTargetIndexes(transaction: PersistenceTransaction, target: Target): PersistencePromise<void>;
    
    getFieldIndexes(transaction: PersistenceTransaction, collectionGroup: string): PersistencePromise<FieldIndex[]>;
    
    getFieldIndexes(transaction: PersistenceTransaction): PersistencePromise<FieldIndex[]>;
    
    getIndexType(transaction: PersistenceTransaction, target: Target): PersistencePromise<IndexType>;
    
    getDocumentsMatchingTarget(transaction: PersistenceTransaction, target: Target): PersistencePromise<DocumentKey[] | null>;
    
    getNextCollectionGroupToUpdate(transaction: PersistenceTransaction): PersistencePromise<string | null>;
    
    updateCollectionGroup(transaction: PersistenceTransaction, collectionGroup: string, offset: IndexOffset): PersistencePromise<void>;
    
    updateIndexEntries(transaction: PersistenceTransaction, documents: DocumentMap): PersistencePromise<void>;
    
    getMinOffset(transaction: PersistenceTransaction, target: Target): PersistencePromise<IndexOffset>;
    
    getMinOffsetFromCollectionGroup(transaction: PersistenceTransaction, collectionGroup: string): PersistencePromise<IndexOffset>;
}




type ActiveTargets = SortedMap<TargetId, unknown>;
declare class LruParams {
    readonly cacheSizeCollectionThreshold: number;
    readonly percentileToCollect: number;
    readonly maximumSequenceNumbersToCollect: number;
    private static readonly DEFAULT_COLLECTION_PERCENTILE;
    private static readonly DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT;
    static withCacheSize(cacheSize: number): LruParams;
    static readonly DEFAULT: LruParams;
    static readonly DISABLED: LruParams;
    constructor(cacheSizeCollectionThreshold: number, percentileToCollect: number, maximumSequenceNumbersToCollect: number);
}
interface LruGarbageCollector {
    readonly params: LruParams;
    collect(txn: PersistenceTransaction, activeTargetIds: ActiveTargets): PersistencePromise<LruResults>;
    
    calculateTargetCount(txn: PersistenceTransaction, percentile: number): PersistencePromise<number>;
    
    nthSequenceNumber(txn: PersistenceTransaction, n: number): PersistencePromise<number>;
    
    removeOrphanedDocuments(txn: PersistenceTransaction, upperBound: ListenSequenceNumber): PersistencePromise<number>;
    getCacheSize(txn: PersistenceTransaction): PersistencePromise<number>;
    
    removeTargets(txn: PersistenceTransaction, upperBound: ListenSequenceNumber, activeTargetIds: ActiveTargets): PersistencePromise<number>;
}

interface LruResults {
    readonly didRun: boolean;
    readonly sequenceNumbersCollected: number;
    readonly targetsRemoved: number;
    readonly documentsRemoved: number;
}




declare class MutationBatch {
    batchId: BatchId;
    localWriteTime: Timestamp$1;
    baseMutations: Mutation[];
    mutations: Mutation[];
    
    constructor(batchId: BatchId, localWriteTime: Timestamp$1, baseMutations: Mutation[], mutations: Mutation[]);
    
    applyToRemoteDocument(document: MutableDocument, batchResult: MutationBatchResult): void;
    
    applyToLocalView(document: MutableDocument, mutatedFields: FieldMask | null): FieldMask | null;
    
    applyToLocalDocumentSet(documentMap: OverlayedDocumentMap, documentsWithoutRemoteVersion: DocumentKeySet): MutationMap;
    keys(): DocumentKeySet;
    isEqual(other: MutationBatch): boolean;
}

declare class MutationBatchResult {
    readonly batch: MutationBatch;
    readonly commitVersion: SnapshotVersion;
    readonly mutationResults: MutationResult[];
    
    readonly docVersions: DocumentVersionMap;
    private constructor();
    
    static from(batch: MutationBatch, commitVersion: SnapshotVersion, results: MutationResult[]): MutationBatchResult;
}




interface MutationQueue {
    
    checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean>;
    
    addMutationBatch(transaction: PersistenceTransaction, localWriteTime: Timestamp$1, baseMutations: Mutation[], mutations: Mutation[]): PersistencePromise<MutationBatch>;
    
    lookupMutationBatch(transaction: PersistenceTransaction, batchId: BatchId): PersistencePromise<MutationBatch | null>;
    
    getNextMutationBatchAfterBatchId(transaction: PersistenceTransaction, batchId: BatchId): PersistencePromise<MutationBatch | null>;
    
    getHighestUnacknowledgedBatchId(transaction: PersistenceTransaction): PersistencePromise<BatchId>;
    
    getAllMutationBatches(transaction: PersistenceTransaction): PersistencePromise<MutationBatch[]>;
    
    getAllMutationBatchesAffectingDocumentKey(transaction: PersistenceTransaction, documentKey: DocumentKey): PersistencePromise<MutationBatch[]>;
    
    getAllMutationBatchesAffectingDocumentKeys(transaction: PersistenceTransaction, documentKeys: SortedMap<DocumentKey, unknown>): PersistencePromise<MutationBatch[]>;
    
    getAllMutationBatchesAffectingQuery(transaction: PersistenceTransaction, query: Query$2): PersistencePromise<MutationBatch[]>;
    
    removeMutationBatch(transaction: PersistenceTransaction, batch: MutationBatch): PersistencePromise<void>;
    
    performConsistencyCheck(transaction: PersistenceTransaction): PersistencePromise<void>;
}



declare class QueryContext {
    
    private _documentReadCount;
    get documentReadCount(): number;
    incrementDocumentReadCount(amount: number): void;
}




declare abstract class RemoteDocumentChangeBuffer {
    protected changes: ObjectMap<DocumentKey, MutableDocument>;
    private changesApplied;
    protected abstract getFromCache(transaction: PersistenceTransaction, documentKey: DocumentKey): PersistencePromise<MutableDocument>;
    protected abstract getAllFromCache(transaction: PersistenceTransaction, documentKeys: DocumentKeySet): PersistencePromise<MutableDocumentMap>;
    protected abstract applyChanges(transaction: PersistenceTransaction): PersistencePromise<void>;
    
    addEntry(document: MutableDocument): void;
    
    removeEntry(key: DocumentKey, readTime: SnapshotVersion): void;
    
    getEntry(transaction: PersistenceTransaction, documentKey: DocumentKey): PersistencePromise<MutableDocument>;
    
    getEntries(transaction: PersistenceTransaction, documentKeys: DocumentKeySet): PersistencePromise<MutableDocumentMap>;
    
    apply(transaction: PersistenceTransaction): PersistencePromise<void>;
    
    protected assertNotApplied(): void;
}




interface RemoteDocumentCache {
    
    setIndexManager(indexManager: IndexManager): void;
    
    getEntry(transaction: PersistenceTransaction, documentKey: DocumentKey): PersistencePromise<MutableDocument>;
    
    getEntries(transaction: PersistenceTransaction, documentKeys: DocumentKeySet): PersistencePromise<MutableDocumentMap>;
    
    getDocumentsMatchingQuery(transaction: PersistenceTransaction, query: Query$2, offset: IndexOffset, mutatedDocs: OverlayMap, context?: QueryContext): PersistencePromise<MutableDocumentMap>;
    
    getAllFromCollectionGroup(transaction: PersistenceTransaction, collectionGroup: string, offset: IndexOffset, limit: number): PersistencePromise<MutableDocumentMap>;
    
    newChangeBuffer(options?: {
        trackRemovals: boolean;
    }): RemoteDocumentChangeBuffer;
    
    getSize(transaction: PersistenceTransaction): PersistencePromise<number>;
}




interface TargetCache {
    
    getLastRemoteSnapshotVersion(transaction: PersistenceTransaction): PersistencePromise<SnapshotVersion>;
    
    getHighestSequenceNumber(transaction: PersistenceTransaction): PersistencePromise<ListenSequenceNumber>;
    
    forEachTarget(txn: PersistenceTransaction, f: (q: TargetData) => void): PersistencePromise<void>;
    
    setTargetsMetadata(transaction: PersistenceTransaction, highestListenSequenceNumber: number, lastRemoteSnapshotVersion?: SnapshotVersion): PersistencePromise<void>;
    
    addTargetData(transaction: PersistenceTransaction, targetData: TargetData): PersistencePromise<void>;
    
    updateTargetData(transaction: PersistenceTransaction, targetData: TargetData): PersistencePromise<void>;
    
    removeTargetData(transaction: PersistenceTransaction, targetData: TargetData): PersistencePromise<void>;
    
    getTargetCount(transaction: PersistenceTransaction): PersistencePromise<number>;
    
    getTargetData(transaction: PersistenceTransaction, target: Target): PersistencePromise<TargetData | null>;
    
    addMatchingKeys(transaction: PersistenceTransaction, keys: DocumentKeySet, targetId: TargetId): PersistencePromise<void>;
    
    removeMatchingKeys(transaction: PersistenceTransaction, keys: DocumentKeySet, targetId: TargetId): PersistencePromise<void>;
    
    removeMatchingKeysForTargetId(transaction: PersistenceTransaction, targetId: TargetId): PersistencePromise<void>;
    
    getMatchingKeysForTargetId(transaction: PersistenceTransaction, targetId: TargetId): PersistencePromise<DocumentKeySet>;
    
    allocateTargetId(transaction: PersistenceTransaction): PersistencePromise<TargetId>;
    containsKey(transaction: PersistenceTransaction, key: DocumentKey): PersistencePromise<boolean>;
}




interface ReferenceDelegate {
    
    addReference(txn: PersistenceTransaction, targetId: TargetId, doc: DocumentKey): PersistencePromise<void>;
    
    removeReference(txn: PersistenceTransaction, targetId: TargetId, doc: DocumentKey): PersistencePromise<void>;
    
    removeTarget(txn: PersistenceTransaction, targetData: TargetData): PersistencePromise<void>;
    
    markPotentiallyOrphaned(txn: PersistenceTransaction, doc: DocumentKey): PersistencePromise<void>;
    
    updateLimboDocument(txn: PersistenceTransaction, doc: DocumentKey): PersistencePromise<void>;
}

interface Persistence {
    
    readonly started: boolean;
    readonly referenceDelegate: ReferenceDelegate;
    
    start(): Promise<void>;
    
    shutdown(): Promise<void>;
    
    setDatabaseDeletedListener(databaseDeletedListener: () => Promise<void>): void;
    
    setNetworkEnabled(networkEnabled: boolean): void;
    
    getGlobalsCache(): GlobalsCache;
    
    getMutationQueue(user: User, indexManager: IndexManager): MutationQueue;
    
    getTargetCache(): TargetCache;
    
    getRemoteDocumentCache(): RemoteDocumentCache;
    
    getBundleCache(): BundleCache;
    
    getIndexManager(user: User): IndexManager;
    
    getDocumentOverlayCache(user: User): DocumentOverlayCache;
    
    runTransaction<T>(action: string, mode: PersistenceTransactionMode, transactionOperation: (transaction: PersistenceTransaction) => PersistencePromise<T>): Promise<T>;
}

interface Scheduler {
    readonly started: boolean;
    start(): void;
    stop(): void;
}




type QueryTargetState = 'not-current' | 'current' | 'rejected';




type ClientId = string;

interface SharedClientState {
    onlineStateHandler: ((onlineState: OnlineState) => void) | null;
    sequenceNumberHandler: ((sequenceNumber: ListenSequenceNumber) => void) | null;
    
    addPendingMutation(batchId: BatchId): void;
    
    updateMutationState(batchId: BatchId, state: 'acknowledged' | 'rejected', error?: FirestoreError$1): void;
    
    addLocalQueryTarget(targetId: TargetId, addToActiveTargetIds?: boolean): QueryTargetState;
    
    removeLocalQueryTarget(targetId: TargetId): void;
    
    isLocalQueryTarget(targetId: TargetId): boolean;
    
    updateQueryState(targetId: TargetId, state: QueryTargetState, error?: FirestoreError$1): void;
    
    clearQueryState(targetId: TargetId): void;
    
    getAllActiveQueryTargets(): SortedSet<TargetId>;
    
    isActiveQueryTarget(targetId: TargetId): boolean;
    
    start(): Promise<void>;
    
    shutdown(): void;
    
    handleUserChange(user: User, removedBatchIds: BatchId[], addedBatchIds: BatchId[]): void;
    
    setOnlineState(onlineState: OnlineState): void;
    writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void;
    
    notifyBundleLoaded(collectionGroups: Set<string>): void;
}



type DocumentComparator = (doc1: Document, doc2: Document) => number;




declare class DocumentSet {
    
    static emptySet(oldSet: DocumentSet): DocumentSet;
    private comparator;
    private keyedMap;
    private sortedSet;
    
    constructor(comp?: DocumentComparator);
    has(key: DocumentKey): boolean;
    get(key: DocumentKey): Document | null;
    first(): Document | null;
    last(): Document | null;
    isEmpty(): boolean;
    
    indexOf(key: DocumentKey): number;
    get size(): number;
    
    forEach(cb: (doc: Document) => void): void;
    
    add(doc: Document): DocumentSet;
    
    delete(key: DocumentKey): DocumentSet;
    isEqual(other: DocumentSet | null | undefined): boolean;
    toString(): string;
    private copy;
}



declare const enum ChangeType {
    Added = 0,
    Removed = 1,
    Modified = 2,
    Metadata = 3
}
interface DocumentViewChange {
    type: ChangeType;
    doc: Document;
}
declare class ViewSnapshot {
    readonly query: Query$2;
    readonly docs: DocumentSet;
    readonly oldDocs: DocumentSet;
    readonly docChanges: DocumentViewChange[];
    readonly mutatedKeys: DocumentKeySet;
    readonly fromCache: boolean;
    readonly syncStateChanged: boolean;
    readonly excludesMetadataChanges: boolean;
    readonly hasCachedResults: boolean;
    constructor(query: Query$2, docs: DocumentSet, oldDocs: DocumentSet, docChanges: DocumentViewChange[], mutatedKeys: DocumentKeySet, fromCache: boolean, syncStateChanged: boolean, excludesMetadataChanges: boolean, hasCachedResults: boolean);
    
    static fromInitialDocuments(query: Query$2, documents: DocumentSet, mutatedKeys: DocumentKeySet, fromCache: boolean, hasCachedResults: boolean): ViewSnapshot;
    get hasPendingWrites(): boolean;
    isEqual(other: ViewSnapshot): boolean;
}




interface LocalWriteResult {
    batchId: BatchId;
    changes: DocumentMap;
}




declare class LocalDocumentsView {
    readonly remoteDocumentCache: RemoteDocumentCache;
    readonly mutationQueue: MutationQueue;
    readonly documentOverlayCache: DocumentOverlayCache;
    readonly indexManager: IndexManager;
    constructor(remoteDocumentCache: RemoteDocumentCache, mutationQueue: MutationQueue, documentOverlayCache: DocumentOverlayCache, indexManager: IndexManager);
    
    getDocument(transaction: PersistenceTransaction, key: DocumentKey): PersistencePromise<Document>;
    
    getDocuments(transaction: PersistenceTransaction, keys: DocumentKeySet): PersistencePromise<DocumentMap>;
    
    getLocalViewOfDocuments(transaction: PersistenceTransaction, docs: MutableDocumentMap, existenceStateChanged?: DocumentKeySet): PersistencePromise<DocumentMap>;
    
    getOverlayedDocuments(transaction: PersistenceTransaction, docs: MutableDocumentMap): PersistencePromise<OverlayedDocumentMap>;
    
    private populateOverlays;
    
    computeViews(transaction: PersistenceTransaction, docs: MutableDocumentMap, overlays: OverlayMap, existenceStateChanged: DocumentKeySet): PersistencePromise<OverlayedDocumentMap>;
    private recalculateAndSaveOverlays;
    
    recalculateAndSaveOverlaysForDocumentKeys(transaction: PersistenceTransaction, documentKeys: DocumentKeySet): PersistencePromise<DocumentKeyMap<FieldMask | null>>;
    
    getDocumentsMatchingQuery(transaction: PersistenceTransaction, query: Query$2, offset: IndexOffset, context?: QueryContext): PersistencePromise<DocumentMap>;
    
    getNextDocuments(transaction: PersistenceTransaction, collectionGroup: string, offset: IndexOffset, count: number): PersistencePromise<LocalWriteResult>;
    private getDocumentsMatchingDocumentQuery;
    private getDocumentsMatchingCollectionGroupQuery;
    private getDocumentsMatchingCollectionQuery;
}



interface LocalStore {
    collectGarbage(garbageCollector: LruGarbageCollector): Promise<LruResults>;
    
    indexManager: IndexManager;
    
    localDocuments: LocalDocumentsView;
}




declare abstract class Datastore {
    abstract terminate(): void;
    abstract serializer: JsonProtoSerializer;
}




interface RemoteSyncer {
    
    applyRemoteEvent?(remoteEvent: RemoteEvent): Promise<void>;
    
    rejectListen?(targetId: TargetId, error: FirestoreError$1): Promise<void>;
    
    applySuccessfulWrite?(result: MutationBatchResult): Promise<void>;
    
    rejectFailedWrite?(batchId: BatchId, error: FirestoreError$1): Promise<void>;
    
    getRemoteKeysForTarget?(targetId: TargetId): DocumentKeySet;
    
    handleCredentialChange?(user: User): Promise<void>;
}




interface RemoteStore {
    
    remoteSyncer: RemoteSyncer;
}


declare class AutoId {
    static newId(): string;
}




interface EventManager {
    onListen?: (query: Query$2, enableRemoteListen: boolean) => Promise<ViewSnapshot>;
    onUnlisten?: (query: Query$2, disableRemoteListen: boolean) => Promise<void>;
    onFirstRemoteStoreListen?: (query: Query$2) => Promise<void>;
    onLastRemoteStoreUnlisten?: (query: Query$2) => Promise<void>;
    terminate(): void;
}



interface SyncEngine {
    isPrimaryClient: boolean;
}



type Kind = 'memory' | 'persistent';
interface ComponentConfiguration {
    asyncQueue: AsyncQueue;
    databaseInfo: DatabaseInfo;
    authCredentials: CredentialsProvider<User>;
    appCheckCredentials: CredentialsProvider<string>;
    clientId: ClientId;
    initialUser: User;
    maxConcurrentLimboResolutions: number;
}
interface OfflineComponentProviderFactory {
    build(onlineComponents: OnlineComponentProvider): OfflineComponentProvider;
}

interface OfflineComponentProvider {
    readonly kind: Kind;
    persistence: Persistence;
    sharedClientState: SharedClientState;
    localStore: LocalStore;
    gcScheduler: Scheduler | null;
    indexBackfillerScheduler: Scheduler | null;
    synchronizeTabs: boolean;
    initialize(cfg: ComponentConfiguration): Promise<void>;
    terminate(): Promise<void>;
}
interface OnlineComponentProviderFactory {
    build(): OnlineComponentProvider;
}

declare class OnlineComponentProvider {
    static readonly provider: OnlineComponentProviderFactory;
    protected localStore: LocalStore;
    protected sharedClientState: SharedClientState;
    datastore: Datastore;
    eventManager: EventManager;
    remoteStore: RemoteStore;
    syncEngine: SyncEngine;
    initialize(offlineComponentProvider: OfflineComponentProvider, cfg: ComponentConfiguration): Promise<void>;
    createEventManager(cfg: ComponentConfiguration): EventManager;
    createDatastore(cfg: ComponentConfiguration): Datastore;
    createRemoteStore(cfg: ComponentConfiguration): RemoteStore;
    createSyncEngine(cfg: ComponentConfiguration, startAsPrimary: boolean): SyncEngine;
    terminate(): Promise<void>;
}




type TaskState = 'Error' | 'Running' | 'Success';

interface LoadBundleTaskProgress {
    
    documentsLoaded: number;
    
    totalDocuments: number;
    
    bytesLoaded: number;
    
    totalBytes: number;
    
    taskState: TaskState;
}

declare class LoadBundleTask implements PromiseLike<LoadBundleTaskProgress> {
    private _progressObserver;
    private _taskCompletionResolver;
    private _lastProgress;
    
    onProgress(next?: (progress: LoadBundleTaskProgress) => unknown, error?: (err: Error) => unknown, complete?: () => void): void;
    
    catch<R>(onRejected: (a: Error) => R | PromiseLike<R>): Promise<R | LoadBundleTaskProgress>;
    
    then<T, R>(onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>, onRejected?: (a: Error) => R | PromiseLike<R>): Promise<T | R>;
    
    _completeWith(progress: LoadBundleTaskProgress): void;
    
    _failWith(error: FirestoreError$1): void;
    
    _updateProgress(progress: LoadBundleTaskProgress): void;
}



interface ParseContext {
    readonly databaseId: DatabaseId;
    readonly ignoreUndefinedProperties: boolean;
}




type MemoryLocalCache = {
    kind: 'memory';
    
    _onlineComponentProvider: OnlineComponentProviderFactory;
    
    _offlineComponentProvider: OfflineComponentProviderFactory;
};

type PersistentLocalCache = {
    kind: 'persistent';
    
    _onlineComponentProvider: OnlineComponentProviderFactory;
    
    _offlineComponentProvider: OfflineComponentProviderFactory;
};

type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;

type MemoryGarbageCollector = MemoryEagerGarbageCollector | MemoryLruGarbageCollector;

type MemoryEagerGarbageCollector = {
    kind: 'memoryEager';
    
    _offlineComponentProvider: OfflineComponentProviderFactory;
};

type MemoryLruGarbageCollector = {
    kind: 'memoryLru';
    
    _offlineComponentProvider: OfflineComponentProviderFactory;
};

declare function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector;

declare function memoryLruGarbageCollector(settings?: {
    cacheSizeBytes?: number;
}): MemoryLruGarbageCollector;

type MemoryCacheSettings = {
    
    garbageCollector?: MemoryGarbageCollector;
};

declare function memoryLocalCache(settings?: MemoryCacheSettings): MemoryLocalCache;

type PersistentCacheSettings = {
    
    cacheSizeBytes?: number;
    
    tabManager?: PersistentTabManager;
};

declare function persistentLocalCache(settings?: PersistentCacheSettings): PersistentLocalCache;

type PersistentSingleTabManager = {
    kind: 'persistentSingleTab';
    
    _initialize: (settings: Omit<PersistentCacheSettings, 'tabManager'> | undefined) => void;
    
    _onlineComponentProvider?: OnlineComponentProviderFactory;
    
    _offlineComponentProvider?: OfflineComponentProviderFactory;
};

type PersistentMultipleTabManager = {
    kind: 'PersistentMultipleTab';
    
    _initialize: (settings: Omit<PersistentCacheSettings, 'tabManager'>) => void;
    
    _onlineComponentProvider?: OnlineComponentProviderFactory;
    
    _offlineComponentProvider?: OfflineComponentProviderFactory;
};

type PersistentTabManager = PersistentSingleTabManager | PersistentMultipleTabManager;

type PersistentSingleTabManagerSettings = {
    
    forceOwnership?: boolean;
};

declare function persistentSingleTabManager(settings: PersistentSingleTabManagerSettings | undefined): PersistentSingleTabManager;

declare function persistentMultipleTabManager(): PersistentMultipleTabManager;




interface FirestoreSettings$1 {
    
    host?: string;
    
    ssl?: boolean;
    
    ignoreUndefinedProperties?: boolean;
}

interface PrivateSettings extends FirestoreSettings$1 {
    credentials?: CredentialsSettings;
    cacheSizeBytes?: number;
    experimentalForceLongPolling?: boolean;
    experimentalAutoDetectLongPolling?: boolean;
    experimentalLongPollingOptions?: ExperimentalLongPollingOptions;
    useFetchStreams?: boolean;
    emulatorOptions?: {
        mockUserToken?: EmulatorMockTokenOptions | string;
    };
    localCache?: FirestoreLocalCache;
}

declare class FirestoreSettingsImpl {
    
    readonly host: string;
    
    readonly ssl: boolean;
    readonly cacheSizeBytes: number;
    readonly experimentalForceLongPolling: boolean;
    readonly experimentalAutoDetectLongPolling: boolean;
    readonly experimentalLongPollingOptions: ExperimentalLongPollingOptions;
    readonly ignoreUndefinedProperties: boolean;
    readonly useFetchStreams: boolean;
    readonly localCache?: FirestoreLocalCache;
    readonly isUsingEmulator: boolean;
    credentials?: any;
    constructor(settings: PrivateSettings);
    isEqual(other: FirestoreSettingsImpl): boolean;
}




interface FirestoreService extends _FirebaseService {
    _authCredentials: CredentialsProvider<User>;
    _appCheckCredentials: CredentialsProvider<string>;
    _persistenceKey: string;
    _databaseId: DatabaseId;
    _terminated: boolean;
    _freezeSettings(): FirestoreSettingsImpl;
}



declare module '@firebase/component' {
    interface NameServiceMapping {
        'firestore/lite': Firestore$1;
    }
}

declare class Firestore$1 implements FirestoreService {
    _authCredentials: CredentialsProvider<User>;
    _appCheckCredentials: CredentialsProvider<string>;
    readonly _databaseId: DatabaseId;
    readonly _app?: FirebaseApp | undefined;
    
    type: 'firestore-lite' | 'firestore';
    readonly _persistenceKey: string;
    private _settings;
    private _settingsFrozen;
    private _emulatorOptions;
    private _terminateTask;
    
    constructor(_authCredentials: CredentialsProvider<User>, _appCheckCredentials: CredentialsProvider<string>, _databaseId: DatabaseId, _app?: FirebaseApp | undefined);
    
    get app(): FirebaseApp;
    get _initialized(): boolean;
    get _terminated(): boolean;
    _setSettings(settings: PrivateSettings): void;
    _getSettings(): FirestoreSettingsImpl;
    _getEmulatorOptions(): {
        mockUserToken?: EmulatorMockTokenOptions | string;
    };
    _freezeSettings(): FirestoreSettingsImpl;
    _delete(): Promise<void>;
    _restart(): Promise<void>;
    
    toJSON(): object;
    
    protected _terminate(): Promise<void>;
}

declare function connectFirestoreEmulator(firestore: Firestore$1, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;




declare abstract class FieldValue {
    _methodName: string;
    
    constructor(_methodName: string);
    
    abstract isEqual(other: FieldValue): boolean;
    abstract _toFieldTransform(context: ParseContext): FieldTransform | null;
}




declare class FieldPath {
    
    readonly _internalPath: FieldPath$2;
    
    constructor(...fieldNames: string[]);
    
    isEqual(other: FieldPath): boolean;
}

declare function documentId(): FieldPath;




declare class VectorValue {
    private readonly _values;
    
    constructor(values: number[] | undefined);
    
    toArray(): number[];
    
    isEqual(other: VectorValue): boolean;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        vectorValues: Property<"object">;
    };
    
    toJSON(): object;
    
    static fromJSON(json: object): VectorValue;
}



type ServerTimestampBehavior = 'estimate' | 'previous' | 'none';

declare abstract class AbstractUserDataWriter {
    convertValue(value: Value, serverTimestampBehavior?: ServerTimestampBehavior): unknown;
    private convertObject;
    
    convertObjectMap(fields: ApiClientObjectMap<Value> | undefined, serverTimestampBehavior?: ServerTimestampBehavior): DocumentData$1;
    
    convertVectorValue(mapValue: MapValue): VectorValue;
    private convertGeoPoint;
    private convertArray;
    private convertServerTimestamp;
    private convertTimestamp;
    protected convertDocumentKey(name: string, expectedDatabaseId: DatabaseId): DocumentKey;
    protected abstract convertReference(name: string): unknown;
    protected abstract convertBytes(bytes: ByteString): unknown;
}




interface FirestoreDataConverter$1<AppModelType, DbModelType extends DocumentData = DocumentData> {
    
    toFirestore(modelObject: WithFieldValue<AppModelType>): WithFieldValue<DbModelType>;
    
    toFirestore(modelObject: PartialWithFieldValue<AppModelType>, options: SetOptions): PartialWithFieldValue<DbModelType>;
    
    fromFirestore(snapshot: QueryDocumentSnapshot$1<DocumentData, DocumentData>): AppModelType;
}

declare class DocumentSnapshot$1<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    _firestore: Firestore$1;
    _userDataWriter: AbstractUserDataWriter;
    _key: DocumentKey;
    _document: Document | null;
    _converter: UntypedFirestoreDataConverter<AppModelType, DbModelType> | null;
    
    constructor(_firestore: Firestore$1, _userDataWriter: AbstractUserDataWriter, _key: DocumentKey, _document: Document | null, _converter: UntypedFirestoreDataConverter<AppModelType, DbModelType> | null);
    
    get id(): string;
    
    get ref(): DocumentReference<AppModelType, DbModelType>;
    
    exists(): this is QueryDocumentSnapshot$1<AppModelType, DbModelType>;
    
    data(): AppModelType | undefined;
    
    get(fieldPath: string | FieldPath): any;
}

declare class QueryDocumentSnapshot$1<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends DocumentSnapshot$1<AppModelType, DbModelType> {
    
    data(): AppModelType;
}





type Primitive = string | number | boolean | undefined | null;

type NestedUpdateFields<T extends Record<string, unknown>> = UnionToIntersection<{
    [K in keyof T & string]: ChildUpdateFields<K, T[K]>;
}[keyof T & string]>;

type ChildUpdateFields<K extends string, V> = V extends Record<string, unknown> ? AddPrefixToKeys<K, UpdateData<V>> : never;

type AddPrefixToKeys<Prefix extends string, T extends Record<string, unknown>> = {
    [K in keyof T & string as `${Prefix}.${K}`]+?: string extends K ? any : T[K];
};

type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;




interface DocumentData {
    
    [field: string]: any;
}

type PartialWithFieldValue<T> = Partial<T> | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: PartialWithFieldValue<T[K]> | FieldValue;
} : never);

type WithFieldValue<T> = T | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]: WithFieldValue<T[K]> | FieldValue;
} : never);

type UpdateData<T> = T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: UpdateData<T[K]> | FieldValue;
} & NestedUpdateFields<T> : Partial<T>;

type SetOptions = {
    readonly merge?: boolean;
} | {
    readonly mergeFields?: Array<string | FieldPath>;
};

declare class Query<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly converter: FirestoreDataConverter$1<AppModelType, DbModelType> | null;
    readonly _query: Query$2;
    
    readonly type: 'query' | 'collection';
    
    readonly firestore: Firestore$1;
    
    constructor(firestore: Firestore$1, 
    
    converter: FirestoreDataConverter$1<AppModelType, DbModelType> | null, _query: Query$2);
    
    withConverter(converter: null): Query<DocumentData, DocumentData>;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter$1<NewAppModelType, NewDbModelType>): Query<NewAppModelType, NewDbModelType>;
}

declare class DocumentReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly converter: FirestoreDataConverter$1<AppModelType, DbModelType> | null;
    readonly _key: DocumentKey;
    
    readonly type = "document";
    
    readonly firestore: Firestore$1;
    
    constructor(firestore: Firestore$1, 
    
    converter: FirestoreDataConverter$1<AppModelType, DbModelType> | null, _key: DocumentKey);
    get _path(): ResourcePath;
    
    get id(): string;
    
    get path(): string;
    
    get parent(): CollectionReference<AppModelType, DbModelType>;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter$1<NewAppModelType, NewDbModelType>): DocumentReference<NewAppModelType, NewDbModelType>;
    
    withConverter(converter: null): DocumentReference<DocumentData, DocumentData>;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        referencePath: Property<"string">;
    };
    
    toJSON(): object;
    
    static fromJSON(firestore: Firestore$1, json: object): DocumentReference;
    
    static fromJSON<NewAppModelType = DocumentData, NewDbModelType extends DocumentData = DocumentData>(firestore: Firestore$1, json: object, converter: FirestoreDataConverter$1<NewAppModelType, NewDbModelType>): DocumentReference<NewAppModelType, NewDbModelType>;
}

declare class CollectionReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends Query<AppModelType, DbModelType> {
    readonly _path: ResourcePath;
    
    readonly type = "collection";
    
    constructor(firestore: Firestore$1, converter: FirestoreDataConverter$1<AppModelType, DbModelType> | null, _path: ResourcePath);
    
    get id(): string;
    
    get path(): string;
    
    get parent(): DocumentReference<DocumentData, DocumentData> | null;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter$1<NewAppModelType, NewDbModelType>): CollectionReference<NewAppModelType, NewDbModelType>;
    
    withConverter(converter: null): CollectionReference<DocumentData, DocumentData>;
}

declare function collection(firestore: Firestore$1, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

declare function collection<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

declare function collection<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

declare function collectionGroup(firestore: Firestore$1, collectionId: string): Query<DocumentData, DocumentData>;

declare function doc(firestore: Firestore$1, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

declare function doc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path?: string, ...pathSegments: string[]): DocumentReference<AppModelType, DbModelType>;

declare function doc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

declare function refEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>, right: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>): boolean;

declare function queryEqual<AppModelType, DbModelType extends DocumentData>(left: Query<AppModelType, DbModelType>, right: Query<AppModelType, DbModelType>): boolean;




interface UntypedFirestoreDataConverter<AppModelType, DbModelType extends DocumentData$1 = DocumentData$1> {
    toFirestore(modelObject: WithFieldValue<AppModelType>): WithFieldValue<DbModelType>;
    toFirestore(modelObject: PartialWithFieldValue<AppModelType>, options: SetOptions$1): PartialWithFieldValue<DbModelType>;
    fromFirestore(snapshot: unknown, options?: unknown): AppModelType;
}

declare class ParsedSetData {
    readonly data: ObjectValue;
    readonly fieldMask: FieldMask | null;
    readonly fieldTransforms: FieldTransform[];
    constructor(data: ObjectValue, fieldMask: FieldMask | null, fieldTransforms: FieldTransform[]);
    toMutation(key: DocumentKey, precondition: Precondition): Mutation;
}

declare class ParsedUpdateData {
    readonly data: ObjectValue;
    readonly fieldMask: FieldMask;
    readonly fieldTransforms: FieldTransform[];
    constructor(data: ObjectValue, fieldMask: FieldMask, fieldTransforms: FieldTransform[]);
    toMutation(key: DocumentKey, precondition: Precondition): Mutation;
}




declare class Transaction$2 {
    private datastore;
    private readVersions;
    private mutations;
    private committed;
    
    private lastTransactionError;
    
    private writtenDocs;
    constructor(datastore: Datastore);
    lookup(keys: DocumentKey[]): Promise<Document[]>;
    set(key: DocumentKey, data: ParsedSetData): void;
    update(key: DocumentKey, data: ParsedUpdateData): void;
    delete(key: DocumentKey): void;
    commit(): Promise<void>;
    private recordVersion;
    
    private precondition;
    
    private preconditionForUpdate;
    private write;
    private ensureCommitNotCalled;
}




declare class FirestoreClient {
    private authCredentials;
    private appCheckCredentials;
    
    asyncQueue: AsyncQueue;
    private databaseInfo;
    private user;
    private readonly clientId;
    private authCredentialListener;
    private appCheckCredentialListener;
    _uninitializedComponentsProvider?: {
        _offline: OfflineComponentProvider;
        _online: OnlineComponentProvider;
    };
    _offlineComponents?: OfflineComponentProvider;
    _onlineComponents?: OnlineComponentProvider;
    constructor(authCredentials: CredentialsProvider<User>, appCheckCredentials: CredentialsProvider<string>, 
    
    asyncQueue: AsyncQueue, databaseInfo: DatabaseInfo, componentProvider?: {
        _offline: OfflineComponentProvider;
        _online: OnlineComponentProvider;
    });
    get configuration(): ComponentConfiguration;
    setCredentialChangeListener(listener: (user: User) => Promise<void>): void;
    setAppCheckTokenChangeListener(listener: (appCheckToken: string, user: User) => Promise<void>): void;
    terminate(): Promise<void>;
}




interface PersistenceSettings {
    
    forceOwnership?: boolean;
}

interface FirestoreSettings extends FirestoreSettings$1 {
    
    cacheSizeBytes?: number;
    
    localCache?: FirestoreLocalCache;
    
    experimentalForceLongPolling?: boolean;
    
    experimentalAutoDetectLongPolling?: boolean;
    
    experimentalLongPollingOptions?: ExperimentalLongPollingOptions;
}



declare module '@firebase/component' {
    interface NameServiceMapping {
        'firestore': Firestore;
    }
}

declare const CACHE_SIZE_UNLIMITED = -1;

declare class Firestore extends Firestore$1 {
    
    type: 'firestore-lite' | 'firestore';
    _queue: AsyncQueue;
    readonly _persistenceKey: string;
    _firestoreClient: FirestoreClient | undefined;
    _componentsProvider?: {
        _offline: OfflineComponentProviderFactory;
        _online: OnlineComponentProviderFactory;
    };
    
    constructor(authCredentialsProvider: CredentialsProvider<User>, appCheckCredentialsProvider: CredentialsProvider<string>, databaseId: DatabaseId, app?: FirebaseApp);
    protected _terminate(): Promise<void>;
}

declare function initializeFirestore(app: FirebaseApp, settings: FirestoreSettings, databaseId?: string): Firestore;

declare function getFirestore(): Firestore;

declare function getFirestore(app: FirebaseApp): Firestore;

declare function getFirestore(databaseId: string): Firestore;

declare function getFirestore(app: FirebaseApp, databaseId: string): Firestore;

declare function ensureFirestoreConfigured(firestore: Firestore): FirestoreClient;

declare function enableIndexedDbPersistence(firestore: Firestore, persistenceSettings?: PersistenceSettings): Promise<void>;

declare function enableMultiTabIndexedDbPersistence(firestore: Firestore): Promise<void>;

declare function clearIndexedDbPersistence(firestore: Firestore): Promise<void>;

declare function waitForPendingWrites(firestore: Firestore): Promise<void>;

declare function enableNetwork(firestore: Firestore): Promise<void>;

declare function disableNetwork(firestore: Firestore): Promise<void>;

declare function terminate(firestore: Firestore): Promise<void>;

declare function loadBundle(firestore: Firestore, bundleData: ReadableStream<Uint8Array> | ArrayBuffer | string): LoadBundleTask;

declare function namedQuery(firestore: Firestore, name: string): Promise<Query | null>;




declare function sum(field: string | FieldPath): AggregateField<number>;

declare function average(field: string | FieldPath): AggregateField<number | null>;

declare function count(): AggregateField<number>;

declare function aggregateFieldEqual(left: AggregateField<unknown>, right: AggregateField<unknown>): boolean;

declare function aggregateQuerySnapshotEqual<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(left: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>, right: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>): boolean;




declare class AggregateField<T> {
    readonly _internalFieldPath?: FieldPath$2 | undefined;
    
    readonly type = "AggregateField";
    
    readonly aggregateType: AggregateType;
    
    constructor(aggregateType?: AggregateType, _internalFieldPath?: FieldPath$2 | undefined);
}

type AggregateFieldType = ReturnType<typeof sum> | ReturnType<typeof average> | ReturnType<typeof count>;

interface AggregateSpec {
    [field: string]: AggregateFieldType;
}

type AggregateSpecData<T extends AggregateSpec> = {
    [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;
};

declare class AggregateQuerySnapshot<AggregateSpecType extends AggregateSpec, AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    private readonly _userDataWriter;
    private readonly _data;
    
    readonly type = "AggregateQuerySnapshot";
    
    readonly query: Query<AppModelType, DbModelType>;
    
    constructor(query: Query<AppModelType, DbModelType>, _userDataWriter: AbstractUserDataWriter, _data: ApiClientObjectMap<Value>);
    
    data(): AggregateSpecData<AggregateSpecType>;
}




declare function getCountFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<AggregateQuerySnapshot<{
    count: AggregateField<number>;
}, AppModelType, DbModelType>>;

declare function getAggregateFromServer<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, aggregateSpec: AggregateSpecType): Promise<AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>>;




declare class Bytes {
    _byteString: ByteString;
    
    constructor(byteString: ByteString);
    
    static fromBase64String(base64: string): Bytes;
    
    static fromUint8Array(array: Uint8Array): Bytes;
    
    toBase64(): string;
    
    toUint8Array(): Uint8Array;
    
    toString(): string;
    
    isEqual(other: Bytes): boolean;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        bytes: Property<"string">;
    };
    
    toJSON(): object;
    
    static fromJSON(json: object): Bytes;
}




interface SnapshotListenOptions {
    
    readonly includeMetadataChanges?: boolean;
    
    readonly source?: ListenSource;
}

type ListenSource = 'default' | 'cache';

declare function getDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

declare function getDocFromCache<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

declare function getDocFromServer<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

declare function getDocs<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

declare function getDocsFromCache<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

declare function getDocsFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

declare function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<void>;

declare function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): Promise<void>;

declare function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): Promise<void>;

declare function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): Promise<void>;

declare function deleteDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<void>;

declare function addDoc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<DocumentReference<AppModelType, DbModelType>>;

interface Unsubscribe {
    
    (): void;
}

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void): Unsubscribe;

declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError$1) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, observer: {
    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, observer: {
    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, observer: {
    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, observer: {
    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

declare function onSnapshotsInSync(firestore: Firestore, observer: {
    next?: (value: void) => void;
    error?: (error: FirestoreError$1) => void;
    complete?: () => void;
}): Unsubscribe;

declare function onSnapshotsInSync(firestore: Firestore, onSync: () => void): Unsubscribe;

declare function executeWrite(firestore: Firestore, mutations: Mutation[]): Promise<void>;




interface FirestoreDataConverter<AppModelType, DbModelType extends DocumentData = DocumentData> extends FirestoreDataConverter$1<AppModelType, DbModelType> {
    
    toFirestore(modelObject: WithFieldValue<AppModelType>): WithFieldValue<DbModelType>;
    
    toFirestore(modelObject: PartialWithFieldValue<AppModelType>, options: SetOptions): PartialWithFieldValue<DbModelType>;
    
    fromFirestore(snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>, options?: SnapshotOptions): AppModelType;
}

interface SnapshotOptions {
    
    readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
}

declare class SnapshotMetadata {
    
    readonly hasPendingWrites: boolean;
    
    readonly fromCache: boolean;
    
    constructor(hasPendingWrites: boolean, fromCache: boolean);
    
    isEqual(other: SnapshotMetadata): boolean;
}

type DocumentChangeType = 'added' | 'removed' | 'modified';

interface DocumentChange<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly type: DocumentChangeType;
    
    readonly doc: QueryDocumentSnapshot<AppModelType, DbModelType>;
    
    readonly oldIndex: number;
    
    readonly newIndex: number;
}

declare class DocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends DocumentSnapshot$1<AppModelType, DbModelType> {
    readonly _firestore: Firestore;
    private readonly _firestoreImpl;
    
    readonly metadata: SnapshotMetadata;
    
    constructor(_firestore: Firestore, userDataWriter: AbstractUserDataWriter, key: DocumentKey, document: Document | null, metadata: SnapshotMetadata, converter: UntypedFirestoreDataConverter<AppModelType, DbModelType> | null);
    
    exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType>;
    
    data(options?: SnapshotOptions): AppModelType | undefined;
    
    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        bundleSource: Property<"string">;
        bundleName: Property<"string">;
        bundle: Property<"string">;
    };
    
    toJSON(): object;
}

declare function documentSnapshotFromJSON(db: Firestore, json: object): DocumentSnapshot;

declare function documentSnapshotFromJSON<AppModelType, DbModelType extends DocumentData = DocumentData>(db: Firestore, json: object, converter: FirestoreDataConverter<AppModelType, DbModelType>): DocumentSnapshot<AppModelType, DbModelType>;

declare class QueryDocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends DocumentSnapshot<AppModelType, DbModelType> {
    
    data(options?: SnapshotOptions): AppModelType;
}

declare class QuerySnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    readonly _firestore: Firestore;
    readonly _userDataWriter: AbstractUserDataWriter;
    readonly _snapshot: ViewSnapshot;
    
    readonly metadata: SnapshotMetadata;
    
    readonly query: Query<AppModelType, DbModelType>;
    private _cachedChanges?;
    private _cachedChangesIncludeMetadataChanges?;
    
    constructor(_firestore: Firestore, _userDataWriter: AbstractUserDataWriter, query: Query<AppModelType, DbModelType>, _snapshot: ViewSnapshot);
    
    get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>>;
    
    get size(): number;
    
    get empty(): boolean;
    
    forEach(callback: (result: QueryDocumentSnapshot<AppModelType, DbModelType>) => void, thisArg?: unknown): void;
    
    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<AppModelType, DbModelType>>;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        bundleSource: Property<"string">;
        bundleName: Property<"string">;
        bundle: Property<"string">;
    };
    
    toJSON(): object;
}

declare function querySnapshotFromJSON(db: Firestore, json: object): QuerySnapshot;

declare function querySnapshotFromJSON<AppModelType, DbModelType extends DocumentData = DocumentData>(db: Firestore, json: object, converter: FirestoreDataConverter<AppModelType, DbModelType>): QuerySnapshot<AppModelType, DbModelType>;

declare function snapshotEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>, right: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>): boolean;




type QueryConstraintType = 'where' | 'orderBy' | 'limit' | 'limitToLast' | 'startAt' | 'startAfter' | 'endAt' | 'endBefore';

declare abstract class AppliableConstraint {
    
    abstract _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

declare abstract class QueryConstraint extends AppliableConstraint {
    
    abstract readonly type: QueryConstraintType;
    
    abstract _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

declare function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, compositeFilter: QueryCompositeFilterConstraint, ...queryConstraints: QueryNonFilterConstraint[]): Query<AppModelType, DbModelType>;

declare function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, ...queryConstraints: QueryConstraint[]): Query<AppModelType, DbModelType>;

declare class QueryFieldFilterConstraint extends QueryConstraint {
    private readonly _field;
    private _op;
    private _value;
    
    readonly type = "where";
    
    protected constructor(_field: FieldPath$2, _op: Operator, _value: unknown);
    static _create(_field: FieldPath$2, _op: Operator, _value: unknown): QueryFieldFilterConstraint;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
    _parse<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): FieldFilter;
}

type WhereFilterOp = '<' | '<=' | '==' | '!=' | '>=' | '>' | 'array-contains' | 'in' | 'array-contains-any' | 'not-in';

declare function where(fieldPath: string | FieldPath, opStr: WhereFilterOp, value: unknown): QueryFieldFilterConstraint;

declare class QueryCompositeFilterConstraint extends AppliableConstraint {
    
    readonly type: 'or' | 'and';
    private readonly _queryConstraints;
    
    protected constructor(
    
    type: 'or' | 'and', _queryConstraints: QueryFilterConstraint[]);
    static _create(type: 'or' | 'and', _queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;
    _parse<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Filter;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
    _getQueryConstraints(): readonly AppliableConstraint[];
    _getOperator(): CompositeOperator;
}

type QueryNonFilterConstraint = QueryOrderByConstraint | QueryLimitConstraint | QueryStartAtConstraint | QueryEndAtConstraint;

type QueryFilterConstraint = QueryFieldFilterConstraint | QueryCompositeFilterConstraint;

declare function or(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

declare function and(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

declare class QueryOrderByConstraint extends QueryConstraint {
    private readonly _field;
    private _direction;
    
    readonly type = "orderBy";
    
    protected constructor(_field: FieldPath$2, _direction: Direction);
    static _create(_field: FieldPath$2, _direction: Direction): QueryOrderByConstraint;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

type OrderByDirection = 'desc' | 'asc';

declare function orderBy(fieldPath: string | FieldPath, directionStr?: OrderByDirection): QueryOrderByConstraint;

declare class QueryLimitConstraint extends QueryConstraint {
    
    readonly type: 'limit' | 'limitToLast';
    private readonly _limit;
    private readonly _limitType;
    
    protected constructor(
    
    type: 'limit' | 'limitToLast', _limit: number, _limitType: LimitType$1);
    static _create(type: 'limit' | 'limitToLast', _limit: number, _limitType: LimitType$1): QueryLimitConstraint;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

declare function limit(limit: number): QueryLimitConstraint;

declare function limitToLast(limit: number): QueryLimitConstraint;

declare class QueryStartAtConstraint extends QueryConstraint {
    
    readonly type: 'startAt' | 'startAfter';
    private readonly _docOrFields;
    private readonly _inclusive;
    
    protected constructor(
    
    type: 'startAt' | 'startAfter', _docOrFields: Array<unknown | DocumentSnapshot$1<unknown>>, _inclusive: boolean);
    static _create(type: 'startAt' | 'startAfter', _docOrFields: Array<unknown | DocumentSnapshot$1<unknown>>, _inclusive: boolean): QueryStartAtConstraint;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

declare function startAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot$1<AppModelType, DbModelType>): QueryStartAtConstraint;

declare function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;

declare function startAfter<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot$1<AppModelType, DbModelType>): QueryStartAtConstraint;

declare function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;

declare class QueryEndAtConstraint extends QueryConstraint {
    
    readonly type: 'endBefore' | 'endAt';
    private readonly _docOrFields;
    private readonly _inclusive;
    
    protected constructor(
    
    type: 'endBefore' | 'endAt', _docOrFields: Array<unknown | DocumentSnapshot$1<unknown>>, _inclusive: boolean);
    static _create(type: 'endBefore' | 'endAt', _docOrFields: Array<unknown | DocumentSnapshot$1<unknown>>, _inclusive: boolean): QueryEndAtConstraint;
    _apply<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Query<AppModelType, DbModelType>;
}

declare function endBefore<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot$1<AppModelType, DbModelType>): QueryEndAtConstraint;

declare function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;

declare function endAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot$1<AppModelType, DbModelType>): QueryEndAtConstraint;

declare function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;



declare interface TransactionOptions {
    
    readonly maxAttempts?: number;
}




declare class Transaction$1 {
    protected readonly _firestore: Firestore$1;
    private readonly _transaction;
    private readonly _dataReader;
    
    constructor(_firestore: Firestore$1, _transaction: Transaction$2);
    
    get<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot$1<AppModelType, DbModelType>>;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): this;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): this;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): this;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): this;
    
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): this;
}




declare class Transaction extends Transaction$1 {
    protected readonly _firestore: Firestore;
    
    constructor(_firestore: Firestore, _transaction: Transaction$2);
    
    get<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;
}

declare function runTransaction<T>(firestore: Firestore, updateFunction: (transaction: Transaction) => Promise<T>, options?: TransactionOptions): Promise<T>;




declare function deleteField(): FieldValue;

declare function serverTimestamp(): FieldValue;

declare function arrayUnion(...elements: unknown[]): FieldValue;

declare function arrayRemove(...elements: unknown[]): FieldValue;

declare function increment(n: number): FieldValue;

declare function vector(values?: number[]): VectorValue;




declare function setLogLevel(logLevel: LogLevelString): void;

declare function logWarn(msg: string, ...obj: unknown[]): void;




declare class WriteBatch {
    private readonly _firestore;
    private readonly _commitHandler;
    private readonly _dataReader;
    private _mutations;
    private _committed;
    
    constructor(_firestore: Firestore$1, _commitHandler: (m: Mutation[]) => Promise<void>);
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): WriteBatch;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): WriteBatch;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): WriteBatch;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): WriteBatch;
    
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): WriteBatch;
    
    commit(): Promise<void>;
    private _verifyNotCommitted;
}




declare function writeBatch(firestore: Firestore): WriteBatch;




declare class GeoPoint {
    private _lat;
    private _long;
    
    constructor(latitude: number, longitude: number);
    
    get latitude(): number;
    
    get longitude(): number;
    
    isEqual(other: GeoPoint): boolean;
    
    _compareTo(other: GeoPoint): number;
    static _jsonSchemaVersion: string;
    static _jsonSchema: {
        type: Property<"string">;
        latitude: Property<"number">;
        longitude: Property<"number">;
    };
    
    toJSON(): {
        latitude: number;
        longitude: number;
        type: string;
    };
    
    static fromJSON(json: object): GeoPoint;
}




interface IndexField {
    
    readonly fieldPath: string;
    
    readonly arrayConfig?: 'CONTAINS';
    
    readonly order?: 'ASCENDING' | 'DESCENDING';
    [key: string]: unknown;
}

interface Index {
    
    readonly collectionGroup: string;
    
    readonly fields?: IndexField[];
    [key: string]: unknown;
}

interface IndexConfiguration {
    
    readonly indexes?: Index[];
    [key: string]: unknown;
}

declare function setIndexConfiguration(firestore: Firestore, configuration: IndexConfiguration): Promise<void>;

declare function setIndexConfiguration(firestore: Firestore, json: string): Promise<void>;




declare class PersistentCacheIndexManager {
    readonly _firestore: Firestore;
    
    readonly type: 'PersistentCacheIndexManager';
    
    constructor(_firestore: Firestore);
}

declare function getPersistentCacheIndexManager(firestore: Firestore): PersistentCacheIndexManager | null;

declare function enablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

declare function disablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

declare function deleteAllPersistentCacheIndexes(indexManager: PersistentCacheIndexManager): void;


declare function isBase64Available(): boolean;




declare function _internalQueryToProtoQueryTarget(query: Query): any;

declare function _internalAggregationQueryToProtoRunAggregationQueryRequest<AggregateSpecType extends AggregateSpec>(query: Query, aggregateSpec: AggregateSpecType): any;




declare function validateIsNotUsedTogether(optionName1: string, argument1: boolean | undefined, optionName2: string, argument2: boolean | undefined): void;

declare function cast<T>(obj: object, constructor: {
    new (...args: any[]): T;
}): T | never;


declare function debugAssert(assertion: boolean, message: string): asserts assertion;


interface ExistenceFilterMismatchInfo {
    
    localCacheCount: number;
    
    existenceFilterCount: number;
    
    projectId: string;
    
    databaseId: string;
    
    bloomFilter?: {
        
        applied: boolean;
        
        hashCount: number;
        
        bitmapLength: number;
        
        padding: number;
        
        mightContain?: (value: string) => boolean;
    };
}




declare class TestingHooks {
    private constructor();
    
    static onExistenceFilterMismatch(callback: ExistenceFilterMismatchCallback): Unsubscribe;
}

type ExistenceFilterMismatchCallback = (info: ExistenceFilterMismatchInfo) => unknown;



declare module '@firebase/component' {
    interface NameServiceMapping {
        'firestore': Firestore;
    }
}

export { AbstractUserDataWriter, AddPrefixToKeys, AggregateField, AggregateFieldType, AggregateQuerySnapshot, AggregateSpec, AggregateSpecData, AggregateType, AuthTokenFactory, Bytes, CACHE_SIZE_UNLIMITED, ChildUpdateFields, CollectionReference, DocumentChange, DocumentChangeType, DocumentData, DocumentReference, DocumentSnapshot, EmulatorMockTokenOptions, ExperimentalLongPollingOptions, FieldPath, FieldValue, Firestore, FirestoreDataConverter, FirestoreError$1 as FirestoreError, FirestoreErrorCode$1 as FirestoreErrorCode, FirestoreLocalCache, FirestoreSettings, FirstPartyCredentialsSettings, GeoPoint, Index, IndexConfiguration, IndexField, ListenSource, LoadBundleTask, LoadBundleTaskProgress, LogLevelString as LogLevel, MemoryCacheSettings, MemoryEagerGarbageCollector, MemoryGarbageCollector, MemoryLocalCache, MemoryLruGarbageCollector, NestedUpdateFields, OrderByDirection, PartialWithFieldValue, PersistenceSettings, PersistentCacheIndexManager, PersistentCacheSettings, PersistentLocalCache, PersistentMultipleTabManager, PersistentSingleTabManager, PersistentSingleTabManagerSettings, PersistentTabManager, Primitive, PrivateSettings, Query, QueryCompositeFilterConstraint, QueryConstraint, QueryConstraintType, QueryDocumentSnapshot, QueryEndAtConstraint, QueryFieldFilterConstraint, QueryFilterConstraint, QueryLimitConstraint, QueryNonFilterConstraint, QueryOrderByConstraint, QuerySnapshot, QueryStartAtConstraint, SetOptions, SnapshotListenOptions, SnapshotMetadata, SnapshotOptions, TaskState, Timestamp$1 as Timestamp, Transaction, TransactionOptions, UnionToIntersection, Unsubscribe, UpdateData, VectorValue, WhereFilterOp, WithFieldValue, WriteBatch, AutoId as _AutoId, ByteString as _ByteString, DatabaseId as _DatabaseId, DocumentKey as _DocumentKey, EmptyAppCheckTokenProvider as _EmptyAppCheckTokenProvider, EmptyAuthCredentialsProvider as _EmptyAuthCredentialsProvider, FieldPath$2 as _FieldPath, ResourcePath as _ResourcePath, TestingHooks as _TestingHooks, ExistenceFilterMismatchCallback as _TestingHooksExistenceFilterMismatchCallback, ExistenceFilterMismatchInfo as _TestingHooksExistenceFilterMismatchInfo, cast as _cast, debugAssert as _debugAssert, _internalAggregationQueryToProtoRunAggregationQueryRequest, _internalQueryToProtoQueryTarget, isBase64Available as _isBase64Available, logWarn as _logWarn, validateIsNotUsedTogether as _validateIsNotUsedTogether, addDoc, aggregateFieldEqual, aggregateQuerySnapshotEqual, and, arrayRemove, arrayUnion, average, clearIndexedDbPersistence, collection, collectionGroup, connectFirestoreEmulator, count, deleteAllPersistentCacheIndexes, deleteDoc, deleteField, disableNetwork, disablePersistentCacheIndexAutoCreation, doc, documentId, documentSnapshotFromJSON, enableIndexedDbPersistence, enableMultiTabIndexedDbPersistence, enableNetwork, enablePersistentCacheIndexAutoCreation, endAt, endBefore, ensureFirestoreConfigured, executeWrite, getAggregateFromServer, getCountFromServer, getDoc, getDocFromCache, getDocFromServer, getDocs, getDocsFromCache, getDocsFromServer, getFirestore, getPersistentCacheIndexManager, increment, initializeFirestore, limit, limitToLast, loadBundle, memoryEagerGarbageCollector, memoryLocalCache, memoryLruGarbageCollector, namedQuery, onSnapshot, onSnapshotResume, onSnapshotsInSync, or, orderBy, persistentLocalCache, persistentMultipleTabManager, persistentSingleTabManager, query, queryEqual, querySnapshotFromJSON, refEqual, runTransaction, serverTimestamp, setDoc, setIndexConfiguration, setLogLevel, snapshotEqual, startAfter, startAt, sum, terminate, updateDoc, vector, waitForPendingWrites, where, writeBatch };
