
import { IndexConfiguration } from '../../../src/api/index_configuration';
import { Query } from '../../../src/core/query';
import { Target } from '../../../src/core/target';
import { TargetIdGenerator } from '../../../src/core/target_id_generator';
import { TargetId } from '../../../src/core/types';
import { TargetPurpose } from '../../../src/local/target_data';
import { Document } from '../../../src/model/document';
import { DocumentKey } from '../../../src/model/document_key';
import { FieldIndex } from '../../../src/model/field_index';
import { JsonObject } from '../../../src/model/object_value';
import { BloomFilter as ProtoBloomFilter } from '../../../src/protos/firestore_proto_api';
import { TimerId } from '../../../src/util/async_queue';
import { Code } from '../../../src/util/error';
import { ObjectMap } from '../../../src/util/obj_map';
import { TestSnapshotVersion } from '../../util/helpers';
import { RpcError } from './spec_rpc_error';
import { PersistenceAction, SpecConfig, SpecQuery, SpecStep } from './spec_test_runner';
export interface LimboMap {
    [key: string]: TargetId;
}
export interface ActiveTargetSpec {
    queries: SpecQuery[];
    targetPurpose?: TargetPurpose;
    resumeToken?: string;
    readTime?: TestSnapshotVersion;
    expectedCount?: number;
}
export interface ActiveTargetMap {
    [targetId: string]: ActiveTargetSpec;
}
export interface ResumeSpec {
    resumeToken?: string;
    readTime?: TestSnapshotVersion;
    expectedCount?: number;
}

export declare class ClientMemoryState {
    activeTargets: ActiveTargetMap;
    queryMapping: ObjectMap<Target, number>;
    limboMapping: LimboMap;
    limboIdGenerator: TargetIdGenerator;
    injectFailures: boolean;
    constructor();
    
    reset(): void;
    
    resetLimboMapping(): void;
}

export declare class SpecBuilder {
    protected config: SpecConfig;
    protected currentStep: SpecStep | null;
    private steps;
    private queryIdGenerator;
    private readonly currentClientState;
    protected get clientState(): ClientMemoryState;
    private get limboIdGenerator();
    private get queryMapping();
    private get limboMapping();
    private get activeTargets();
    private get injectFailures();
    private set injectFailures(value);
    
    toJSON(): {
        config: SpecConfig;
        steps: SpecStep[];
    };
    
    runAsTest(name: string, tags: string[], usePersistence: boolean): Promise<void>;
    ensureManualLruGC(): this;
    withMaxConcurrentLimboResolutions(value?: number): this;
    private addUserListenStep;
    userListens(query: Query, resume?: ResumeSpec): this;
    
    userListensForGet(query: Query, resume?: ResumeSpec): this;
    userListensToCache(query: Query, resume?: ResumeSpec): this;
    
    restoreListen(query: Query, resumeToken: string, expectedCount?: number): this;
    userUnlistens(query: Query, shouldRemoveWatchTarget?: boolean): this;
    userUnlistensToCache(query: Query): this;
    userSets(key: string, value: JsonObject<unknown>): this;
    userPatches(key: string, value: JsonObject<unknown>): this;
    userDeletes(key: string): this;
    userAddsSnapshotsInSyncListener(): this;
    userRemovesSnapshotsInSyncListener(): this;
    loadBundle(bundleContent: string): this;
    setIndexConfiguration(jsonOrConfiguration: string | IndexConfiguration): this;
    becomeHidden(): this;
    becomeVisible(): this;
    runTimer(timerId: TimerId): this;
    changeUser(uid: string | null): this;
    disableNetwork(): this;
    enableNetwork(): this;
    clearPersistence(): this;
    restart(): this;
    shutdown(): this;
    
    failDatabaseTransactions(...actions: PersistenceAction[]): this;
    
    recoverDatabase(): this;
    expectIsShutdown(): this;
    
    expectIndexes(indexes: FieldIndex[]): this;
    
    expectActiveTargets(...targets: Array<{
        query: Query;
        targetPurpose?: TargetPurpose;
        resumeToken?: string;
        readTime?: TestSnapshotVersion;
        expectedCount?: number;
    }>): this;
    
    expectLimboDocs(...keys: DocumentKey[]): this;
    
    expectEnqueuedLimboDocs(...keys: DocumentKey[]): this;
    
    ackLimbo(version: TestSnapshotVersion, doc: Document): this;
    
    watchRemovesLimboTarget(doc: Document): this;
    
    writeAcks(doc: string, version: TestSnapshotVersion, options?: {
        expectUserCallback?: boolean;
        keepInQueue?: boolean;
    }): this;
    
    failWrite(doc: string, error: RpcError, options?: {
        expectUserCallback?: boolean;
        keepInQueue?: boolean;
    }): this;
    watchAcks(query: Query): this;
    watchCurrents(query: Query, resumeToken: string): this;
    watchRemoves(query: Query, cause?: RpcError): this;
    watchSends(targets: {
        affects?: Query[];
        removed?: Query[];
    }, ...docs: Document[]): this;
    watchRemovesDoc(key: DocumentKey, ...targets: Query[]): this;
    watchDeletesDoc(key: DocumentKey, version: TestSnapshotVersion, ...targets: Query[]): this;
    watchFilters(queries: Query[], docs?: DocumentKey[], bloomFilter?: ProtoBloomFilter): this;
    watchResets(...queries: Query[]): this;
    watchSnapshots(version: TestSnapshotVersion, targets?: Query[], resumeToken?: string): this;
    watchAcksFull(query: Query, version: TestSnapshotVersion, ...docs: Document[]): this;
    watchStreamCloses(error: Code, opts?: {
        runBackoffTimer: boolean;
    }): this;
    waitForPendingWrites(): this;
    expectUserCallbacks(docs: {
        acknowledged?: string[];
        rejected?: string[];
    }): this;
    expectEvents(query: Query, events: {
        fromCache?: boolean;
        hasPendingWrites?: boolean;
        added?: Document[];
        modified?: Document[];
        removed?: Document[];
        metadata?: Document[];
        errorCode?: Code;
    }): this;
    private registerQuery;
    
    expectListen(query: Query, resume?: ResumeSpec): this;
    
    expectListenToCache(query: Query, resume?: ResumeSpec): this;
    removeQuery(query: Query, shouldRemoveWatchTarget?: boolean): this;
    
    expectUnlisten(query: Query): this;
    
    expectUnlistenToCache(query: Query): this;
    
    expectWriteStreamRequestCount(num: number): this;
    
    expectWatchStreamRequestCount(num: number): this;
    expectNumOutstandingWrites(num: number): this;
    expectNumActiveClients(num: number): this;
    expectPrimaryState(isPrimary: boolean): this;
    expectSnapshotsInSyncEvent(count?: number): this;
    expectWaitForPendingWritesEvent(count?: number): this;
    triggerLruGC(cacheThreshold: number): this;
    removeExpectedTargetMapping(query: Query): this;
    private static queryToSpec;
    private static docToSpec;
    private static keyToSpec;
    protected nextStep(): void;
    
    private addQueryToActiveTargets;
    private removeQueryFromActiveTargets;
    private assertStep;
    private getTargetId;
}

export declare class MultiClientSpecBuilder extends SpecBuilder {
    private activeClientIndex;
    private clientStates;
    protected get clientState(): ClientMemoryState;
    client(clientIndex: number): MultiClientSpecBuilder;
    
    stealPrimaryLease(): this;
    protected nextStep(): void;
}

export declare function spec(): SpecBuilder;

export declare function client(num: number): MultiClientSpecBuilder;
