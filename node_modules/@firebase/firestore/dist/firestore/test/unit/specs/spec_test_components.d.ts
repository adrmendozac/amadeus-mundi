
import { Token } from '../../../src/api/credentials';
import { ComponentConfiguration, MemoryOfflineComponentProvider, OnlineComponentProvider, MultiTabOfflineComponentProvider } from '../../../src/core/component_provider';
import { Observer } from '../../../src/core/event_manager';
import { Query } from '../../../src/core/query';
import { ViewSnapshot } from '../../../src/core/view_snapshot';
import { IndexedDbPersistence } from '../../../src/local/indexeddb_persistence';
import { LocalStore } from '../../../src/local/local_store';
import { MemoryPersistence } from '../../../src/local/memory_persistence';
import { Scheduler, Persistence } from '../../../src/local/persistence';
import { PersistencePromise } from '../../../src/local/persistence_promise';
import { PersistenceTransaction, PersistenceTransactionMode } from '../../../src/local/persistence_transaction';
import { SharedClientState } from '../../../src/local/shared_client_state';
import { Mutation } from '../../../src/model/mutation';
import * as api from '../../../src/protos/firestore_proto_api';
import { ApiClientObjectMap } from '../../../src/protos/firestore_proto_api';
import { Connection, Stream } from '../../../src/remote/connection';
import { Datastore } from '../../../src/remote/datastore';
import { StreamBridge } from '../../../src/remote/stream_bridge';
import { AsyncQueue } from '../../../src/util/async_queue';
import { FirestoreError } from '../../../src/util/error';
import { Deferred } from '../../../src/util/promise';
import { WindowLike } from '../../../src/util/types';
import { FakeDocument } from '../../util/test_platform';
import { PersistenceAction } from './spec_test_runner';

export declare class MockMemoryPersistence extends MemoryPersistence {
    injectFailures: PersistenceAction[];
    runTransaction<T>(action: string, mode: PersistenceTransactionMode, transactionOperation: (transaction: PersistenceTransaction) => PersistencePromise<T>): Promise<T>;
}

export declare class MockIndexedDbPersistence extends IndexedDbPersistence {
    injectFailures: PersistenceAction[];
    runTransaction<T>(action: string, mode: PersistenceTransactionMode, transactionOperation: (transaction: PersistenceTransaction) => PersistencePromise<T>): Promise<T>;
}
export declare class MockOnlineComponentProvider extends OnlineComponentProvider {
    private readonly connection;
    constructor(connection: MockConnection);
    createDatastore(cfg: ComponentConfiguration): Datastore;
}
export declare class MockMultiTabOfflineComponentProvider extends MultiTabOfflineComponentProvider {
    private readonly window;
    private readonly document;
    persistence: MockIndexedDbPersistence;
    constructor(window: WindowLike, document: FakeDocument, onlineComponentProvider: OnlineComponentProvider);
    createGarbageCollectionScheduler(cfg: ComponentConfiguration, localStore: LocalStore): Scheduler | null;
    createIndexBackfillerScheduler(cfg: ComponentConfiguration, localStore: LocalStore): Scheduler | null;
    createSharedClientState(cfg: ComponentConfiguration): SharedClientState;
    createPersistence(cfg: ComponentConfiguration): MockIndexedDbPersistence;
}
export declare class MockMemoryOfflineComponentProvider extends MemoryOfflineComponentProvider {
    private readonly eagerGCEnabled;
    persistence: MockMemoryPersistence;
    connection: MockConnection;
    constructor(eagerGCEnabled: boolean);
    createGarbageCollectionScheduler(cfg: ComponentConfiguration): Scheduler | null;
    createPersistence(cfg: ComponentConfiguration): Persistence;
}
export declare class MockConnection implements Connection {
    private queue;
    watchStream: StreamBridge<api.ListenRequest, api.ListenResponse> | null;
    writeStream: StreamBridge<api.WriteRequest, api.WriteResponse> | null;
    
    writeSendBarriers: Array<Deferred<api.WriteRequest>>;
    
    earlyWrites: api.WriteRequest[];
    
    watchStreamRequestCount: number;
    
    writeStreamRequestCount: number;
    nextWriteStreamToken: number;
    constructor(queue: AsyncQueue);
    terminate(): void;
    shouldResourcePathBeIncludedInRequest: boolean;
    
    activeTargets: {
        [targetId: number]: {
            target: api.Target;
            labels?: ApiClientObjectMap<string>;
        };
    };
    
    watchOpen: Deferred<void>;
    
    isWatchOpen: boolean;
    invokeRPC<Req>(rpcName: string, request: Req): never;
    invokeStreamingRPC<Req>(rpcName: string, request: Req): never;
    waitForWriteRequest(): Promise<api.WriteRequest>;
    waitForWatchOpen(): Promise<void>;
    ackWrite(commitTime?: api.Timestamp, mutationResults?: api.WriteResult[]): void;
    failWrite(err: FirestoreError): void;
    private resetAndCloseWriteStream;
    failWatchStream(err?: FirestoreError): void;
    private resetAndCloseWatchStream;
    openStream<Req, Resp>(rpcName: string, token: Token | null): Stream<Req, Resp>;
}

export declare class EventAggregator implements Observer<ViewSnapshot> {
    private query;
    private pushEvent;
    constructor(query: Query, pushEvent: (e: QueryEvent) => void);
    next(view: ViewSnapshot): void;
    error(error: Error): void;
}

export declare class SharedWriteTracker {
    private writes;
    push(write: Mutation[]): void;
    peek(): Mutation[];
    shift(): Mutation[];
}

export interface QueryEvent {
    query: Query;
    view?: ViewSnapshot;
    error?: FirestoreError;
}
