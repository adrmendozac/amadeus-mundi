
import { FirebaseApp } from '@firebase/app';
import { LogLevelString as LogLevel } from '@firebase/logger';
import { EmulatorMockTokenOptions } from '@firebase/util';
import { FirebaseError } from '@firebase/util';


export declare function addDoc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<DocumentReference<AppModelType, DbModelType>>;

export declare type AddPrefixToKeys<Prefix extends string, T extends Record<string, unknown>> = {
    [K in keyof T & string as `${Prefix}.${K}`]+?: string extends K ? any : T[K];
};

export declare class AggregateField<T> {
    
    readonly type = "AggregateField";
    
    readonly aggregateType: AggregateType;
}

export declare function aggregateFieldEqual(left: AggregateField<unknown>, right: AggregateField<unknown>): boolean;

export declare type AggregateFieldType = ReturnType<typeof sum> | ReturnType<typeof average> | ReturnType<typeof count>;

export declare class AggregateQuerySnapshot<AggregateSpecType extends AggregateSpec, AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly type = "AggregateQuerySnapshot";
    
    readonly query: Query<AppModelType, DbModelType>;
    private constructor();
    
    data(): AggregateSpecData<AggregateSpecType>;
}

export declare function aggregateQuerySnapshotEqual<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(left: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>, right: AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>): boolean;

export declare interface AggregateSpec {
    [field: string]: AggregateFieldType;
}

export declare type AggregateSpecData<T extends AggregateSpec> = {
    [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;
};

export declare type AggregateType = 'count' | 'avg' | 'sum';

export declare function and(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

export declare function arrayRemove(...elements: unknown[]): FieldValue;

export declare function arrayUnion(...elements: unknown[]): FieldValue;



export declare function average(field: string | FieldPath): AggregateField<number | null>;

export declare class Bytes {
    private constructor();
    
    static fromBase64String(base64: string): Bytes;
    
    static fromUint8Array(array: Uint8Array): Bytes;
    
    toBase64(): string;
    
    toUint8Array(): Uint8Array;
    
    toString(): string;
    
    isEqual(other: Bytes): boolean;
    
    toJSON(): object;
    
    static fromJSON(json: object): Bytes;
}


export declare const CACHE_SIZE_UNLIMITED = -1;

export declare type ChildUpdateFields<K extends string, V> = V extends Record<string, unknown> ? AddPrefixToKeys<K, UpdateData<V>> : never;

export declare function clearIndexedDbPersistence(firestore: Firestore): Promise<void>;

export declare function collection(firestore: Firestore, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

export declare function collection<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

export declare function collection<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

export declare function collectionGroup(firestore: Firestore, collectionId: string): Query<DocumentData, DocumentData>;

export declare class CollectionReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends Query<AppModelType, DbModelType> {
    
    readonly type = "collection";
    private constructor();
    
    get id(): string;
    
    get path(): string;
    
    get parent(): DocumentReference<DocumentData, DocumentData> | null;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): CollectionReference<NewAppModelType, NewDbModelType>;
    
    withConverter(converter: null): CollectionReference<DocumentData, DocumentData>;
}

export declare function connectFirestoreEmulator(firestore: Firestore, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;

export declare function count(): AggregateField<number>;

export declare function deleteAllPersistentCacheIndexes(indexManager: PersistentCacheIndexManager): void;

export declare function deleteDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<void>;

export declare function deleteField(): FieldValue;

export declare function disableNetwork(firestore: Firestore): Promise<void>;

export declare function disablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

export declare function doc(firestore: Firestore, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

export declare function doc<AppModelType, DbModelType extends DocumentData>(reference: CollectionReference<AppModelType, DbModelType>, path?: string, ...pathSegments: string[]): DocumentReference<AppModelType, DbModelType>;

export declare function doc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

export declare interface DocumentChange<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly type: DocumentChangeType;
    
    readonly doc: QueryDocumentSnapshot<AppModelType, DbModelType>;
    
    readonly oldIndex: number;
    
    readonly newIndex: number;
}

export declare type DocumentChangeType = 'added' | 'removed' | 'modified';

export declare interface DocumentData {
    
    [field: string]: any;
}

export declare function documentId(): FieldPath;

export declare class DocumentReference<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly converter: FirestoreDataConverter<AppModelType, DbModelType> | null;
    
    readonly type = "document";
    
    readonly firestore: Firestore;
    private constructor();
    
    get id(): string;
    
    get path(): string;
    
    get parent(): CollectionReference<AppModelType, DbModelType>;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): DocumentReference<NewAppModelType, NewDbModelType>;
    
    withConverter(converter: null): DocumentReference<DocumentData, DocumentData>;
    
    toJSON(): object;
    
    static fromJSON(firestore: Firestore, json: object): DocumentReference;
    
    static fromJSON<NewAppModelType = DocumentData, NewDbModelType extends DocumentData = DocumentData>(firestore: Firestore, json: object, converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): DocumentReference<NewAppModelType, NewDbModelType>;
}

export declare class DocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly metadata: SnapshotMetadata;
    protected constructor();
    
    exists(): this is QueryDocumentSnapshot<AppModelType, DbModelType>;
    
    data(options?: SnapshotOptions): AppModelType | undefined;
    
    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;
    
    toJSON(): object;
    
    get id(): string;
    
    get ref(): DocumentReference<AppModelType, DbModelType>;
}

export declare function documentSnapshotFromJSON(db: Firestore, json: object): DocumentSnapshot;

export declare function documentSnapshotFromJSON<AppModelType, DbModelType extends DocumentData = DocumentData>(db: Firestore, json: object, converter: FirestoreDataConverter<AppModelType, DbModelType>): DocumentSnapshot<AppModelType, DbModelType>;


export { EmulatorMockTokenOptions };

export declare function enableIndexedDbPersistence(firestore: Firestore, persistenceSettings?: PersistenceSettings): Promise<void>;

export declare function enableMultiTabIndexedDbPersistence(firestore: Firestore): Promise<void>;

export declare function enableNetwork(firestore: Firestore): Promise<void>;

export declare function enablePersistentCacheIndexAutoCreation(indexManager: PersistentCacheIndexManager): void;

export declare function endAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryEndAtConstraint;

export declare function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;

export declare function endBefore<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryEndAtConstraint;

export declare function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;



export declare interface ExperimentalLongPollingOptions {
    
    timeoutSeconds?: number;
}

export declare class FieldPath {
    
    constructor(...fieldNames: string[]);
    
    isEqual(other: FieldPath): boolean;
}

export declare abstract class FieldValue {
    private constructor();
    
    abstract isEqual(other: FieldValue): boolean;
}


export declare class Firestore {
    
    type: 'firestore-lite' | 'firestore';
    private constructor();
    
    get app(): FirebaseApp;
    
    toJSON(): object;
}

export declare interface FirestoreDataConverter<AppModelType, DbModelType extends DocumentData = DocumentData> {
    
    toFirestore(modelObject: WithFieldValue<AppModelType>): WithFieldValue<DbModelType>;
    
    toFirestore(modelObject: PartialWithFieldValue<AppModelType>, options: SetOptions): PartialWithFieldValue<DbModelType>;
    
    fromFirestore(snapshot: QueryDocumentSnapshot<DocumentData, DocumentData>, options?: SnapshotOptions): AppModelType;
}

export declare class FirestoreError extends FirebaseError {
    
    readonly code: FirestoreErrorCode;
    
    readonly message: string;
    
    readonly stack?: string;
    private constructor();
}

export declare type FirestoreErrorCode = 'cancelled' | 'unknown' | 'invalid-argument' | 'deadline-exceeded' | 'not-found' | 'already-exists' | 'permission-denied' | 'resource-exhausted' | 'failed-precondition' | 'aborted' | 'out-of-range' | 'unimplemented' | 'internal' | 'unavailable' | 'data-loss' | 'unauthenticated';

export declare type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;

export declare interface FirestoreSettings {
    
    cacheSizeBytes?: number;
    
    localCache?: FirestoreLocalCache;
    
    experimentalForceLongPolling?: boolean;
    
    experimentalAutoDetectLongPolling?: boolean;
    
    experimentalLongPollingOptions?: ExperimentalLongPollingOptions;
    
    host?: string;
    
    ssl?: boolean;
    
    ignoreUndefinedProperties?: boolean;
}

export declare class GeoPoint {
    
    constructor(latitude: number, longitude: number);
    
    get latitude(): number;
    
    get longitude(): number;
    
    isEqual(other: GeoPoint): boolean;
    
    toJSON(): {
        latitude: number;
        longitude: number;
        type: string;
    };
    
    static fromJSON(json: object): GeoPoint;
}

export declare function getAggregateFromServer<AggregateSpecType extends AggregateSpec, AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, aggregateSpec: AggregateSpecType): Promise<AggregateQuerySnapshot<AggregateSpecType, AppModelType, DbModelType>>;

export declare function getCountFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<AggregateQuerySnapshot<{
    count: AggregateField<number>;
}, AppModelType, DbModelType>>;

export declare function getDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

export declare function getDocFromCache<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

export declare function getDocFromServer<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;

export declare function getDocs<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

export declare function getDocsFromCache<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

export declare function getDocsFromServer<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>): Promise<QuerySnapshot<AppModelType, DbModelType>>;

export declare function getFirestore(): Firestore;

export declare function getFirestore(app: FirebaseApp): Firestore;

export declare function getFirestore(databaseId: string): Firestore;

export declare function getFirestore(app: FirebaseApp, databaseId: string): Firestore;

export declare function getPersistentCacheIndexManager(firestore: Firestore): PersistentCacheIndexManager | null;

export declare function increment(n: number): FieldValue;

export declare interface Index {
    
    readonly collectionGroup: string;
    
    readonly fields?: IndexField[];
    [key: string]: unknown;
}

export declare interface IndexConfiguration {
    
    readonly indexes?: Index[];
    [key: string]: unknown;
}

export declare interface IndexField {
    
    readonly fieldPath: string;
    
    readonly arrayConfig?: 'CONTAINS';
    
    readonly order?: 'ASCENDING' | 'DESCENDING';
    [key: string]: unknown;
}

export declare function initializeFirestore(app: FirebaseApp, settings: FirestoreSettings, databaseId?: string): Firestore;

export declare function limit(limit: number): QueryLimitConstraint;

export declare function limitToLast(limit: number): QueryLimitConstraint;

export declare type ListenSource = 'default' | 'cache';

export declare function loadBundle(firestore: Firestore, bundleData: ReadableStream<Uint8Array> | ArrayBuffer | string): LoadBundleTask;

export declare class LoadBundleTask implements PromiseLike<LoadBundleTaskProgress> {
    
    onProgress(next?: (progress: LoadBundleTaskProgress) => unknown, error?: (err: Error) => unknown, complete?: () => void): void;
    
    catch<R>(onRejected: (a: Error) => R | PromiseLike<R>): Promise<R | LoadBundleTaskProgress>;
    
    then<T, R>(onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>, onRejected?: (a: Error) => R | PromiseLike<R>): Promise<T | R>;
}

export declare interface LoadBundleTaskProgress {
    
    documentsLoaded: number;
    
    totalDocuments: number;
    
    bytesLoaded: number;
    
    totalBytes: number;
    
    taskState: TaskState;
}
export { LogLevel };

export declare interface MemoryCacheSettings {
    
    garbageCollector?: MemoryGarbageCollector;
}

export declare interface MemoryEagerGarbageCollector {
    kind: 'memoryEager';
}

export declare function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector;

export declare type MemoryGarbageCollector = MemoryEagerGarbageCollector | MemoryLruGarbageCollector;

export declare interface MemoryLocalCache {
    kind: 'memory';
}

export declare function memoryLocalCache(settings?: MemoryCacheSettings): MemoryLocalCache;

export declare interface MemoryLruGarbageCollector {
    kind: 'memoryLru';
}

export declare function memoryLruGarbageCollector(settings?: {
    cacheSizeBytes?: number;
}): MemoryLruGarbageCollector;

export declare function namedQuery(firestore: Firestore, name: string): Promise<Query | null>;

export declare type NestedUpdateFields<T extends Record<string, unknown>> = UnionToIntersection<{
    [K in keyof T & string]: ChildUpdateFields<K, T[K]>;
}[keyof T & string]>;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

export declare function onSnapshot<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, observer: {
    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, observer: {
    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, observer: {
    next: (snapshot: QuerySnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotResume<AppModelType, DbModelType extends DocumentData>(firestore: Firestore, snapshotJson: object, options: SnapshotListenOptions, observer: {
    next: (snapshot: DocumentSnapshot<AppModelType, DbModelType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}, converter?: FirestoreDataConverter<DbModelType>): Unsubscribe;

export declare function onSnapshotsInSync(firestore: Firestore, observer: {
    next?: (value: void) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

export declare function onSnapshotsInSync(firestore: Firestore, onSync: () => void): Unsubscribe;

export declare function or(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

export declare function orderBy(fieldPath: string | FieldPath, directionStr?: OrderByDirection): QueryOrderByConstraint;

export declare type OrderByDirection = 'desc' | 'asc';

export declare type PartialWithFieldValue<T> = Partial<T> | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: PartialWithFieldValue<T[K]> | FieldValue;
} : never);

export declare interface PersistenceSettings {
    
    forceOwnership?: boolean;
}

export declare class PersistentCacheIndexManager {
    
    readonly type: 'PersistentCacheIndexManager';
    private constructor();
}

export declare interface PersistentCacheSettings {
    
    cacheSizeBytes?: number;
    
    tabManager?: PersistentTabManager;
}

export declare interface PersistentLocalCache {
    kind: 'persistent';
}

export declare function persistentLocalCache(settings?: PersistentCacheSettings): PersistentLocalCache;

export declare interface PersistentMultipleTabManager {
    kind: 'PersistentMultipleTab';
}

export declare function persistentMultipleTabManager(): PersistentMultipleTabManager;

export declare interface PersistentSingleTabManager {
    kind: 'persistentSingleTab';
}

export declare function persistentSingleTabManager(settings: PersistentSingleTabManagerSettings | undefined): PersistentSingleTabManager;

export declare interface PersistentSingleTabManagerSettings {
    
    forceOwnership?: boolean;
}

export declare type PersistentTabManager = PersistentSingleTabManager | PersistentMultipleTabManager;


export declare type Primitive = string | number | boolean | undefined | null;

export declare class Query<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly converter: FirestoreDataConverter<AppModelType, DbModelType> | null;
    
    readonly type: 'query' | 'collection';
    
    readonly firestore: Firestore;
    protected constructor();
    
    withConverter(converter: null): Query<DocumentData, DocumentData>;
    
    withConverter<NewAppModelType, NewDbModelType extends DocumentData = DocumentData>(converter: FirestoreDataConverter<NewAppModelType, NewDbModelType>): Query<NewAppModelType, NewDbModelType>;
}

export declare function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, compositeFilter: QueryCompositeFilterConstraint, ...queryConstraints: QueryNonFilterConstraint[]): Query<AppModelType, DbModelType>;

export declare function query<AppModelType, DbModelType extends DocumentData>(query: Query<AppModelType, DbModelType>, ...queryConstraints: QueryConstraint[]): Query<AppModelType, DbModelType>;

export declare class QueryCompositeFilterConstraint {
    
    readonly type: 'or' | 'and';
}

export declare abstract class QueryConstraint {
    
    abstract readonly type: QueryConstraintType;
}

export declare type QueryConstraintType = 'where' | 'orderBy' | 'limit' | 'limitToLast' | 'startAt' | 'startAfter' | 'endAt' | 'endBefore';

export declare class QueryDocumentSnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> extends DocumentSnapshot<AppModelType, DbModelType> {
    
    data(options?: SnapshotOptions): AppModelType;
}

export declare class QueryEndAtConstraint extends QueryConstraint {
    
    readonly type: 'endBefore' | 'endAt';
}

export declare function queryEqual<AppModelType, DbModelType extends DocumentData>(left: Query<AppModelType, DbModelType>, right: Query<AppModelType, DbModelType>): boolean;

export declare class QueryFieldFilterConstraint extends QueryConstraint {
    
    readonly type = "where";
}

export declare type QueryFilterConstraint = QueryFieldFilterConstraint | QueryCompositeFilterConstraint;

export declare class QueryLimitConstraint extends QueryConstraint {
    
    readonly type: 'limit' | 'limitToLast';
}

export declare type QueryNonFilterConstraint = QueryOrderByConstraint | QueryLimitConstraint | QueryStartAtConstraint | QueryEndAtConstraint;

export declare class QueryOrderByConstraint extends QueryConstraint {
    
    readonly type = "orderBy";
}

export declare class QuerySnapshot<AppModelType = DocumentData, DbModelType extends DocumentData = DocumentData> {
    
    readonly metadata: SnapshotMetadata;
    
    readonly query: Query<AppModelType, DbModelType>;
    private constructor();
    
    get docs(): Array<QueryDocumentSnapshot<AppModelType, DbModelType>>;
    
    get size(): number;
    
    get empty(): boolean;
    
    forEach(callback: (result: QueryDocumentSnapshot<AppModelType, DbModelType>) => void, thisArg?: unknown): void;
    
    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<AppModelType, DbModelType>>;
    
    toJSON(): object;
}

export declare function querySnapshotFromJSON(db: Firestore, json: object): QuerySnapshot;

export declare function querySnapshotFromJSON<AppModelType, DbModelType extends DocumentData = DocumentData>(db: Firestore, json: object, converter: FirestoreDataConverter<AppModelType, DbModelType>): QuerySnapshot<AppModelType, DbModelType>;

export declare class QueryStartAtConstraint extends QueryConstraint {
    
    readonly type: 'startAt' | 'startAfter';
}

export declare function refEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>, right: DocumentReference<AppModelType, DbModelType> | CollectionReference<AppModelType, DbModelType>): boolean;


export declare function runTransaction<T>(firestore: Firestore, updateFunction: (transaction: Transaction) => Promise<T>, options?: TransactionOptions): Promise<T>;

export declare function serverTimestamp(): FieldValue;

export declare function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): Promise<void>;

export declare function setDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): Promise<void>;

export declare function setIndexConfiguration(firestore: Firestore, configuration: IndexConfiguration): Promise<void>;

export declare function setIndexConfiguration(firestore: Firestore, json: string): Promise<void>;

export declare function setLogLevel(logLevel: LogLevel): void;

export declare type SetOptions = {
    readonly merge?: boolean;
} | {
    readonly mergeFields?: Array<string | FieldPath>;
};

export declare function snapshotEqual<AppModelType, DbModelType extends DocumentData>(left: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>, right: DocumentSnapshot<AppModelType, DbModelType> | QuerySnapshot<AppModelType, DbModelType>): boolean;

export declare interface SnapshotListenOptions {
    
    readonly includeMetadataChanges?: boolean;
    
    readonly source?: ListenSource;
}

export declare class SnapshotMetadata {
    
    readonly hasPendingWrites: boolean;
    
    readonly fromCache: boolean;
    private constructor();
    
    isEqual(other: SnapshotMetadata): boolean;
}

export declare interface SnapshotOptions {
    
    readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
}

export declare function startAfter<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryStartAtConstraint;

export declare function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;

export declare function startAt<AppModelType, DbModelType extends DocumentData>(snapshot: DocumentSnapshot<AppModelType, DbModelType>): QueryStartAtConstraint;

export declare function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;

export declare function sum(field: string | FieldPath): AggregateField<number>;

export declare type TaskState = 'Error' | 'Running' | 'Success';

export declare function terminate(firestore: Firestore): Promise<void>;

export declare class Timestamp {
    
    readonly seconds: number;
    
    readonly nanoseconds: number;
    
    static now(): Timestamp;
    
    static fromDate(date: Date): Timestamp;
    
    static fromMillis(milliseconds: number): Timestamp;
    
    constructor(
    
    seconds: number, 
    
    nanoseconds: number);
    
    toDate(): Date;
    
    toMillis(): number;
    
    isEqual(other: Timestamp): boolean;
    
    toString(): string;
    
    toJSON(): {
        seconds: number;
        nanoseconds: number;
        type: string;
    };
    
    static fromJSON(json: object): Timestamp;
    
    valueOf(): string;
}

export declare class Transaction {
    private constructor();
    
    get<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): Promise<DocumentSnapshot<AppModelType, DbModelType>>;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): this;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): this;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): this;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): this;
    
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): this;
}


export declare interface TransactionOptions {
    
    readonly maxAttempts?: number;
}

export declare type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

export declare interface Unsubscribe {
    
    (): void;
}

export declare type UpdateData<T> = T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: UpdateData<T[K]> | FieldValue;
} & NestedUpdateFields<T> : Partial<T>;

export declare function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): Promise<void>;

export declare function updateDoc<AppModelType, DbModelType extends DocumentData>(reference: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): Promise<void>;

export declare function vector(values?: number[]): VectorValue;

export declare class VectorValue {
    
    
    toArray(): number[];
    
    isEqual(other: VectorValue): boolean;
    
    toJSON(): object;
    
    static fromJSON(json: object): VectorValue;
}

export declare function waitForPendingWrites(firestore: Firestore): Promise<void>;

export declare function where(fieldPath: string | FieldPath, opStr: WhereFilterOp, value: unknown): QueryFieldFilterConstraint;

export declare type WhereFilterOp = '<' | '<=' | '==' | '!=' | '>=' | '>' | 'array-contains' | 'in' | 'array-contains-any' | 'not-in';

export declare type WithFieldValue<T> = T | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]: WithFieldValue<T[K]> | FieldValue;
} : never);

export declare class WriteBatch {
    private constructor();
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: WithFieldValue<AppModelType>): WriteBatch;
    
    set<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: PartialWithFieldValue<AppModelType>, options: SetOptions): WriteBatch;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, data: UpdateData<DbModelType>): WriteBatch;
    
    update<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): WriteBatch;
    
    delete<AppModelType, DbModelType extends DocumentData>(documentRef: DocumentReference<AppModelType, DbModelType>): WriteBatch;
    
    commit(): Promise<void>;
}

export declare function writeBatch(firestore: Firestore): WriteBatch;
export {};
