

export as namespace protobuf;


export function common(name: string, json: { [k: string]: any }): void;

export namespace common {

    
    interface IAny {
        typeUrl?: string;
        bytes?: Uint8Array;
    }

    
    interface IDuration {
        seconds?: (number|Long);
        nanos?: number;
    }

    
    interface ITimestamp {
        seconds?: (number|Long);
        nanos?: number;
    }

    
    interface IEmpty {
    }

    
    interface IStruct {
        fields?: { [k: string]: IValue };
    }

    
    interface IValue {
        kind?: string;
        nullValue?: 0;
        numberValue?: number;
        stringValue?: string;
        boolValue?: boolean;
        structValue?: IStruct;
        listValue?: IListValue;
    }

    
    interface IListValue {
        values?: IValue[];
    }

    
    interface IDoubleValue {
        value?: number;
    }

    
    interface IFloatValue {
        value?: number;
    }

    
    interface IInt64Value {
        value?: (number|Long);
    }

    
    interface IUInt64Value {
        value?: (number|Long);
    }

    
    interface IInt32Value {
        value?: number;
    }

    
    interface IUInt32Value {
        value?: number;
    }

    
    interface IBoolValue {
        value?: boolean;
    }

    
    interface IStringValue {
        value?: string;
    }

    
    interface IBytesValue {
        value?: Uint8Array;
    }

    
    function get(file: string): (INamespace|null);
}


export namespace converter {

    
    function fromObject(mtype: Type): Codegen;

    
    function toObject(mtype: Type): Codegen;
}


export function decoder(mtype: Type): Codegen;


export function encoder(mtype: Type): Codegen;


export class Enum extends ReflectionObject {

    
    constructor(name: string, values?: { [k: string]: number }, options?: { [k: string]: any }, comment?: string, comments?: { [k: string]: string }, valuesOptions?: ({ [k: string]: { [k: string]: any } }|undefined));

    
    public valuesById: { [k: number]: string };

    
    public values: { [k: string]: number };

    
    public comment: (string|null);

    
    public comments: { [k: string]: string };

    
    public valuesOptions?: { [k: string]: { [k: string]: any } };

    
    public _valuesFeatures?: { [k: string]: { [k: string]: any } };

    
    public reserved: (number[]|string)[];

    
    public static fromJSON(name: string, json: IEnum): Enum;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IEnum;

    
    public add(name: string, id: number, comment?: string, options?: ({ [k: string]: any }|undefined)): Enum;

    
    public remove(name: string): Enum;

    
    public isReservedId(id: number): boolean;

    
    public isReservedName(name: string): boolean;
}


export interface IEnum {

    
    values: { [k: string]: number };

    
    options?: { [k: string]: any };
}


export class Field extends FieldBase {

    
    constructor(name: string, id: number, type: string, rule?: (string|{ [k: string]: any }), extend?: (string|{ [k: string]: any }), options?: { [k: string]: any });

    
    public static fromJSON(name: string, json: IField): Field;

    
    public readonly required: boolean;

    
    public readonly optional: boolean;

    
    public readonly delimited: boolean;

    
    public readonly packed: boolean;

    
    public readonly hasPresence: boolean;

    
    public static d<T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]>(fieldId: number, fieldType: ("double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|object), fieldRule?: ("optional"|"required"|"repeated"), defaultValue?: T): FieldDecorator;

    
    public static d<T extends Message<T>>(fieldId: number, fieldType: (Constructor<T>|string), fieldRule?: ("optional"|"required"|"repeated")): FieldDecorator;
}


export class FieldBase extends ReflectionObject {

    
    constructor(name: string, id: number, type: string, rule?: (string|{ [k: string]: any }), extend?: (string|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string);

    
    public type: string;

    
    public id: number;

    
    public extend?: string;

    
    public repeated: boolean;

    
    public map: boolean;

    
    public message: (Type|null);

    
    public partOf: (OneOf|null);

    
    public typeDefault: any;

    
    public defaultValue: any;

    
    public long: boolean;

    
    public bytes: boolean;

    
    public resolvedType: (Type|Enum|null);

    
    public extensionField: (Field|null);

    
    public declaringField: (Field|null);

    
    public comment: (string|null);

    
    public toJSON(toJSONOptions?: IToJSONOptions): IField;

    
    public resolve(): Field;

    
    public _inferLegacyProtoFeatures(edition: (string|undefined)): object;
}


export interface IField {

    
    rule?: string;

    
    type: string;

    
    id: number;

    
    options?: { [k: string]: any };
}


export interface IExtensionField extends IField {

    
    extend: string;
}


type FieldDecorator = (prototype: object, fieldName: string) => void;


type LoadCallback = (error: (Error|null), root?: Root) => void;


export function load(filename: (string|string[]), root: Root, callback: LoadCallback): void;


export function load(filename: (string|string[]), callback: LoadCallback): void;


export function load(filename: (string|string[]), root?: Root): Promise<Root>;


export function loadSync(filename: (string|string[]), root?: Root): Root;


export const build: string;


export function configure(): void;


export class MapField extends FieldBase {

    
    constructor(name: string, id: number, keyType: string, type: string, options?: { [k: string]: any }, comment?: string);

    
    public keyType: string;

    
    public resolvedKeyType: (ReflectionObject|null);

    
    public static fromJSON(name: string, json: IMapField): MapField;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IMapField;

    
    public static d<T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }>(fieldId: number, fieldKeyType: ("int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"), fieldValueType: ("double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|object|Constructor<{}>)): FieldDecorator;
}


export interface IMapField extends IField {

    
    keyType: string;
}


export interface IExtensionMapField extends IMapField {

    
    extend: string;
}


export class Message<T extends object = object> {

    
    constructor(properties?: Properties<T>);

    
    public static readonly $type: Type;

    
    public readonly $type: Type;

    
    public static create<T extends Message<T>>(this: Constructor<T>, properties?: { [k: string]: any }): Message<T>;

    
    public static encode<T extends Message<T>>(this: Constructor<T>, message: (T|{ [k: string]: any }), writer?: Writer): Writer;

    
    public static encodeDelimited<T extends Message<T>>(this: Constructor<T>, message: (T|{ [k: string]: any }), writer?: Writer): Writer;

    
    public static decode<T extends Message<T>>(this: Constructor<T>, reader: (Reader|Uint8Array)): T;

    
    public static decodeDelimited<T extends Message<T>>(this: Constructor<T>, reader: (Reader|Uint8Array)): T;

    
    public static verify(message: { [k: string]: any }): (string|null);

    
    public static fromObject<T extends Message<T>>(this: Constructor<T>, object: { [k: string]: any }): T;

    
    public static toObject<T extends Message<T>>(this: Constructor<T>, message: T, options?: IConversionOptions): { [k: string]: any };

    
    public toJSON(): { [k: string]: any };
}


export class Method extends ReflectionObject {

    
    constructor(name: string, type: (string|undefined), requestType: string, responseType: string, requestStream?: (boolean|{ [k: string]: any }), responseStream?: (boolean|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string, parsedOptions?: { [k: string]: any });

    
    public type: string;

    
    public requestType: string;

    
    public requestStream?: boolean;

    
    public responseType: string;

    
    public responseStream?: boolean;

    
    public resolvedRequestType: (Type|null);

    
    public resolvedResponseType: (Type|null);

    
    public comment: (string|null);

    
    public parsedOptions: any;

    
    public static fromJSON(name: string, json: IMethod): Method;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IMethod;
}


export interface IMethod {

    
    type?: string;

    
    requestType: string;

    
    responseType: string;

    
    requestStream?: boolean;

    
    responseStream?: boolean;

    
    options?: { [k: string]: any };

    
    comment: string;

    
    parsedOptions?: { [k: string]: any };
}


export class Namespace extends NamespaceBase {

    
    constructor(name: string, options?: { [k: string]: any });

    
    public static fromJSON(name: string, json: { [k: string]: any }): Namespace;

    
    public static arrayToJSON(array: ReflectionObject[], toJSONOptions?: IToJSONOptions): ({ [k: string]: any }|undefined);

    
    public static isReservedId(reserved: ((number[]|string)[]|undefined), id: number): boolean;

    
    public static isReservedName(reserved: ((number[]|string)[]|undefined), name: string): boolean;
}


export abstract class NamespaceBase extends ReflectionObject {

    
    public nested?: { [k: string]: ReflectionObject };

    
    protected _needsRecursiveFeatureResolution: boolean;

    
    protected _needsRecursiveResolve: boolean;

    
    public readonly nestedArray: ReflectionObject[];

    
    public toJSON(toJSONOptions?: IToJSONOptions): INamespace;

    
    public addJSON(nestedJson: { [k: string]: AnyNestedObject }): Namespace;

    
    public get(name: string): (ReflectionObject|null);

    
    public getEnum(name: string): { [k: string]: number };

    
    public add(object: ReflectionObject): Namespace;

    
    public remove(object: ReflectionObject): Namespace;

    
    public define(path: (string|string[]), json?: any): Namespace;

    
    public resolveAll(): Namespace;

    
    public lookup(path: (string|string[]), filterTypes: (any|any[]), parentAlreadyChecked?: boolean): (ReflectionObject|null);

    
    public lookup(path: (string|string[]), parentAlreadyChecked?: boolean): (ReflectionObject|null);

    
    public lookupType(path: (string|string[])): Type;

    
    public lookupEnum(path: (string|string[])): Enum;

    
    public lookupTypeOrEnum(path: (string|string[])): Type;

    
    public lookupService(path: (string|string[])): Service;
}


export interface INamespace {

    
    options?: { [k: string]: any };

    
    nested?: { [k: string]: AnyNestedObject };
}


type AnyExtensionField = (IExtensionField|IExtensionMapField);


type AnyNestedObject = (IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf);


export abstract class ReflectionObject {

    
    public options?: { [k: string]: any };

    
    public parsedOptions?: { [k: string]: any[] };

    
    public name: string;

    
    public parent: (Namespace|null);

    
    public resolved: boolean;

    
    public comment: (string|null);

    
    public filename: (string|null);

    
    public readonly root: Root;

    
    public readonly fullName: string;

    
    public toJSON(): { [k: string]: any };

    
    public onAdd(parent: ReflectionObject): void;

    
    public onRemove(parent: ReflectionObject): void;

    
    public resolve(): ReflectionObject;

    
    public _resolveFeaturesRecursive(edition: string): ReflectionObject;

    
    public _resolveFeatures(edition: string): void;

    
    public _inferLegacyProtoFeatures(edition: (string|undefined)): object;

    
    public getOption(name: string): any;

    
    public setOption(name: string, value: any, ifNotSet?: (boolean|undefined)): ReflectionObject;

    
    public setParsedOption(name: string, value: any, propName: string): ReflectionObject;

    
    public setOptions(options: { [k: string]: any }, ifNotSet?: boolean): ReflectionObject;

    
    public toString(): string;

    
    public _editionToJSON(): (string|undefined);
}


export class OneOf extends ReflectionObject {

    
    constructor(name: string, fieldNames?: (string[]|{ [k: string]: any }), options?: { [k: string]: any }, comment?: string);

    
    public oneof: string[];

    
    public readonly fieldsArray: Field[];

    
    public comment: (string|null);

    
    public static fromJSON(name: string, json: IOneOf): OneOf;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IOneOf;

    
    public add(field: Field): OneOf;

    
    public remove(field: Field): OneOf;

    
    public readonly isProto3Optional: boolean;

    
    public static d<T extends string>(...fieldNames: string[]): OneOfDecorator;
}


export interface IOneOf {

    
    oneof: string[];

    
    options?: { [k: string]: any };
}


type OneOfDecorator = (prototype: object, oneofName: string) => void;


export function parse(source: string, options?: IParseOptions): IParserResult;


export interface IParserResult {

    
    package: (string|undefined);

    
    imports: (string[]|undefined);

    
    weakImports: (string[]|undefined);

    
    root: Root;
}


export interface IParseOptions {

    
    keepCase?: boolean;

    
    alternateCommentMode?: boolean;

    
    preferTrailingComment?: boolean;
}


export interface IToJSONOptions {

    
    keepComments?: boolean;
}


export function parse(source: string, root: Root, options?: IParseOptions): IParserResult;


export class Reader {

    
    constructor(buffer: Uint8Array);

    
    public buf: Uint8Array;

    
    public pos: number;

    
    public len: number;

    
    public static create(buffer: (Uint8Array|Buffer)): (Reader|BufferReader);

    
    public uint32(): number;

    
    public int32(): number;

    
    public sint32(): number;

    
    public int64(): Long;

    
    public uint64(): Long;

    
    public sint64(): Long;

    
    public bool(): boolean;

    
    public fixed32(): number;

    
    public sfixed32(): number;

    
    public fixed64(): Long;

    
    public sfixed64(): Long;

    
    public float(): number;

    
    public double(): number;

    
    public bytes(): Uint8Array;

    
    public string(): string;

    
    public skip(length?: number): Reader;

    
    public skipType(wireType: number): Reader;
}


export class BufferReader extends Reader {

    
    constructor(buffer: Buffer);

    
    public bytes(): Buffer;
}


export class Root extends NamespaceBase {

    
    constructor(options?: { [k: string]: any });

    
    public deferred: Field[];

    
    public files: string[];

    
    public static fromJSON(json: INamespace, root?: Root): Root;

    
    public resolvePath(origin: string, target: string): (string|null);

    
    public fetch(path: string, callback: FetchCallback): void;

    
    public load(filename: (string|string[]), options: IParseOptions, callback: LoadCallback): void;

    
    public load(filename: (string|string[]), callback: LoadCallback): void;

    
    public load(filename: (string|string[]), options?: IParseOptions): Promise<Root>;

    
    public loadSync(filename: (string|string[]), options?: IParseOptions): Root;
}


export let roots: { [k: string]: Root };


export namespace rpc {

    
    type ServiceMethodCallback<TRes extends Message<TRes>> = (error: (Error|null), response?: TRes) => void;

    
    type ServiceMethod<TReq extends Message<TReq>, TRes extends Message<TRes>> = (request: (TReq|Properties<TReq>), callback?: rpc.ServiceMethodCallback<TRes>) => Promise<Message<TRes>>;

    
    class Service extends util.EventEmitter {

        
        constructor(rpcImpl: RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean);

        
        public rpcImpl: (RPCImpl|null);

        
        public requestDelimited: boolean;

        
        public responseDelimited: boolean;

        
        public rpcCall<TReq extends Message<TReq>, TRes extends Message<TRes>>(method: (Method|rpc.ServiceMethod<TReq, TRes>), requestCtor: Constructor<TReq>, responseCtor: Constructor<TRes>, request: (TReq|Properties<TReq>), callback: rpc.ServiceMethodCallback<TRes>): void;

        
        public end(endedByRPC?: boolean): rpc.Service;
    }
}


type RPCImpl = (method: (Method|rpc.ServiceMethod<Message<{}>, Message<{}>>), requestData: Uint8Array, callback: RPCImplCallback) => void;


type RPCImplCallback = (error: (Error|null), response?: (Uint8Array|null)) => void;


export class Service extends NamespaceBase {

    
    constructor(name: string, options?: { [k: string]: any });

    
    public methods: { [k: string]: Method };

    
    public static fromJSON(name: string, json: IService): Service;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IService;

    
    public readonly methodsArray: Method[];

    
    public create(rpcImpl: RPCImpl, requestDelimited?: boolean, responseDelimited?: boolean): rpc.Service;
}


export interface IService extends INamespace {

    
    methods: { [k: string]: IMethod };
}


type TokenizerHandleNext = () => (string|null);


type TokenizerHandlePeek = () => (string|null);


type TokenizerHandlePush = (token: string) => void;


type TokenizerHandleSkip = (expected: string, optional?: boolean) => boolean;


type TokenizerHandleCmnt = (line?: number) => (string|null);


export interface ITokenizerHandle {

    
    next: TokenizerHandleNext;

    
    peek: TokenizerHandlePeek;

    
    push: TokenizerHandlePush;

    
    skip: TokenizerHandleSkip;

    
    cmnt: TokenizerHandleCmnt;

    
    line: number;
}


export function tokenize(source: string, alternateCommentMode: boolean): ITokenizerHandle;

export namespace tokenize {

    
    function unescape(str: string): string;
}


export class Type extends NamespaceBase {

    
    constructor(name: string, options?: { [k: string]: any });

    
    public fields: { [k: string]: Field };

    
    public oneofs: { [k: string]: OneOf };

    
    public extensions: number[][];

    
    public reserved: (number[]|string)[];

    
    public readonly fieldsById: { [k: number]: Field };

    
    public readonly fieldsArray: Field[];

    
    public readonly oneofsArray: OneOf[];

    
    public ctor: Constructor<{}>;

    
    public static generateConstructor(mtype: Type): Codegen;

    
    public static fromJSON(name: string, json: IType): Type;

    
    public toJSON(toJSONOptions?: IToJSONOptions): IType;

    
    public add(object: ReflectionObject): Type;

    
    public remove(object: ReflectionObject): Type;

    
    public isReservedId(id: number): boolean;

    
    public isReservedName(name: string): boolean;

    
    public create(properties?: { [k: string]: any }): Message<{}>;

    
    public setup(): Type;

    
    public encode(message: (Message<{}>|{ [k: string]: any }), writer?: Writer): Writer;

    
    public encodeDelimited(message: (Message<{}>|{ [k: string]: any }), writer?: Writer): Writer;

    
    public decode(reader: (Reader|Uint8Array), length?: number): Message<{}>;

    
    public decodeDelimited(reader: (Reader|Uint8Array)): Message<{}>;

    
    public verify(message: { [k: string]: any }): (null|string);

    
    public fromObject(object: { [k: string]: any }): Message<{}>;

    
    public toObject(message: Message<{}>, options?: IConversionOptions): { [k: string]: any };

    
    public static d<T extends Message<T>>(typeName?: string): TypeDecorator<T>;
}


export interface IType extends INamespace {

    
    oneofs?: { [k: string]: IOneOf };

    
    fields: { [k: string]: IField };

    
    extensions?: number[][];

    
    reserved?: (number[]|string)[];

    
    group?: boolean;
}


export interface IConversionOptions {

    
    longs?: Function;

    
    enums?: Function;

    
    bytes?: Function;

    
    defaults?: boolean;

    
    arrays?: boolean;

    
    objects?: boolean;

    
    oneofs?: boolean;

    
    json?: boolean;
}


type TypeDecorator<T extends Message<T>> = (target: Constructor<T>) => void;


export namespace types {

    
    const basic: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number,
        "string": number,
        "bytes": number
    };

    
    const defaults: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": boolean,
        "string": string,
        "bytes": number[],
        "message": null
    };

    
    const long: {
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number
    };

    
    const mapKey: {
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number,
        "string": number
    };

    
    const packed: {
        "double": number,
        "float": number,
        "int32": number,
        "uint32": number,
        "sint32": number,
        "fixed32": number,
        "sfixed32": number,
        "int64": number,
        "uint64": number,
        "sint64": number,
        "fixed64": number,
        "sfixed64": number,
        "bool": number
    };
}


export interface Constructor<T> extends Function {
    new(...params: any[]): T; prototype: T;
}


type Properties<T> = { [P in keyof T]?: T[P] };


export interface Buffer extends Uint8Array {
}


export interface Long {

    
    low: number;

    
    high: number;

    
    unsigned: boolean;
}


type OneOfGetter = () => (string|undefined);


type OneOfSetter = (value: (string|undefined)) => void;


export namespace util {

    
    class LongBits {

        
        constructor(lo: number, hi: number);

        
        public lo: number;

        
        public hi: number;

        
        public static zero: util.LongBits;

        
        public static zeroHash: string;

        
        public static fromNumber(value: number): util.LongBits;

        
        public static from(value: (Long|number|string)): util.LongBits;

        
        public toNumber(unsigned?: boolean): number;

        
        public toLong(unsigned?: boolean): Long;

        
        public static fromHash(hash: string): util.LongBits;

        
        public toHash(): string;

        
        public zzEncode(): util.LongBits;

        
        public zzDecode(): util.LongBits;

        
        public length(): number;
    }

    
    let isNode: boolean;

    
    let global: object;

    
    const emptyArray: any[];

    
    const emptyObject: object;

    
    function isInteger(value: any): boolean;

    
    function isString(value: any): boolean;

    
    function isObject(value: any): boolean;

    
    function isset(obj: object, prop: string): boolean;

    
    function isSet(obj: object, prop: string): boolean;

    
    let Buffer: Constructor<Buffer>;

    
    function newBuffer(sizeOrArray?: (number|number[])): (Uint8Array|Buffer);

    
    let Array: Constructor<Uint8Array>;

    
    let Long: Constructor<Long>;

    
    const key2Re: RegExp;

    
    const key32Re: RegExp;

    
    const key64Re: RegExp;

    
    function longToHash(value: (Long|number)): string;

    
    function longFromHash(hash: string, unsigned?: boolean): (Long|number);

    
    function merge(dst: { [k: string]: any }, src: { [k: string]: any }, ifNotSet?: boolean): { [k: string]: any };

    
    function lcFirst(str: string): string;

    
    function newError(name: string): Constructor<Error>;

    
    class ProtocolError<T extends Message<T>> extends Error {

        
        constructor(message: string, properties?: { [k: string]: any });

        
        public instance: Message<T>;
    }

    
    function oneOfGetter(fieldNames: string[]): OneOfGetter;

    
    function oneOfSetter(fieldNames: string[]): OneOfSetter;

    
    let toJSONOptions: IConversionOptions;

    
    let fs: { [k: string]: any };

    
    function toArray(object: { [k: string]: any }): any[];

    
    function toObject(array: any[]): { [k: string]: any };

    
    function isReserved(name: string): boolean;

    
    function safeProp(prop: string): string;

    
    function ucFirst(str: string): string;

    
    function camelCase(str: string): string;

    
    function compareFieldsById(a: Field, b: Field): number;

    
    function decorateType<T extends Message<T>>(ctor: Constructor<T>, typeName?: string): Type;

    
    function decorateEnum(object: object): Enum;

    
    function setProperty(dst: { [k: string]: any }, path: string, value: object, ifNotSet?: (boolean|undefined)): { [k: string]: any };

    
    let decorateRoot: Root;

    
    function asPromise(fn: asPromiseCallback, ctx: any, ...params: any[]): Promise<any>;

    
    namespace base64 {

        
        function length(string: string): number;

        
        function encode(buffer: Uint8Array, start: number, end: number): string;

        
        function decode(string: string, buffer: Uint8Array, offset: number): number;

        
        function test(string: string): boolean;
    }

    
    function codegen(functionParams: string[], functionName?: string): Codegen;

    namespace codegen {

        
        let verbose: boolean;
    }

    
    function codegen(functionName?: string): Codegen;

    
    class EventEmitter {

        
        constructor();

        
        public on(evt: string, fn: EventEmitterListener, ctx?: any): this;

        
        public off(evt?: string, fn?: EventEmitterListener): this;

        
        public emit(evt: string, ...args: any[]): this;
    }

    
    namespace float {

        
        function writeFloatLE(val: number, buf: Uint8Array, pos: number): void;

        
        function writeFloatBE(val: number, buf: Uint8Array, pos: number): void;

        
        function readFloatLE(buf: Uint8Array, pos: number): number;

        
        function readFloatBE(buf: Uint8Array, pos: number): number;

        
        function writeDoubleLE(val: number, buf: Uint8Array, pos: number): void;

        
        function writeDoubleBE(val: number, buf: Uint8Array, pos: number): void;

        
        function readDoubleLE(buf: Uint8Array, pos: number): number;

        
        function readDoubleBE(buf: Uint8Array, pos: number): number;
    }

    
    function fetch(filename: string, options: IFetchOptions, callback: FetchCallback): void;

    
    function fetch(path: string, callback: FetchCallback): void;

    
    function fetch(path: string, options?: IFetchOptions): Promise<(string|Uint8Array)>;

    
    function inquire(moduleName: string): object;

    
    namespace path {

        
        function isAbsolute(path: string): boolean;

        
        function normalize(path: string): string;

        
        function resolve(originPath: string, includePath: string, alreadyNormalized?: boolean): string;
    }

    
    function pool(alloc: PoolAllocator, slice: PoolSlicer, size?: number): PoolAllocator;

    
    namespace utf8 {

        
        function length(string: string): number;

        
        function read(buffer: Uint8Array, start: number, end: number): string;

        
        function write(string: string, buffer: Uint8Array, offset: number): number;
    }
}


export function verifier(mtype: Type): Codegen;


export const wrappers: { [k: string]: IWrapper };


type WrapperFromObjectConverter = (this: Type, object: { [k: string]: any }) => Message<{}>;


type WrapperToObjectConverter = (this: Type, message: Message<{}>, options?: IConversionOptions) => { [k: string]: any };


export interface IWrapper {

    
    fromObject?: WrapperFromObjectConverter;

    
    toObject?: WrapperToObjectConverter;
}


export class Writer {

    
    constructor();

    
    public len: number;

    
    public head: object;

    
    public tail: object;

    
    public states: (object|null);

    
    public static create(): (BufferWriter|Writer);

    
    public static alloc(size: number): Uint8Array;

    
    public uint32(value: number): Writer;

    
    public int32(value: number): Writer;

    
    public sint32(value: number): Writer;

    
    public uint64(value: (Long|number|string)): Writer;

    
    public int64(value: (Long|number|string)): Writer;

    
    public sint64(value: (Long|number|string)): Writer;

    
    public bool(value: boolean): Writer;

    
    public fixed32(value: number): Writer;

    
    public sfixed32(value: number): Writer;

    
    public fixed64(value: (Long|number|string)): Writer;

    
    public sfixed64(value: (Long|number|string)): Writer;

    
    public float(value: number): Writer;

    
    public double(value: number): Writer;

    
    public bytes(value: (Uint8Array|string)): Writer;

    
    public string(value: string): Writer;

    
    public fork(): Writer;

    
    public reset(): Writer;

    
    public ldelim(): Writer;

    
    public finish(): Uint8Array;
}


export class BufferWriter extends Writer {

    
    constructor();

    
    public static alloc(size: number): Buffer;

    
    public finish(): Buffer;
}


type asPromiseCallback = (error: (Error|null), ...params: any[]) => void;


type Codegen = (formatStringOrScope?: (string|{ [k: string]: any }), ...formatParams: any[]) => (Codegen|Function);


type EventEmitterListener = (...args: any[]) => void;


type FetchCallback = (error: Error, contents?: string) => void;


export interface IFetchOptions {

    
    binary?: boolean;

    
    xhr?: boolean;
}


type PoolAllocator = (size: number) => Uint8Array;


type PoolSlicer = (this: Uint8Array, start: number, end: number) => Uint8Array;
